Directory Structure:
-------------------
/ 
├── data/
│   ├── histopathologyDescriptives.omv
│   ├── histopathologyDescriptives.rda
│   ├── oncology_response_data.csv
│   ├── oncology_response_data.omv
│   ├── oncology_response_data.rds
│   ├── percent_no_time.csv
│   ├── percent_no_time.omv
│   ├── percent_no_time.rda
│   ├── percent_with_time.csv
│   ├── percent_with_time.omv
│   ├── percent_with_time.rda
│   ├── raw_no_time.csv
│   ├── raw_no_time.omv
│   ├── raw_no_time.rda
│   ├── raw_with_time.csv
│   ├── raw_with_time.omv
│   ├── raw_with_time.rda
│   ├── treatmentResponse.omv
│   ├── treatmentResponse.rda
│   ├── tumor_response_data.csv
│   ├── tumor_response_data.omv
│   └── tumor_response_examples.rda
├── docs/
│   ├── reference/
│   │   ├── agepyramid.html
│   │   ├── agepyramidClass.html
│   │   ├── alluvial.html
│   │   ├── alluvialClass.html
│   │   ├── benford.html
│   │   ├── ClinicoPath-package.html
│   │   ├── crosstable.html
│   │   ├── crosstableClass.html
│   │   ├── histopathology.html
│   │   ├── index.html
│   │   ├── reportcat.html
│   │   ├── reportcatClass.html
│   │   ├── Rplot001.png
│   │   ├── summarydata.html
│   │   ├── summarydataClass.html
│   │   ├── tableone.html
│   │   ├── tableoneClass.html
│   │   ├── venn.html
│   │   └── vennClass.html
│   ├── 404.html
│   ├── authors.html
│   ├── bootstrap-toc.css
│   ├── bootstrap-toc.js
│   ├── docsearch.css
│   ├── docsearch.js
│   ├── index.html
│   ├── link.svg
│   ├── pkgdown.css
│   ├── pkgdown.js
│   ├── pkgdown.yml
│   └── sitemap.xml
├── jamovi/
│   ├── 0000.yaml
│   ├── 00refs.yaml
│   ├── agepyramid.a.yaml
│   ├── agepyramid.r.yaml
│   ├── agepyramid.u.yaml
│   ├── alluvial.a.yaml
│   ├── alluvial.r.yaml
│   ├── alluvial.u.yaml
│   ├── benford.a.yaml
│   ├── benford.r.yaml
│   ├── benford.u.yaml
│   ├── crosstable.a.yaml
│   ├── crosstable.r.yaml
│   ├── crosstable.u.yaml
│   ├── reportcat.a.yaml
│   ├── reportcat.r.yaml
│   ├── reportcat.u.yaml
│   ├── summarydata.a.yaml
│   ├── summarydata.r.yaml
│   ├── summarydata.u.yaml
│   ├── tableone.a.yaml
│   ├── tableone.r.yaml
│   ├── tableone.u.yaml
│   ├── vartree.a.yaml
│   ├── vartree.r.yaml
│   ├── vartree.u.yaml
│   ├── venn.a.yaml
│   ├── venn.r.yaml
│   ├── venn.u.yaml
│   ├── waterfall.a.yaml
│   ├── waterfall.r.yaml
│   └── waterfall.u.yaml
├── man/
│   ├── agepyramid.Rd
│   ├── agepyramidClass.Rd
│   ├── alluvial.Rd
│   ├── alluvialClass.Rd
│   ├── benford.Rd
│   ├── ClinicoPathDescriptives-package.Rd
│   ├── crosstable.Rd
│   ├── crosstableClass.Rd
│   ├── format_posthoc_html.Rd
│   ├── histopathology.Rd
│   ├── perform_pairwise_chisq.Rd
│   ├── perform_pairwise_tests.Rd
│   ├── perform_residuals_analysis.Rd
│   ├── reportcat.Rd
│   ├── reportcatClass.Rd
│   ├── summarydata.Rd
│   ├── summarydataClass.Rd
│   ├── tableone.Rd
│   ├── tableoneClass.Rd
│   ├── tumor_response_examples.Rd
│   ├── vartree.Rd
│   ├── vartreeClass.Rd
│   ├── venn.Rd
│   ├── vennClass.Rd
│   ├── waterfall.Rd
│   └── waterfallClass.Rd
├── R/
│   ├── 00jmv.R
│   ├── agepyramid.b.R
│   ├── agepyramid.h.R
│   ├── alluvial.b.R
│   ├── alluvial.h.R
│   ├── benford.b.R
│   ├── benford.h.R
│   ├── ClinicoPathDescriptives-package.R
│   ├── crosstable.b.R
│   ├── crosstable.h.R
│   ├── data-histopathology.R
│   ├── data-treatmentResponse.R
│   ├── posthoc_utils.R
│   ├── reportcat.b.R
│   ├── reportcat.h.R
│   ├── summarydata.b.R
│   ├── summarydata.h.R
│   ├── tableone.b.R
│   ├── tableone.h.R
│   ├── tumor_response_examples.R
│   ├── utils.R
│   ├── vartree.b.R
│   ├── vartree.h.R
│   ├── venn.b.R
│   ├── venn.h.R
│   ├── waterfall.b.R
│   └── waterfall.h.R
├── .gitattributes
├── ClinicoPathDescriptives.code-workspace
├── ClinicoPathDescriptives.Rproj
├── DESCRIPTION
├── LICENSE.md
├── NAMESPACE
└── README.md

File Contents:
--------------
File: jamovi\0000.yaml
--------------------------------------------------
Content of jamovi\0000.yaml:
---
title: Descriptives Functions for Clinicopathological Research
name: ClinicoPathDescriptives
version: 0.0.2.45
jms: '1.0'
authors:
  - Serdar Balci
maintainer: Serdar Balci <drserdarbalci@gmail.com>
date: '2025-01-10'
type: R
description: >-
  Descriptives Functions for Clinicopathological Research Descriptive functions
  from ClinicoPath jamovi module. ClinicoPath help researchers to generate
  natural language summaries of their dataset, generate cross tables with
  statistical tests, and survival analysis with survival tables, survival plots,
  and natural language summaries.
analyses:
  - title: Table One
    name: tableone
    ns: ClinicoPathDescriptives
    menuGroup: Exploration
    menuSubgroup: ClinicoPath Descriptives
    menuTitle: Table One
    description: Function for making Table One.
  - title: Summary of Continuous Variables
    name: summarydata
    ns: ClinicoPathDescriptives
    menuGroup: Exploration
    menuSubgroup: ClinicoPath Descriptives
    menuTitle: Summary of Continuous Variables
    description: Function for Generating Summaries for Continuous Variables.
  - title: Summary of Categorical Variables
    name: reportcat
    ns: ClinicoPathDescriptives
    menuGroup: Exploration
    menuSubgroup: ClinicoPath Descriptives
    menuTitle: Summary of Categorical Variables
    description: Function for Generating Summaries for Categorical Variables.
  - title: Alluvial Diagrams
    name: alluvial
    ns: ClinicoPathDescriptives
    menuGroup: Exploration
    menuSubgroup: ClinicoPath Descriptive Plots
    menuTitle: Alluvial Diagrams
  - title: Cross Tables
    name: crosstable
    ns: ClinicoPathDescriptives
    menuGroup: Exploration
    menuSubgroup: ClinicoPath Comparisons
    menuTitle: Cross Tables
    description: Function for making Cross Tables.
  - title: Age Pyramid
    name: agepyramid
    ns: ClinicoPathDescriptives
    menuGroup: Exploration
    menuSubgroup: ClinicoPath Descriptive Plots
    menuTitle: Age Pyramid
  - title: Benford Analysis
    name: benford
    ns: ClinicoPathDescriptives
    menuGroup: Exploration
    menuSubgroup: ClinicoPath Descriptives
    menuTitle: Benford Analysis
  - title: Venn Diagram
    name: venn
    ns: ClinicoPathDescriptives
    menuGroup: Exploration
    menuSubgroup: ClinicoPath Descriptive Plots
    menuTitle: Venn Diagram
  - title: Variable Tree
    name: vartree
    ns: ClinicoPathDescriptives
    menuGroup: Exploration
    menuSubgroup: ClinicoPath Descriptive Plots
    menuTitle: Variable Tree
    description: Function for Generating Tree Summaries of Variables.
  - title: Treatment Response Waterfall Plot
    name: waterfall
    ns: ClinicoPathDescriptives
    menuGroup: Exploration
    menuTitle: Treatment Response Waterfall Plot
    menuSubgroup: ClinicoPath Descriptive Plots
    description: >-
      Creates a waterfall plot to visualize tumor response data following RECIST
      criteria.
datasets:
  - name: histopathology including analysis
    path: histopathologyDescriptives.omv
    description: Example analysis for descriptive functions.
    tags:
      - Table One
      - Data Summary
      - Cross Tables
      - Alluvial Diagrams
      - Venn Diagrams
  - name: treatmentResponse
    path: treatmentResponse.omv
    description: Example analysis for treatment response.
    tags:
      - Oncology
      - Water Fall
      - Treatment Response
usesNative: true
minApp: 1.6.0

...


File: jamovi\00refs.yaml
--------------------------------------------------
Content of jamovi\00refs.yaml:
---
refs:
    emmeans:
        type: 'software'
        author: Lenth, R.
        year: 2018
        title: 'emmeans: Estimated Marginal Means, aka Least-Squares Means'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=emmeans'
        url: https://CRAN.R-project.org/package=emmeans

    afex:
        type: 'software'
        author: Singmann, H.
        year: 2018
        title: 'afex: Analysis of Factorial Experiments'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=afex'
        url: https://CRAN.R-project.org/package=afex

    R:
        type: 'software'
        author: R Core Team
        year: 2018
        title: 'A Language and Envionment for Statistical Computing'
        publisher: '[Computer software]. Retrieved from https://CRAN.R-project.org/'
        url: https://CRAN.R-project.org/

    BF:
        type: 'software'
        author: Morey, R. D., & Rouder, J. N.
        year: 2018
        title: 'BayesFactor: Computation of Bayes Factors for Common Designs'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=BayesFactor'
        url: https://CRAN.R-project.org/package=BayesFactor

    btt:
        type: 'article'
        author: Rouder, J. N., Speckman, P. L., Sun, D., Morey, R. D., & Iverson, G.
        year: 2009
        title: Bayesian t tests for accepting and rejecting the null hypothesis
        publisher: Psychonomic Bulletin & Review
        volume: 16
        pages: 225-237

    car:
        type: 'software'
        author: Fox, J., & Weisberg, S.
        year: 2018
        title: 'car: Companion to Applied Regression'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=car'
        url: https://CRAN.R-project.org/package=car

    ggplot2:
        type: 'software'
        author: Wickham, H., Chang, W., Henry, L., Pedersen, T. L., Takahashi, K., Wilke, C., Woo, K., & RStudio
        year: 2018
        title: 'ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ggplot2'
        url: https://CRAN.R-project.org/package=ggplot2

    ggridges:
        type: 'software'
        author: Wilke, C., & RStudio
        year: 2018
        title: 'ggridges: Ridgeline Plots in ggplot2'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ggridges'
        url: https://CRAN.R-project.org/package=ggridges

    mvnormtest:
        type: 'software'
        author: Jarek, S.
        year: 2012
        title: 'mvnormtest: Normality test for multivariate variables'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=mvnormtest'
        url: https://CRAN.R-project.org/package=mvnormtest

    PMCMR:
        type: 'software'
        author: Pohlert, T.
        year: 2018
        title: 'PMCMR: Calculate Pairwise Multiple Comparisons of Mean Rank Sums'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=PMCMR'
        url: https://CRAN.R-project.org/package=PMCMR

    ROCR:
        type: 'software'
        author: Sing, T., Sander, O., Beerenwinkel, N., & Lengauer, T.
        year: 2015
        title: 'ROCR: Visualizing the Performance of Scoring Classifiers'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ROCR'
        url: https://CRAN.R-project.org/package=ROCR

    nnet:
        type: 'software'
        author: Ripley, B., Venables W.
        year: 2016
        title: 'nnet: Feed-Forward Neural Networks and Multinomial Log-Linear Models'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=nnet'
        url: https://CRAN.R-project.org/package=nnet

    MASS:
        type: 'software'
        author: Ripley, B., Venables W., Bates, D. M., Hornik, K., Gebhardt, A., & Firth, D.
        year: 2018
        title: "MASS: Support Functions and Datasets for Venables and Ripley's MASS"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=MASS'
        url: https://CRAN.R-project.org/package=MASS

    vcd:
        type: 'software'
        author: Meyer, D., Zeileis, A., Hornik, K., Gerber, F., & Friendly, M.
        year: 2017
        title: "vcd: Visualizing Categorical Data"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=vcd'
        url: https://CRAN.R-project.org/package=vcd

    vcdExtra:
        type: 'software'
        author: Friendly M., Turner, H., Zeileis, A., Murdoch, D., & Firth, D.
        year: 2017
        title: "vcdExtra: 'vcd' Extensions and Additions"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=vcdExtra'
        url: https://CRAN.R-project.org/package=vcdExtra

    exact2x2:
        type: 'software'
        author: Fay, M. P., Hunsberger, S. A., Nason, M., & Gabriel, E.
        year: 2018
        title: "exact2x2: Exact Tests and Confidence Intervals for 2x2 Tables"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=exact2x2'
        url: https://CRAN.R-project.org/package=exact2x2

    psych:
        type: 'software'
        author: Revelle, W.
        year: 2019
        title: "psych: Procedures for Psychological, Psychometric, and Personality Research"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=psych'
        url: https://CRAN.R-project.org/package=psych

    lavaan:
        type: 'software'
        author: Rosseel, Y., et al.
        year: 2018
        title: "lavaan: Latent Variable Analysis"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=lavaan'
        url: https://CRAN.R-project.org/package=lavaan

    semPlot:
        type: 'software'
        author: Epskamp, S.
        year: 2017
        title: "semPlot: Path Diagrams and Visual Analysis of Various SEM Packages' Output"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=semPlot'
        url: https://CRAN.R-project.org/package=semPlot

    ggstatsplot:
        type: 'software'
        author: Patil, I.
        year: 2018
        title: "ggstatsplot: 'ggplot2' Based Plots with Statistical Details"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ggstatsplot'
        url: https://CRAN.R-project.org/package=ggstatsplot
        doi: '10.5281/zenodo.2074621'

    report:
        type: 'software'
        author: Makowski, Dominique, Lüdecke, Daniel
        year: 2019
        title: "The report package for R: Ensuring the use of best practices for results reporting"
        publisher: '[R package]. Retrieved from https://github.com/easystats/report'
        url: https://github.com/easystats/report

    arsenal:
        type: 'software'
        author: Heinzen, E Sinnwell, J Atkinson, E Gunderson, T Dougherty, G
        year: 2018
        title: "arsenal: An Arsenal of 'R' Functions for Large-Scale Statistical Summaries"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=arsenal'
        url: https://CRAN.R-project.org/package=arsenal

    tangram:
        type: 'software'
        author: Garbett, S.
        year: 2018
        title: "tangram: The Grammar of Tables"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=tangram'
        url: https://CRAN.R-project.org/package=tangram

    irr:
        type: 'software'
        author: Matthias Gamer, Jim Lemon, Ian Fellows, Puspendra Singh
        year: 2019
        title: "Various Coefficients of Interrater Reliability and Agreement."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=irr'
        url: https://CRAN.R-project.org/package=irr

    tableone:
        type: 'software'
        author: Kazuki, Y.
        year: 2019
        title: "tableone: Create 'Table 1' to Describe Baseline Characteristics"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=tableone'
        url: https://CRAN.R-project.org/package=tableone

    janitor:
        type: 'software'
        author: Firke, S.
        year: 2019
        title: "janitor: Simple Tools for Examining and Cleaning Dirty Data."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=janitor'
        url: https://CRAN.R-project.org/package=janitor


    finalfit:
        type: 'software'
        author: Ewen Harrison and Tom Drake and Riinu Ots
        year: 2019
        title: "finalfit: Quickly Create Elegant Regression Results Tables and Plots when Modelling"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=finalfit'
        url: https://CRAN.R-project.org/package=finalfit


    caret:
        type: 'software'
        author: Max Kuhn
        year: 2020
        title: "caret: Classification and Regression Training"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=caret'
        url: https://CRAN.R-project.org/package=caret

    psycho:
        type: 'software'
        author: Makowski, D.
        year: 2018
        title: "The Psycho Package: An Efficient and Publishing-Oriented Workflow for Psychological Science. Journal of Open Source Software, 3(22), 470."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=psycho.R'
        url: https://CRAN.R-project.org/package=psycho.R

    survival:
        type: 'software'
        author: Terry M Therneau, Thomas Lumley
        year: 2019
        title: "survival: Survival Analysis"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=survival'
        url: https://CRAN.R-project.org/package=survival

    survminer:
        type: 'software'
        author: Alboukadel Kassambara and Marcin Kosinski and Przemyslaw Biecek
        year: 2019
        title: "survminer: Drawing Survival Curves using 'ggplot2'"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=survminer'
        url: https://CRAN.R-project.org/package=survminer


    ggalluvial:
        type: 'software'
        author: Jason Cory Brunson
        year: 2019
        title: "ggalluvial: Alluvial Plots in 'ggplot2'."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ggalluvial'
        url: https://CRAN.R-project.org/package=ggalluvial

    explore:
        type: 'software'
        author: Roland Krasser
        year: 2020
        title: "explore: Simplifies Exploratory Data Analysis."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=explore'
        url: https://CRAN.R-project.org/package=explore

    FFTrees:
        type: 'software'
        author: Nathaniel Phillips, Hansjoerg Neth, Jan Woike and Wolfgang Gaissmaer
        year: 2019
        title: "FFTrees: Generate, Visualise, and Evaluate Fast-and-Frugal Decision Trees"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=FFTrees'
        url: https://CRAN.R-project.org/package=FFTrees


    rpart:
        type: 'software'
        author: Terry Therneau and Beth Atkinson
        year: 2019
        title: "rpart: Recursive Partitioning and Regression Trees."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=rpart'
        url: https://CRAN.R-project.org/package=rpart

    rpart.plot:
        type: 'software'
        author: Stephen Milborrow
        year: 2019
        title: "rpart.plot: Plot 'rpart' Models: An Enhanced Version of 'plot.rpart'"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=rpart.plot'
        url: https://CRAN.R-project.org/package=rpart.plot

    gtsummary:
        type: 'software'
        author: Daniel D. Sjoberg, Margie Hannum, Karissa Whiting and Emily C. Zabor
        year: 2020
        title: "gtsummary: Presentation-Ready Data Summary and Analytic Result Tables"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=gtsummary'
        url: https://CRAN.R-project.org/package=gtsummary

    rmngb:
        type: 'software'
        author: Antoine Filipovic Pierucci
        year: 2014
        title: "rmngb: Miscellaneous Collection of Functions for Medical Data Analysis"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=rmngb'
        url: https://CRAN.R-project.org/package=rmngb

    RVAideMemoire:
        type: 'software'
        author: Maxime Hervé
        year: 2020
        title: "RVAideMemoire: Testing and Plotting Procedures for Biostatistics"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=RVAideMemoire'
        url: https://CRAN.R-project.org/package=RVAideMemoire


    chisq.posthoc.test:
        type: 'software'
        author: Daniel Ebbert
        year: 2019
        title: "chisq.posthoc.test: A Post Hoc Analysis for Pearson's Chi-Squared Test for Count Data"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=chisq.posthoc.test'
        url: https://CRAN.R-project.org/package=chisq.posthoc.test



    easyalluvial:
        type: 'software'
        author: Bjoern Koneswarakantha
        year: 2019
        title: "easyalluvial: Generate Alluvial Plots with a Single Line of Code."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=easyalluvial'
        url: https://CRAN.R-project.org/package=easyalluvial


    parcats:
        type: 'software'
        author: Bjoern Koneswarakantha
        year: 2019
        title: "parcats: Interactive Parallel Categories Diagrams for 'easyalluvial'"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=parcats'
        url: https://CRAN.R-project.org/package=parcats


    plotROC:
        type: 'software'
        author: Michael C. Sachs
        year: 2017
        title: "plotROC: A Tool for Plotting ROC Curves.Journal of Statistical Software, Code Snippets, 79(2), 1-19. doi:10.18637/jss.v079.c02"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=plotROC'
        url: https://CRAN.R-project.org/package=plotROC


    RGraphGallery:
        type: 'website'
        author: Holtz Yan
        year: 2020
        title: "The R Graph Gallery"
        publisher: 'A website that displays hundreds of R charts https://www.r-graph-gallery.com'
        url: https://github.com/holtzy/R-graph-gallery


    hrbrthemes:
        type: 'software'
        author: Bob Rudis
        year: 2020
        title: "hrbrthemes: Additional Themes, Theme Components and Utilities for 'ggplot2'."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=hrbrthemes'
        url: https://CRAN.R-project.org/package=hrbrthemes


    retractcheck:
        type: 'software'
        author: Chris Hartgerink and Frederik Aust
        year: 2019
        title: "retractcheck: Retraction Scanner"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=retractcheck'
        url: https://CRAN.R-project.org/package=retractcheck


    RefManageR:
        type: 'software'
        author: McLean MW
        year: 2017
        title: 'RefManageR: Import and Manage BibTeX and BibLaTeX References in R. The Journal of Open Source Software.'
        doi: 10.21105/joss.00338
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=RefManageR'
        url: https://CRAN.R-project.org/package=RefManageR


    rcrossref:
        type: 'software'
        author: Scott Chamberlain and Hao Zhu and Najko Jahn and Carl Boettiger and Karthik Ram
        year: 2020
        title: "rcrossref: Client for Various 'CrossRef' 'APIs'"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=rcrossref'
        url: https://CRAN.R-project.org/package=rcrossref


    epiR:
        type: 'software'
        author: >-
            Mark Stevenson with contributions from Telmo Nunes,
            Cord Heuer, Jonathon Marshall, Javier Sanchez, Ron
            Thornton, Jeno Reiczigel, Jim Robison-Cox, Paola
            Sebastiani, Peter Solymos, Kazuki Yoshida, Geoff Jones,
            Sarah Pirikahu, Simon Firestone, Ryan Kyle, Johann
            Popp, Mathew Jay and Charles Reynard.
        year: 2020
        title: "epiR: Tools for the Analysis of Epidemiological Data."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=epiR'
        url: https://CRAN.R-project.org/package=epiR


    KMunicate:
        type: 'software'
        author: Alessandro Gasparini
        year: 2020
        title: "KMunicate: KMunicate-Style Kaplan–Meier Plots"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=KMunicate'
        url: https://CRAN.R-project.org/package=KMunicate


    KMunicate2:
        type: 'article'
        author: Morris TP, Jarvis CI, Cragg W, et al
        title: "Proposals on Kaplan–Meier plots in medical research and a survey of stakeholder views: KMunicate"
        year: 2019
        publisher: 'BMJ Open 2019;9:e030215.'
        doi: 10.1136/bmjopen-2019-030215
        url: https://bmjopen.bmj.com/content/9/9/e030215


    Fagan:
        type: 'software'
        author: Adam Chekroud
        title: "nomogrammer: Fagan's nomograms with ggplot2"
        publisher: 'GitHub'
        year: 2020
        url: https://github.com/achekroud/nomogrammer


    Fagan2:
        type: 'article'
        author:
        title: 'StATS: What is a Fagan nomogram?'
        publisher: 'website'
        year: 2020
        url: http://www.pmean.com/definitions/fagan.htm


    benford.analysis:
        type: 'software'
        author: Carlos Cinelli
        year: 2020
        title: "benford.analysis: Benford Analysis for Data Validation and Forensic Analytics"
        publisher: '[R package]. Retrieved from http://github.com/carloscinelli/benford.analysis'
        url: http://github.com/carloscinelli/benford.analysis


    vtree:
        type: 'software'
        author: Nick Barrowman
        year: 2020
        title: "vtree: Display Information About Nested Subsets of a Data Frame"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=vtree'
        url: https://CRAN.R-project.org/package=vtree


    PathologyKappa:
        type: 'article'
        title: Pathologists should probably forget about kappa. Percent agreement, diagnostic specificity and related metrics provide more clinically applicable measures of interobserver variability
        year: 2020
        author:
        publisher: Annals of Diagnostic Pathology
        volume: 47
        url: https://www.sciencedirect.com/science/article/abs/pii/S1092913420301040


    DiagnosticTests:
        type: 'article'
        title: The Interpretation of SARS-CoV-2 Diagnostic Tests
        year: 2020
        author: Stites EC, Wilen CB.
        publisher:  Med (N Y).
        doi: 10.1016/j.medj.2020.08.001
        url: https://www.cell.com/med/fulltext/S2666-6340(20)30016-7

    dichotomizing:
        type: 'article'
        title: 'Dichotomizing continuous predictors in multiple regression: a bad idea.'
        year: 2006
        author: Royston, P., Altman, D.G. and Sauerbrei, W.
        publisher:  Statist. Med.
        volume: 25
        pages: 127-141
        doi: 10.1002/sim.2331
        url: https://onlinelibrary.wiley.com/doi/abs/10.1002/sim.2331

    bbccookbook:
        type: 'article'
        title: 'BBC Visual and Data Journalism cookbook for R graphics'
        year: 2019
        author: BBC data team
        url: https://bbc.github.io/rcookbook/

    bbplot:
        type: 'software'
        author: Nassos Stylianou and Will william.dahlgreen@bbc.co.uk Dahlgreen and Robert robert.cuffe@bbc.co.uk Cuffe and Tom Calver and Ransome Mpini
        year: 2020
        title: "bbplot: MAKING GGPLOT GRAPHICS IN BBC NEWS STYLE"
        publisher: '[R package]. Retrieved from https://github.com/bbc/bbplot'
        url: https://github.com/bbc/bbplot

    venn:
        type: 'software'
        author: Linlin Yan
        year: 2020
        title: "Venn Diagram by ggplot2, with really easy-to-use API"
        publisher: '[R package]. Retrieved from https://github.com/yanlinlin82/ggvenn'
        url: https://github.com/yanlinlin82/ggvenn

    upset:
        type: 'software'
        author: Jake R Conway, Alexander Lex, Nils Gehlenborg
        year: 2017
        title: "UpSetR: An R Package for the Visualization of Intersecting Sets and their Properties"
        doi: 10.1093/bioinformatics/btx364
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=UpSetR'
        url: https://CRAN.R-project.org/package=UpSetR

    whoisinthisstudy:
        type: 'article'
        author: Hayes-Larson E, Kezios KL, Mooney SJ, Lovasi G.
        year: 2019
        title: "Who is in this study, anyway? Guidelines for a useful Table 1."
        publisher: J Clin Epidemiol.
        volume: 114
        pages: 125-132
        doi: 10.1016/j.jclinepi.2019.06.011
        url: https://pubmed.ncbi.nlm.nih.gov/31229583/


    recist:
        type: 'article'
        author: Eisenhauer EA, Therasse P, Bogaerts J, Schwartz LH, Sargent D, Ford R, Dancey J, Arbuck S, Gwyther S, Mooney M, Rubinstein L, Shankar L, Dodd L, Kaplan R, Lacombe D, Verweij J.
        year: 2009
        title: "New response evaluation criteria in solid tumours: revised RECIST guideline (version 1.1)."
        publisher: Eur J Cancer.
        volume: 45(2)
        pages: 228-47
        doi: 10.1016/j.ejca.2008.10.026
        url: https://pubmed.ncbi.nlm.nih.gov/19097774/


    ClinicoPathJamoviModule:
        type: 'software'
        author: Serdar Balci
        year: 2022
        title: "ClinicoPath jamovi Module doi:10.5281/zenodo.3997188"
        publisher: '[R package]. Retrieved from https://github.com/sbalci/ClinicoPathJamoviModule'
        doi: 10.17605/OSF.IO/9SZUD
        url: https://www.serdarbalci.com/ClinicoPathJamoviModule/


...


File: jamovi\agepyramid.a.yaml
--------------------------------------------------
Content of jamovi\agepyramid.a.yaml:
---
name:  agepyramid
title: Age Pyramid
menuGroup: Exploration
menuSubgroup: ClinicoPath Descriptive Plots
version: '1.0.0'
jas: '1.2'

options:
    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.
          jamovi: >
            The data as a data frame.

    - name: age
      title: Age
      type: Variable
      suggested: [ continuous ]
      permitted: [ numeric ]
      description:
          R: >
            a string naming the variable from `data` that contains the
            continuous values used for the report
          jamovi: >
            a string naming the variable from `data` that contains the
            continuous values used for the report

    - name: gender
      title: Gender
      type: Variable
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]
      description:
          R: >
            a string naming the variable from `data` that contains the
            categorical values used for the report
          jamovi: >
            a string naming the variable from `data` that contains the
            categorical values used for the report
            
    - name: female
      title: Select Female
      type: Level
      variable: (gender)
      description:
          R: >
            a string naming the level from `gender` that contains the
            level female
          jamovi: >
            a string naming the level from `gender` that contains the
            level female

...


File: jamovi\agepyramid.r.yaml
--------------------------------------------------
Content of jamovi\agepyramid.r.yaml:
---
name:  agepyramid
title: Age Pyramid
jrs:   '1.1'

items:


    - name:  pyramidTable
      title: 'Population Data'
      type: Table
      rows: 0
      columns:
      # columns: &idcols
        - name: Pop
          title: "Population"
          type: text
        - name: Female
          title: "Female"
          type: number
        - name: Male
          title: "Male"
          type: number
      clearWith:
          - age
          - gender
          - female



    - name: plot
      title: 'Age Pyramid'
      type: Image
      width:  600
      height: 450
      renderFun: .plot
      requiresData: true
      clearWith:
          - age
          - gender
          - female

refs:
    - ClinicoPathJamoviModule

...


File: jamovi\agepyramid.u.yaml
--------------------------------------------------
Content of jamovi\agepyramid.u.yaml:
title: Age Pyramid
name: agepyramid
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Age
        children:
          - type: VariablesListBox
            name: age
            maxItemCount: 1
            isTarget: true
      - type: TargetLayoutBox
        label: Gender
        children:
          - type: VariablesListBox
            name: gender
            maxItemCount: 1
            isTarget: true
          - type: LevelSelector
            name: female
            enable: (gender)


File: jamovi\alluvial.a.yaml
--------------------------------------------------
Content of jamovi\alluvial.a.yaml:
---
name:  alluvial
title: Alluvial Diagrams
menuGroup: Exploration
menuSubgroup: ClinicoPath Descriptive Plots
version: '1.0.0'
jas: '1.2'
options:
    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.
          jamovi: >
            The data as a data frame.

    - name: vars
      title: Variables
      type: Variables
      description:
          R: >
            a string naming the variables from `data` that contains the
            values used for the Alluvial Diagram.
          jamovi: >
            a string naming the variables from `data` that contains the
            values used for the Alluvial Diagram.

    - name: condensationvar
      title: Condensation Variable
      type: Variable
      description:
          R: >
            The primary variable to be used for condensation.
          jamovi: >
            The primary variable to be used for condensation.

    - name: excl
      title: Exclude missing (NA)
      type: Bool
      default: false
      description:
          R: >
            Exclude missing values from the analysis.
          jamovi: >
            Exclude missing values from the analysis.

    - name: marg
      title: Marginal plots
      type: Bool
      default: false
      description:
          R: >
            Include marginal plots.
          jamovi: >
            Include marginal plots.


    # - name: verb
    #   title: Print plot summary
    #   type: Bool
    #   default: false


    - name: fill
      title: Fill by
      type: List
      options:
        - title: First variable
          name: first_variable
        - title: Last variable
          name: last_variable
        - title: All flows
          name: all_flows
        - title: Values
          name: values
      default: first_variable
      description:
          R: >
            A list for the argument fill for selecting the variable to be
            represented by color. Default is 'first_variable'.
          jamovi: >
            A list for the argument fill for selecting the variable to be
            represented by color. Default is 'first_variable'.

    - name: bin
      title: Bin labels
      type: List
      options:
        - title: Default
          name: default
        - title: Mean
          name: mean
        - title: Median
          name: median
        - title: Min-Max
          name: min_max
        - title: Cuts
          name: cuts
      default: default
      description:
          R: >
            labels for the bins from low to high
          jamovi: >
            labels for the bins from low to high


    - name: orient
      title: Plot orientation
      type: List
      options:
        - title: Horizontal
          name: horr
        - title: Vertical
          name: vert
      default: vert
      description:
          R: >
            Orientation of the plot. Default is 'vertical'.
          jamovi: >
            Orientation of the plot. Default is 'vertical'.




#     - name: flip
#       title: Flip plot
#       type: Bool
#       default: false



    - name: usetitle
      title: Custom title
      type: Bool
      default: false
      description:
          R: >
            Use a custom title for the plot.
          jamovi: >
            Use a custom title for the plot.

    - name: mytitle
      title: Title
      type: String
      default: 'Alluvial Plot'
      description:
          R: >
            Title for the plot.
          jamovi: >
            Title for the plot.


    # - name: originaltheme
    #   title: Easy Alluvial Theme
    #   type: Bool
    #   default: false


    # - name: themex
    #   title: Theme
    #   type: List
    #   options:
    #     - title: jamovi
    #       name: jamovi
    #     - title: easyalluvial
    #       name: easyalluvial
    #     # - title: ipsum
    #     #   name: ipsum
    #     - title: grey
    #       name: grey
    #     - title: gray
    #       name: gray
    #     - title: bw
    #       name: bw
    #     - title: linedraw
    #       name: linedraw
    #     - title: light
    #       name: light
    #     - title: dark
    #       name: dark
    #     - title: minimal
    #       name: minimal
    #     - title: classic
    #       name: classic
    #     - title: void
    #       name: void
    #     - title: test
    #       name: test
    #   default: easyalluvial

# - name: inter
#   title: Interactive
#   type: Bool
#   default: false

...


File: jamovi\alluvial.r.yaml
--------------------------------------------------
Content of jamovi\alluvial.r.yaml:
---
name:  alluvial
title: Alluvial Diagrams
jrs:   '1.1'

items:

    - name:  todo
      title: To Do
      type:  Html
      clearWith:
          - vars

    # - name:  plothtml
    #   title: Plot html
    #   type:  Html
    #   clearWith:
    #       - vars
    #       - excl
    #       - marg
    #       - inter

    - title: Alluvial Diagrams
      name: plot
      type: Image
      width:  600
      height: 450
      renderFun: .plot
      requiresData: true
      clearWith:
          - vars
          - excl
          - marg
          - verb
          - fill
          - bin
          - orient
          - usetitle
          - mytitle
          # - themex
          # - originaltheme


    - title: '`Condensation Plot ${condensationvar}`'
      name: plot2
      type: Image
      width:  600
      height: 450
      renderFun: .plot2
      requiresData: true
      clearWith:
          - vars
          - condensationvar
          # - themex
          # - originaltheme
      visible: (condensationvar)


refs:
    - easyalluvial
    - ClinicoPathJamoviModule
    # - parcats


...


File: jamovi\alluvial.u.yaml
--------------------------------------------------
Content of jamovi\alluvial.u.yaml:
title: Alluvial Diagrams
name: alluvial
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: true
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Variables
        children:
          - type: VariablesListBox
            name: vars
            isTarget: true
      - type: TargetLayoutBox
        label: Condensation Variable
        children:
          - type: VariablesListBox
            name: condensationvar
            maxItemCount: 1
            isTarget: true
  - type: CollapseBox
    label: Options
    stretchFactor: 1
    collapsed: true
    children:
      - type: LayoutBox
        margin: large
        stretchFactor: 1
        children:
          - type: LayoutBox
            cell:
              column: 0
              row: 0
            stretchFactor: 1
            children:
              - type: Label
                label: Output
                fitToGrid: true
                children:
                  - type: CheckBox
                    name: excl
                  - type: CheckBox
                    name: marg
                    enable: (orient:vert && !usetitle)
                  - type: ComboBox
                    name: orient
                    enable: (!marg)
          - type: LayoutBox
            cell:
              column: 1
              row: 0
            stretchFactor: 1
            children:
              - type: Label
                label: Plots
                fitToGrid: true
                cell:
                  column: 1
                  row: 0
                children:
                  - type: ComboBox
                    name: fill
                  - type: ComboBox
                    name: bin
                  - type: CheckBox
                    name: usetitle
                    enable: (!marg)
                    children:
                      - type: TextBox
                        name: mytitle
                        format: string
                        width: large
                        enable: (usetitle)



File: jamovi\benford.a.yaml
--------------------------------------------------
Content of jamovi\benford.a.yaml:
---
name:  benford
title: Benford Analysis
menuGroup: Exploration
menuSubgroup: ClinicoPath Descriptives
version: '1.0.0'
jas: '1.2'

options:
    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.
          jamovi: >
            The data as a data frame.

    - name: var
      title: Variable
      type: Variable
      suggested: [ continuous ]
      permitted: [ numeric ]
      description:
          R: >
            a string naming the variable from `data` that contains the
            continuous values used for the report
          jamovi: >
            a string naming the variable from `data` that contains the
            continuous values used for the report

    # - name: li
    #   title: Load Image
    #   type: Bool
    #   default: false


...


File: jamovi\benford.r.yaml
--------------------------------------------------
Content of jamovi\benford.r.yaml:
---
name:  benford
title: Benford Analysis
jrs:   '1.1'

items:

    - name:  todo
      title: To Do
      type:  Html

    - name:  text
      title: Benford Analysis
      type:  Preformatted


    - name:  text2
      title: Suspects
      type:  Preformatted


    - name: plot
      title: 'Benford Analysis'
      type: Image
      width:  600
      height: 450
      renderFun: .plot
      requiresData: true

refs:
    - benford.analysis
    - ClinicoPathJamoviModule

...


File: jamovi\benford.u.yaml
--------------------------------------------------
Content of jamovi\benford.u.yaml:
title: Benford Analysis
name: benford
jus: '3.0'
stage: 0
compilerMode: aggressive
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Variable
        children:
          - type: VariablesListBox
            name: var
            maxItemCount: 1
            isTarget: true


File: jamovi\crosstable.a.yaml
--------------------------------------------------
Content of jamovi\crosstable.a.yaml:
---
name:  crosstable
title: Cross Tables
menuGroup: Exploration
menuSubgroup: ClinicoPath Comparisons
version: '1.0.0'
jas: '1.2'

description:
    main: Function for making Cross Tables.
    R:
        dontrun: true
        usage: |
            # example will be added


options:
    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.


    - name: vars
      title: Dependent Variable
      type: Variables
      description: >
                  variable in the rows


    - name: group
      title: Grouping Variable
      type: Variable
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]
      description: >
                  variable in the column


    - name: sty
      title: Table Style
      type: List
      options:
        - title: arsenal
          name: arsenal
        - title: finalfit
          name: finalfit
        - title: gtsummary
          name: gtsummary
        - title: NEJM
          name: nejm
        - title: Lancet
          name: lancet
        - title: hmisc
          name: hmisc
      default: nejm

    - name: excl
      title: Exclude Missing (NA)
      type: Bool
      default: false


    - name: cont
      title: Mean vs Median
      type: List
      options:
        - title: mean
          name: mean
        - title: median
          name: median
      default: mean


    - name: pcat
      title: ChiSq vs Fisher
      type: List
      options:
        - title: chisq
          name: chisq
        - title: fisher
          name: fisher
      default: chisq

    # - name: perform_posthoc
    #   title: Include Post-hoc Analysis
    #   type: Bool
    #   default: false
    #   description: >
    #     Performs detailed post-hoc analysis of the contingency table


    # - name: primary_var
    #   title: Primary Variable
    #   type: Variable
    #   suggested: [ ordinal, nominal ]
    #   permitted: [ factor ]
    #   description: >
    #     Variable to focus on in post-hoc analysis (typically the row variable)

    # - name: secondary_var
    #   title: Secondary Variable
    #   type: Variable
    #   suggested: [ ordinal, nominal ]
    #   permitted: [ factor ]
    #   description: >
    #     Variable to analyze against (typically the column variable)



    # - name: posthoc_method
    #   title: Post-hoc Analysis Method
    #   type: List
    #   options:
    #     - title: Both Methods
    #       name: both
    #     - title: Cell Residuals Only
    #       name: residuals
    #     - title: Pairwise Only
    #       name: pairwise
    #   default: both
    #   description: >
    #     Select method for post-hoc analysis of contingency tables.
    #     'Both Methods' shows cell residuals and pairwise comparisons,
    #     'Cell Residuals Only' shows standardized residuals analysis,
    #     'Pairwise Only' shows traditional 2x2 comparisons,
    #     'None' skips post-hoc analysis.




    # - name: export
    #   title: Export Html
    #   type: Bool
    #   default: false


    # - name: excl2
    #   title: Exclude Missing per Variable (NA)
    #   type: Bool
    #   default: true

...


File: jamovi\crosstable.r.yaml
--------------------------------------------------
Content of jamovi\crosstable.r.yaml:
---
name:  crosstable
title: '`Cross Table - ${group}`'
jrs:   '1.1'

items:

    - name:  todo
      title: To Do
      type:  Html
      clearWith:
          - vars
          - group

    - name:  todo2
      title: To Do
      type:  Html
      clearWith:
          - vars
          - group
          - sty

    - name:  tablestyle1
      title: '`Cross Table - ${group}`'
      type:  Html
      clearWith:
          - vars
          - group
          - sty
      visible: (sty:arsenal)
      refs: arsenal

    - name:  tablestyle2
      title: '`Cross Table - ${group}`'
      type: Html
      clearWith:
          - vars
          - group
          - cont
          - pcat
          - sty
      visible: (sty:finalfit)
      refs: finalfit


    - name: tablestyle3
      title: '`Cross Table - ${group}`'
      type:  Html
      clearWith:
          - vars
          - group
          - sty
      visible: (sty:gtsummary)
      refs: gtsummary


    - name: tablestyle4
      title: '`Cross Table - ${group}`'
      type:  Html
      clearWith:
          - vars
          - group
          - sty
      visible: (sty:nejm || sty:lancet || sty:hmisc)
      refs: tangram


    # - name: basic_analysis
    #   title: 'Contingency Table Analysis'
    #   type: Html
    #   clearWith:
    #       - vars
    #       - group
    #       - excl


    # - name: posthoc
    #   title: '`Chi-Square Post-hoc Analysis ${group_posthoc} - ${var_posthoc}`'
    #   type:  Html


refs:
    - ClinicoPathJamoviModule


...


File: jamovi\crosstable.u.yaml
--------------------------------------------------
Content of jamovi\crosstable.u.yaml:
title: Cross Tables
name: crosstable
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Dependent Variable
        children:
          - type: VariablesListBox
            name: vars
            isTarget: true
      - type: TargetLayoutBox
        label: Grouping Variable
        children:
          - type: VariablesListBox
            name: group
            maxItemCount: 1
            isTarget: true
  - type: CollapseBox
    label: Options
    collapsed: true
    children:
      - type: LayoutBox
        margin: large
        children:
          - type: ComboBox
            name: sty
      - type: LayoutBox
        margin: large
        children:
          - type: CheckBox
            name: excl
      - type: LayoutBox
        margin: large
        children:
          - type: ComboBox
            name: cont
            enable: (sty:finalfit)
      - type: LayoutBox
        margin: large
        children:
          - type: ComboBox
            name: pcat
            enable: (sty:finalfit)
  # - type: CollapseBox
  #   label: Post-hoc Analysis
  #   collapsed: true
  #   stretchFactor: 1
  #   children:
  #     - type: Label
  #       label: Chi-Square Post-hoc Analysis
  #       fitToGrid: true
  #       stretchFactor: 1
  #       children:
  #         - type: LayoutBox
  #           margin: large
  #           stretchFactor: 1
  #           children:
  #             - type: Label
  #               label: Variables for Post-hoc Analysis
  #               fitToGrid: true
  #               stretchFactor: 1
  #               children: []


File: jamovi\reportcat.a.yaml
--------------------------------------------------
Content of jamovi\reportcat.a.yaml:
---
name:  reportcat
title: Summary of Categorical Variables
menuGroup: Exploration
menuSubgroup: ClinicoPath Descriptives
version: '1.0.0'
jas: '1.2'

description:
    main: Function for Generating Summaries for Categorical Variables.
    R:
        dontrun: true
        usage: |
            # example will be added

options:
    - name: data
      type: Data
      description:
          R: the data as a data frame

    - name: vars
      title: Variables
      type: Variables
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]
      description:
          R: >
            string naming the variables from `data` that contains the
            values used for the report.



# Uses report::report() function.
# Refer to report.data.frame {report}	documentation.

    # - name: med
    #   title: Median
    #   type: Bool
    #   default: false
    #   description:
    #       R: >
    #         Boolean argument whether to include 'median' instead of 'mean'. Default is false.
    # - name: cent
    #   title: Centrality
    #   type: Bool
    #   default: true
    #   description:
    #       R: >
    #         Boolean argument whether to include centrality (mean or median). Default is true.

    # - name: disp
    #   title: Dispersion
    #   type: Bool
    #   default: true
    #   description:
    #       R: >
    #         Boolean argument whether to include dispersion. Default is true.

    # - name: ran
    #   title: Range
    #   type: Bool
    #   default: true
    #   description:
    #       R: >
    #         Boolean argument whether to include centrality (mean or median). Default is true.

    # - name: distr
    #   title: Distribution
    #   type: Bool
    #   default: false
    #   description:
    #       R: >
    #         Boolean argument whether to include kurtosis and skewness. Default is false.

    # - name: lev
    #   title: Levels Percentage
    #   type: Bool
    #   default: false
    #   description:
    #       R: >
    #         Boolean argument whether to use percentage instead of numbers. Default is false.

    # - name: n_ch
    #   title: Character Numbers
    #   type: Integer
    #   default: 3
    #   description:
    #       R: >
    #         Boolean argument whether to use percentage instead of numbers. Default is false.

    # - name: mis
    #   title: Missing Percentage
    #   type: Bool
    #   default: false
    #   description:
    #       R: >
    #         Boolean argument whether to include missing as percentage. Default is false.

...


File: jamovi\reportcat.r.yaml
--------------------------------------------------
Content of jamovi\reportcat.r.yaml:
---
name:  reportcat
title: Summary of Categorical Variables
jrs:   '1.1'

items:

    - name:  todo
      title: To Do
      type:  Html
      clearWith:
          - vars

    - name:  text
      title: ''
      type:  Preformatted

    - name:  text1
      title: 'Categorical Data'
      type:  Html


refs:
    - report
    - gtExtras
    - ClinicoPathJamoviModule


...


File: jamovi\reportcat.u.yaml
--------------------------------------------------
Content of jamovi\reportcat.u.yaml:
title: Summary of Categorical Variables
name: reportcat
jus: '3.0'
stage: 0
compilerMode: aggressive
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Variables
        children:
          - type: VariablesListBox
            name: vars
            isTarget: true


File: jamovi\summarydata.a.yaml
--------------------------------------------------
Content of jamovi\summarydata.a.yaml:
---
name: summarydata
title: Summary of Continuous Variables
menuGroup: Exploration
menuSubgroup: ClinicoPath Descriptives
version: '1.0.0'
jas: '1.2'

description:
    main: Function for Generating Summaries for Continuous Variables.
    R:
        dontrun: true
        usage: |
            # example will be added


options:

    # - name: lang
    #   title: Language
    #   type: List
    #   options:
    #     - title: English
    #       name: English
    #     - title: Türkçe
    #       name: Türkçe
    #     - title: Deutsch
    #       name: Deutsch
    #   default: English
    #   description:
    #       R: select language


    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.

    - name: vars
      title: Variables
      type: Variables
      suggested: [ continuous ]
      permitted: [ numeric ]
      description:
          R: >
            a string naming the variables from `data` that contains the
            continuous values used for the report

#
#     - name: grvar
#       title: 'Group'
#       type: Variable
#       suggested: [ ordinal, nominal ]
#       permitted: [ factor ]


...


File: jamovi\summarydata.r.yaml
--------------------------------------------------
Content of jamovi\summarydata.r.yaml:
---
name: summarydata
title: Summary of Continuous Variables
jrs:   '1.1'

items:

    - name:  todo
      title: To Do
      type:  Html

    - name:  text
      title: ''
      type:  Preformatted


    - name:  text1
      title: 'Continuous Data Plots'
      type:  Html



refs:
    - gtExtras
    - ClinicoPathJamoviModule

...


File: jamovi\summarydata.u.yaml
--------------------------------------------------
Content of jamovi\summarydata.u.yaml:
title: Summary of Continuous Variables
name: summarydata
jus: '3.0'
stage: 0
compilerMode: aggressive
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Variables
        children:
          - type: VariablesListBox
            name: vars
            isTarget: true


File: jamovi\tableone.a.yaml
--------------------------------------------------
Content of jamovi\tableone.a.yaml:
---
name:  tableone
title: Table One
menuGroup: Exploration
menuSubgroup: ClinicoPath Descriptives
version: '0.0.1'
jas: '1.2'

description:
    main: 'Function for making Table One.'
    R:
        dontrun: true
        usage: |
            data('histopathology')
            dat <- as.data.frame(histopathology)
            ClinicoPath::tableone(
            data = dat,
            vars = vars(Sex, PreinvasiveComponent, LVI, PNI, Grade, Age),
            sty = "t3",
            excl = TRUE)


options:
    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.
          jamovi: >
            The data as a data frame.

    - name: vars
      title: Variables
      type: Variables
      description:
          R: >
            a string naming the variables from `data` that contains the
            values used for the Table One.
          jamovi: >
            a string naming the variables from `data` that contains the
            values used for the Table One.


    - name: sty
      title: Table Style
      type: List
      options:
        - title: tableone
          name: t1
        - title: gtsummary
          name: t2
        - title: arsenal
          name: t3
        - title: janitor
          name: t4
      default: t1
      description:
          R: >
            a string naming the style of the table. 
          jamovi: >
            a string naming the style of the table.


    - name: excl
      title: Exclude Missing (NA)
      type: Bool
      default: false
      description:
          R: >
            a boolean argument whether to exclude missing values. Default is false.
          jamovi: >
            a boolean argument whether to exclude missing values. Default is false.


    # - name: alllevels
    #   title: Show All Levels
    #   type: Bool
    #   default: false


...


File: jamovi\tableone.r.yaml
--------------------------------------------------
Content of jamovi\tableone.r.yaml:
---
name:  tableone
title: Table One
jrs:   '1.1'

items:

    - name:  todo
      title: To Do
      type:  Html


    - name:  tablestyle1
      title: ''
      type:  Preformatted
      clearWith:
          - vars
          - excl
      visible: (sty:t1)
      refs: tableone

    - name:  tablestyle2
      title: ''
      type:  Html
      clearWith:
          - vars
          - excl
      visible: (sty:t2)
      refs: gtsummary

    - name:  tablestyle3
      title: ''
      type:  Html
      clearWith:
          - vars
          - excl
      visible: (sty:t3)
      refs: arsenal


    - name:  tablestyle4
      title: ''
      type:  Preformatted
      clearWith:
          - vars
          - excl
      visible: (sty:t4)
      refs: janitor

refs:
    - ClinicoPathJamoviModule
    - whoisinthisstudy

...


File: jamovi\tableone.u.yaml
--------------------------------------------------
Content of jamovi\tableone.u.yaml:
title: Table One
name: tableone
jus: '3.0'
stage: 0
compilerMode: aggressive
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Variables
        children:
          - type: VariablesListBox
            name: vars
            isTarget: true
  - type: LayoutBox
    margin: large
    children:
      - type: ComboBox
        name: sty
  - type: LayoutBox
    margin: large
    children:
      - type: CheckBox
        name: excl


File: jamovi\vartree.a.yaml
--------------------------------------------------
Content of jamovi\vartree.a.yaml:
---
name:  vartree
title: Variable Tree
menuGroup: Exploration
menuSubgroup: ClinicoPath Descriptive Plots
version: '1.0.0'
jas: '1.2'

description:
    main: Function for Generating Tree Summaries of Variables.
    R:
        dontrun: true
        usage: |
            # example will be added

options:
    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.


    - name: vars
      title: Variables
      type: Variables
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]

    - name: percvar
      title: Variable for Percentage
      type: Variable
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]

    - name: percvarLevel
      title: Level
      type: Level
      variable: (percvar)

    - name: summaryvar
      title: Continuous Variable for Summaries
      type: Variable
      suggested: [ continuous ]
      permitted: [ numeric ]

    - name: prunebelow
      title: Prune Below
      type: Variable
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]

    - name: pruneLevel1
      title: 'Level 1'
      type: Level
      variable: (prunebelow)
      allowNone: true

    - name: pruneLevel2
      title: 'Level 2'
      type: Level
      variable: (prunebelow)
      allowNone: true

    - name: follow
      title: Follow Below
      type: Variable
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]

    - name: followLevel1
      title: 'Level 1'
      type: Level
      variable: (follow)
      allowNone: true

    - name: followLevel2
      title: 'Level 2'
      type: Level
      variable: (follow)
      allowNone: true

    - name: excl
      title: Exclude Missing (NA)
      type: Bool
      default: false

    - name: vp
      title: Valid Percentages
      type: Bool
      default: true

    - name: horizontal
      title: Horizontal Layout
      type: Bool
      default: false

    - name: sline
      title: Sameline
      type: Bool
      default: true

    - name: varnames
      title: Variable Names
      type: Bool
      default: false

    - name: nodelabel
      title: Node Label
      type: Bool
      default: true

    - name: pct
      title: Percentages
      type: Bool
      default: false

    - name: showcount
      title: Counts
      type: Bool
      default: true

    - name: legend
      title: Legends
      type: Bool
      default: false


    - name: pattern
      title: Pattern Tree
      type: Bool
      default: false

    - name: sequence
      title: Sequence Tree
      type: Bool
      default: false

    - name: ptable
      title: Pattern Table
      type: Bool
      default: false

    # - name: venntable
    #   title: Venn Table
    #   type: Bool
    #   default: false

    - name: mytitle
      title: Root Title
      type: String
      default: ''

    - name: useprunesmaller
      title: Prune
      type: Bool
      default: false

    - name: prunesmaller
      title: 'counts <'
      type: Integer
      default: 5

    - name: summarylocation
      title: 'Summary Location'
      type: List
      options:
        - title: 'All Nodes'
          name: allnodes
        - title: 'Leaf Nodes'
          name: leafonly
      default: leafonly

    # - name: maxwidth
    #   title: Image Width
    #   type: Integer
    #   default: 100

    # - name: width
    #   title: Image Width
    #   type: Integer
    #   default: 100

    # - name: height
    #   title: Image Height
    #   type: Integer
    #   default: 100

...


File: jamovi\vartree.r.yaml
--------------------------------------------------
Content of jamovi\vartree.r.yaml:
---
name:  vartree
title: Variable Tree
jrs:   '1.1'

items:

    - name:  todo
      title: To Do
      type:  Html

    - name:  text1
      title: Variable Tree
      type:  Html

    - name:  text2
      title: Pattern Table
      type:  Preformatted
      visible: (ptable)

    # - name:  text3
    #   title: Venn Table
    #   type:  Preformatted
    #   visible: (venntable)


refs:
    - vtree
    - ClinicoPathJamoviModule

...


File: jamovi\vartree.u.yaml
--------------------------------------------------
Content of jamovi\vartree.u.yaml:
title: Variable Tree
name: vartree
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: true
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Variables
        children:
          - type: VariablesListBox
            name: vars
            isTarget: true
      - type: TargetLayoutBox
        label: Variable for Percentage
        children:
          - type: VariablesListBox
            name: percvar
            maxItemCount: 1
            isTarget: true
          - type: LevelSelector
            name: percvarLevel
      - type: TargetLayoutBox
        label: Continuous Variable for Summaries
        children:
          - type: VariablesListBox
            name: summaryvar
            maxItemCount: 1
            isTarget: true
      - type: TargetLayoutBox
        label: Prune Below
        children:
          - type: VariablesListBox
            name: prunebelow
            maxItemCount: 1
            isTarget: true
          - type: LevelSelector
            name: pruneLevel1
          - type: LevelSelector
            name: pruneLevel2
      - type: TargetLayoutBox
        label: Follow Below
        children:
          - type: VariablesListBox
            name: follow
            maxItemCount: 1
            isTarget: true
          - type: LevelSelector
            name: followLevel1
          - type: LevelSelector
            name: followLevel2
  - type: CollapseBox
    label: Options
    stretchFactor: 1
    collapsed: true
    children:
      - type: LayoutBox
        margin: large
        stretchFactor: 1
        children:
          - type: LayoutBox
            cell:
              column: 0
              row: 0
            stretchFactor: 1
            children:
              - type: Label
                label: Output
                fitToGrid: true
                children:
                  - type: CheckBox
                    name: excl
                  - type: CheckBox
                    name: varnames
                  - type: CheckBox
                    name: showcount
                  - type: CheckBox
                    name: pct
                  - type: CheckBox
                    name: vp
                    enable: (!excl && pct)
                  - type: CheckBox
                    name: nodelabel
                  - type: CheckBox
                    name: legend
                    enable: (varnames)
                  - type: TextBox
                    name: mytitle
                    format: string
                    width: large
          - type: LayoutBox
            cell:
              column: 1
              row: 0
            stretchFactor: 1
            children:
              - type: Label
                label: Plots
                fitToGrid: true
                cell:
                  column: 1
                  row: 0
                children:
                  - type: CheckBox
                    name: horizontal
                  - type: CheckBox
                    name: sline
                  - type: CheckBox
                    name: useprunesmaller
                    children:
                      - type: TextBox
                        name: prunesmaller
                        format: number
                        enable: (useprunesmaller)
                  - type: CheckBox
                    name: pattern
                    enable: (!sequence)
                  - type: CheckBox
                    name: sequence
                    enable: (!pattern)
                  - type: CheckBox
                    name: ptable
                  - type: ComboBox
                    name: summarylocation


File: jamovi\venn.a.yaml
--------------------------------------------------
Content of jamovi\venn.a.yaml:
---
name:  venn
title: Venn Diagram
menuGroup: Exploration
menuSubgroup: ClinicoPath Descriptive Plots
version: '1.0.0'
jas: '1.2'

options:

    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.
          jamovi: >
            The data as a data frame.

    - name: var1
      title: 'Variable 1'
      type: Variable
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]
      description:
          R: >
            a string naming the variable from `data` that contains the
            the first variable used for the report
          jamovi: >
            a string naming the variable from `data` that contains the
            the first variable used for the report

    - name: var1true
      title: 'Select True Level'
      type: Level
      variable: (var1)
      description:
          R: >
            a string naming the level from `var1` that contains the
            the true level
          jamovi: >
            a string naming the level from `var1` that contains the
            the true level


    - name: var2
      title: 'Variable 2'
      type: Variable
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]
      description:
          R: >
            a string naming the variable from `data` that contains the
            the second variable used for the report
          jamovi: >
            a string naming the variable from `data` that contains the
            the second variable used for the report

    - name: var2true
      title: 'Select True Level'
      type: Level
      variable: (var2)
      description:
          R: >
            a string naming the level from `var2` that contains the
            the true level
          jamovi: >
            a string naming the level from `var2` that contains the
            the true level


    - name: var3
      title: 'Variable 3'
      type: Variable
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]
      description:
          R: >
            a string naming the variable from `data` that contains the
            the third variable used for the report
          jamovi: >
            a string naming the variable from `data` that contains the
            the third variable used for the report

    - name: var3true
      title: 'Select True Level'
      type: Level
      variable: (var3)
      description:
          R: >
            a string naming the level from `var3` that contains the
            the true level
          jamovi: >
            a string naming the level from `var3` that contains the
            the true level

    - name: var4
      title: 'Variable 4'
      type: Variable
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]
      description:
          R: >
            a string naming the variable from `data` that contains the
            the fourth variable used for the report
          jamovi: >
            a string naming the variable from `data` that contains the
            the fourth variable used for the report

    - name: var4true
      title: 'Select True Level'
      type: Level
      variable: (var4)
      description:
          R: >
            a string naming the level from `var4` that contains the
            the true level
          jamovi: >
            a string naming the level from `var4` that contains the
            the true level


...


File: jamovi\venn.r.yaml
--------------------------------------------------
Content of jamovi\venn.r.yaml:
---
name:  venn
title: Venn Diagram
jrs:   '1.1'

clearWith:
    - var1
    - var2
    - var3
    - var4
    - var1true
    - var2true
    - var3true
    - var4true

items:

    - name:  todo
      title: To Do
      type:  Html

    # - name: output1
    #   title: To Do
    #   type:  Preformatted

    - title: Venn Diagram
      name: plot
      type: Image
      width:  700
      height: 450
      renderFun: .plot
      requiresData: true
      refs:
        - venn


    - title: Upset Diagram
      name: plot2
      type: Image
      width:  700
      height: 450
      renderFun: .plot2
      requiresData: true
      refs:
        - upset



refs:
    - ClinicoPathJamoviModule

...


File: jamovi\venn.u.yaml
--------------------------------------------------
Content of jamovi\venn.u.yaml:
title: Venn Diagram
name: venn
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Variable 1
        children:
          - type: VariablesListBox
            name: var1
            isTarget: true
            maxItemCount: 1
          - type: LevelSelector
            name: var1true
            enable: (var1)
      - type: TargetLayoutBox
        label: Variable 2
        children:
          - type: VariablesListBox
            name: var2
            isTarget: true
            maxItemCount: 1
            enable: (var1)
          - type: LevelSelector
            name: var2true
            enable: (var2)
      - type: TargetLayoutBox
        label: Variable 3
        children:
          - type: VariablesListBox
            name: var3
            isTarget: true
            maxItemCount: 1
            enable: (var2)
          - type: LevelSelector
            name: var3true
            enable: (var3)
      - type: TargetLayoutBox
        label: Variable 4
        children:
          - type: VariablesListBox
            name: var4
            isTarget: true
            maxItemCount: 1
            enable: (var3)
          - type: LevelSelector
            name: var4true
            enable: (var4)


File: jamovi\waterfall.a.yaml
--------------------------------------------------
Content of jamovi\waterfall.a.yaml:
---
name: waterfall
title: Treatment Response Waterfall Plot
menuGroup: Exploration
menuSubgroup: ClinicoPath Descriptive Plots
version: '1.0.0'
jas: '1.2'


description:
    main: Creates a waterfall plot to visualize tumor response data following RECIST criteria.
    R:
        dontrun: true
        usage: |
            data <- data.frame(
                PatientID = paste0("PT", 1:10),
                Response = c(-100, -45, -30, -20, -10, 0, 10, 20, 30, 40)
            )
            waterfall(
                data = data,
                patientID = "PatientID",
                response = "Response"
            )


options:
    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.
          jamovi: >
            The data as a data frame.
            
    - name: patientID
      title: Patient ID
      type: Variable
      suggested: [nominal]
      permitted: [numeric, factor, id]
      description:
          R: >
            Variable containing patient identifiers.
          jamovi: >
            Variable containing patient identifiers.

    - name: responseVar
      title: Response Value (Raw or Percent)
      type: Variable
      suggested: [continuous]
      permitted: [numeric]
      description:
          R: >
            Percentage change in tumor size.
          jamovi: >
            Percentage change in tumor size.


    - name: timeVar
      title: Time Variable 
      type: Variable
      suggested: [continuous]
      permitted: [numeric]
      description:
          R: >
            Time point of measurement for spider plot (e.g., months from baseline)
          jamovi: >
            Time point of measurement for spider plot (e.g., months from baseline)


    - name: inputType
      title: Input Type
      type: List
      options:
        - title: Raw Measurements
          name: raw
        - title: Percentage Changes
          name: percentage
      default: percentage
      description:
          R: >
            Specify data format: 'raw' for actual measurements (will calculate percent change) 
            or 'percentage' for pre-calculated percentage changes
          jamovi: >
            Select 'Raw Measurements' if providing actual tumor measurements,
            or 'Percentage Changes' if changes from baseline are pre-calculated


    - name: sortBy
      title: Sort By
      type: List
      options:
        - title: Best Response
          name: response
        - title: Patient ID
          name: id
      default: response
      description:
          R: >
            Sort the waterfall plot by best response or patient ID.
          jamovi: >
            Sort the waterfall plot by best response or patient ID.

    - name: showThresholds
      title: Show RECIST Thresholds
      type: Bool
      default: false
      description:
          R: >
            Show +20 percent and -30 percent RECIST thresholds.
          jamovi: >
            Show +20 percent and -30 percent RECIST thresholds.

    - name: labelOutliers
      title: Label Large Changes
      type: Bool
      default: false
      description:
          R: >
            Label responses exceeding ±50 percent.
          jamovi: >
            Label responses exceeding ±50 percent.



    - name: showMedian
      title: Show Median Response
      type: Bool
      default: false
      description:
          R: >
            Show median response as a horizontal line.
          jamovi: >
            Show median response as a horizontal line.

    - name: showCI
      title: Show Confidence Interval
      type: Bool
      default: false
      description:
          R: >
            Show confidence interval around median response.
          jamovi: >
            Show confidence interval around median response.

    - name: minResponseForLabel
      title: Minimum Response for Labels (percent)
      type: Number
      default: 50
      min: 0
      max: 100
      description:
          R: >
            Minimum response value for labels to be displayed.
          jamovi: >
            Minimum response value for labels to be displayed.


    - name: colorScheme
      title: Color Scheme
      type: List
      options:
        - title: jamovi 
          name: jamovi
        - title: RECIST (Red/Blue/Green)
          name: recist
        - title: Simple (Red/Green)
          name: simple
      default: jamovi
      description:
          R: >
            Color scheme for waterfall plot.
          jamovi: >
            Color scheme for waterfall plot.


    - name: barAlpha
      title: Bar Transparency
      type: Number
      default: 1
      min: 0
      max: 1
      description:
          R: >
            Transparency of bars in waterfall plot.
          jamovi: >
            Transparency of bars in waterfall plot.
      
    - name: barWidth
      title: Bar Width
      type: Number
      default: 0.7
      min: 0.1
      max: 1
      description:
          R: >
            Width of bars in waterfall plot.
          jamovi: >
            Width of bars in waterfall plot.

    - name: showWaterfallPlot
      title: Show Waterfall Plot
      type: Bool
      default: false

    - name: showSpiderPlot
      title: Show Spider Plot
      type: Bool
      default: false
      description:
          R: >
            Create an additional spider plot showing response over time if longitudinal data available
          jamovi: >
            Create an additional spider plot showing response over time if longitudinal data available

    - name: addResponseCategory
      title: Add Response Category to Data  
      type: Bool
      default: false
      description:
          R: >
            Add a new variable to the data frame indicating response category.
          jamovi: >
            Add a new variable to the data frame indicating response category.



...


File: jamovi\waterfall.r.yaml
--------------------------------------------------
Content of jamovi\waterfall.r.yaml:
---
name:  waterfall
title: Treatment Response Waterfall Plot
jrs:   '1.1'

items:
    - name: todo2
      title: To Do 2
      type: Html

    - name: todo
      title: To Do
      type: Html

    - name: summary
      title: Response Summary
      type: Table
      rows: 0
      columns:
        - name: category
          title: "Response Category"
          type: text
        - name: n
          title: "n"
          type: integer
        - name: percent
          title: "%"
          type: number
          format: percent


    - name: clinicalMetrics
      title: Clinical Response Metrics
      type: Table
      rows: 0
      columns:
        - name: metric
          title: "Metric"
          type: text
        - name: value
          title: "Value"
          type: text

    - name: waterfallplot
      title: 'Waterfall Plot'
      type: Image
      width: 800
      height: 500
      renderFun: .waterfallplot
      requiresData: true
      visible: (showWaterfallPlot)
      clearWith:
        - patientID
        - response
        - sortBy
        - showThresholds
        - labelOutliers
        - colorScheme
        - showMedian
        - showCI

    - name: spiderplot
      title: 'Response Over Time'
      type: Image
      width: 800
      height: 500
      renderFun: .spiderplot
      requiresData: true
      visible: (showSpiderPlot)
      clearWith:
        - patientID
        - response
        - timeVar
        - inputType
        - sortBy

    - name: responseCategory
      title: "Response Category"
      type: Output
      varTitle: '`Calculated Response Category`'
      varDescription: Calculated response category based on RECIST criteria.
      clearWith:
        - patientID
        - response


    - name: mydataview
      title: mydataview
      type: Preformatted


refs:
    - recist
    - ClinicoPathJamoviModule

...


File: jamovi\waterfall.u.yaml
--------------------------------------------------
Content of jamovi\waterfall.u.yaml:
title: Treatment Response Waterfall Plot
name: waterfall
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Patient ID
        children:
          - type: VariablesListBox
            name: patientID
            maxItemCount: 1
            isTarget: true
      - type: TargetLayoutBox
        label: Response Value (Raw or Percentage Measurement)
        children:
          - type: VariablesListBox
            name: responseVar
            maxItemCount: 1
            isTarget: true
          - type: LayoutBox
            margin: large
            children:
              - type: ComboBox
                name: inputType
      - type: TargetLayoutBox
        label: Time Variable
        children:
          - type: VariablesListBox
            name: timeVar
            maxItemCount: 1
            isTarget: true
  - type: CollapseBox
    label: Waterfall Plot Options
    collapsed: false
    children:
      - type: LayoutBox
        margin: large
        children:
          - type: CheckBox
            name: showWaterfallPlot
      - type: LayoutBox
        margin: large
        children:
          - type: Label
            label: Visualization
            children:
              - type: ComboBox
                name: sortBy
              - type: ComboBox
                name: colorScheme
          - type: Label
            label: Annotations
            children:
              - type: CheckBox
                name: showThresholds
              - type: CheckBox
                name: labelOutliers
              - type: CheckBox
                name: showMedian
              - type: CheckBox
                name: showCI
          - type: Label
            label: Plot Customization
            children:
              - type: TextBox
                name: minResponseForLabel
                format: number
                enable: ()
              - type: TextBox
                name: barAlpha
                format: number
                enable: ()
              - type: TextBox
                name: barWidth
                format: number
                enable: ()
          - type: LayoutBox
            margin: large
            children:
              - type: Label
                label: Update Data
                children:
                  - type: CheckBox
                    name: addResponseCategory

  - type: CollapseBox
    label: Waterfall Plot Options
    collapsed: false
    children:
      - type: LayoutBox
        margin: large
        children:
          - type: CheckBox
            name: showSpiderPlot




File: R\00jmv.R
--------------------------------------------------
Content of R\00jmv.R:

# This file is automatically generated, you probably don't want to edit this

.jmvrefs <- list(
    `emmeans`=list(
        `type`="software", 
        `author`="Lenth, R.", 
        `year`=2018, 
        `title`="emmeans: Estimated Marginal Means, aka Least-Squares Means", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=emmeans", 
        `url`="https://CRAN.R-project.org/package=emmeans"), 
    `afex`=list(
        `type`="software", 
        `author`="Singmann, H.", 
        `year`=2018, 
        `title`="afex: Analysis of Factorial Experiments", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=afex", 
        `url`="https://CRAN.R-project.org/package=afex"), 
    `R`=list(
        `type`="software", 
        `author`="R Core Team", 
        `year`=2018, 
        `title`="A Language and Envionment for Statistical Computing", 
        `publisher`="[Computer software]. Retrieved from https://CRAN.R-project.org/", 
        `url`="https://CRAN.R-project.org/"), 
    `BF`=list(
        `type`="software", 
        `author`="Morey, R. D., & Rouder, J. N.", 
        `year`=2018, 
        `title`="BayesFactor: Computation of Bayes Factors for Common Designs", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=BayesFactor", 
        `url`="https://CRAN.R-project.org/package=BayesFactor"), 
    `btt`=list(
        `type`="article", 
        `author`="Rouder, J. N., Speckman, P. L., Sun, D., Morey, R. D., & Iverson, G.", 
        `year`=2009, 
        `title`="Bayesian t tests for accepting and rejecting the null hypothesis", 
        `publisher`="Psychonomic Bulletin & Review", 
        `volume`=16, 
        `pages`="225-237"), 
    `car`=list(
        `type`="software", 
        `author`="Fox, J., & Weisberg, S.", 
        `year`=2018, 
        `title`="car: Companion to Applied Regression", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=car", 
        `url`="https://CRAN.R-project.org/package=car"), 
    `ggplot2`=list(
        `type`="software", 
        `author`="Wickham, H., Chang, W., Henry, L., Pedersen, T. L., Takahashi, K., Wilke, C., Woo, K., & RStudio", 
        `year`=2018, 
        `title`="ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ggplot2", 
        `url`="https://CRAN.R-project.org/package=ggplot2"), 
    `ggridges`=list(
        `type`="software", 
        `author`="Wilke, C., & RStudio", 
        `year`=2018, 
        `title`="ggridges: Ridgeline Plots in ggplot2", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ggridges", 
        `url`="https://CRAN.R-project.org/package=ggridges"), 
    `mvnormtest`=list(
        `type`="software", 
        `author`="Jarek, S.", 
        `year`=2012, 
        `title`="mvnormtest: Normality test for multivariate variables", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=mvnormtest", 
        `url`="https://CRAN.R-project.org/package=mvnormtest"), 
    `PMCMR`=list(
        `type`="software", 
        `author`="Pohlert, T.", 
        `year`=2018, 
        `title`="PMCMR: Calculate Pairwise Multiple Comparisons of Mean Rank Sums", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=PMCMR", 
        `url`="https://CRAN.R-project.org/package=PMCMR"), 
    `ROCR`=list(
        `type`="software", 
        `author`="Sing, T., Sander, O., Beerenwinkel, N., & Lengauer, T.", 
        `year`=2015, 
        `title`="ROCR: Visualizing the Performance of Scoring Classifiers", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ROCR", 
        `url`="https://CRAN.R-project.org/package=ROCR"), 
    `nnet`=list(
        `type`="software", 
        `author`="Ripley, B., Venables W.", 
        `year`=2016, 
        `title`="nnet: Feed-Forward Neural Networks and Multinomial Log-Linear Models", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=nnet", 
        `url`="https://CRAN.R-project.org/package=nnet"), 
    `MASS`=list(
        `type`="software", 
        `author`="Ripley, B., Venables W., Bates, D. M., Hornik, K., Gebhardt, A., & Firth, D.", 
        `year`=2018, 
        `title`="MASS: Support Functions and Datasets for Venables and Ripley's MASS", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=MASS", 
        `url`="https://CRAN.R-project.org/package=MASS"), 
    `vcd`=list(
        `type`="software", 
        `author`="Meyer, D., Zeileis, A., Hornik, K., Gerber, F., & Friendly, M.", 
        `year`=2017, 
        `title`="vcd: Visualizing Categorical Data", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=vcd", 
        `url`="https://CRAN.R-project.org/package=vcd"), 
    `vcdExtra`=list(
        `type`="software", 
        `author`="Friendly M., Turner, H., Zeileis, A., Murdoch, D., & Firth, D.", 
        `year`=2017, 
        `title`="vcdExtra: 'vcd' Extensions and Additions", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=vcdExtra", 
        `url`="https://CRAN.R-project.org/package=vcdExtra"), 
    `exact2x2`=list(
        `type`="software", 
        `author`="Fay, M. P., Hunsberger, S. A., Nason, M., & Gabriel, E.", 
        `year`=2018, 
        `title`="exact2x2: Exact Tests and Confidence Intervals for 2x2 Tables", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=exact2x2", 
        `url`="https://CRAN.R-project.org/package=exact2x2"), 
    `psych`=list(
        `type`="software", 
        `author`="Revelle, W.", 
        `year`=2019, 
        `title`="psych: Procedures for Psychological, Psychometric, and Personality Research", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=psych", 
        `url`="https://CRAN.R-project.org/package=psych"), 
    `lavaan`=list(
        `type`="software", 
        `author`="Rosseel, Y., et al.", 
        `year`=2018, 
        `title`="lavaan: Latent Variable Analysis", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=lavaan", 
        `url`="https://CRAN.R-project.org/package=lavaan"), 
    `semPlot`=list(
        `type`="software", 
        `author`="Epskamp, S.", 
        `year`=2017, 
        `title`="semPlot: Path Diagrams and Visual Analysis of Various SEM Packages' Output", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=semPlot", 
        `url`="https://CRAN.R-project.org/package=semPlot"), 
    `ggstatsplot`=list(
        `type`="software", 
        `author`="Patil, I.", 
        `year`=2018, 
        `title`="ggstatsplot: 'ggplot2' Based Plots with Statistical Details", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ggstatsplot", 
        `url`="https://CRAN.R-project.org/package=ggstatsplot", 
        `doi`="10.5281/zenodo.2074621"), 
    `report`=list(
        `type`="software", 
        `author`="Makowski, Dominique, L\u00FCdecke, Daniel", 
        `year`=2019, 
        `title`="The report package for R: Ensuring the use of best practices for results reporting", 
        `publisher`="[R package]. Retrieved from https://github.com/easystats/report", 
        `url`="https://github.com/easystats/report"), 
    `arsenal`=list(
        `type`="software", 
        `author`="Heinzen, E Sinnwell, J Atkinson, E Gunderson, T Dougherty, G", 
        `year`=2018, 
        `title`="arsenal: An Arsenal of 'R' Functions for Large-Scale Statistical Summaries", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=arsenal", 
        `url`="https://CRAN.R-project.org/package=arsenal"), 
    `tangram`=list(
        `type`="software", 
        `author`="Garbett, S.", 
        `year`=2018, 
        `title`="tangram: The Grammar of Tables", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=tangram", 
        `url`="https://CRAN.R-project.org/package=tangram"), 
    `irr`=list(
        `type`="software", 
        `author`="Matthias Gamer, Jim Lemon, Ian Fellows, Puspendra Singh", 
        `year`=2019, 
        `title`="Various Coefficients of Interrater Reliability and Agreement.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=irr", 
        `url`="https://CRAN.R-project.org/package=irr"), 
    `tableone`=list(
        `type`="software", 
        `author`="Kazuki, Y.", 
        `year`=2019, 
        `title`="tableone: Create 'Table 1' to Describe Baseline Characteristics", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=tableone", 
        `url`="https://CRAN.R-project.org/package=tableone"), 
    `janitor`=list(
        `type`="software", 
        `author`="Firke, S.", 
        `year`=2019, 
        `title`="janitor: Simple Tools for Examining and Cleaning Dirty Data.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=janitor", 
        `url`="https://CRAN.R-project.org/package=janitor"), 
    `finalfit`=list(
        `type`="software", 
        `author`="Ewen Harrison and Tom Drake and Riinu Ots", 
        `year`=2019, 
        `title`="finalfit: Quickly Create Elegant Regression Results Tables and Plots when Modelling", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=finalfit", 
        `url`="https://CRAN.R-project.org/package=finalfit"), 
    `caret`=list(
        `type`="software", 
        `author`="Max Kuhn", 
        `year`=2020, 
        `title`="caret: Classification and Regression Training", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=caret", 
        `url`="https://CRAN.R-project.org/package=caret"), 
    `psycho`=list(
        `type`="software", 
        `author`="Makowski, D.", 
        `year`=2018, 
        `title`="The Psycho Package: An Efficient and Publishing-Oriented Workflow for Psychological Science. Journal of Open Source Software, 3(22), 470.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=psycho.R", 
        `url`="https://CRAN.R-project.org/package=psycho.R"), 
    `survival`=list(
        `type`="software", 
        `author`="Terry M Therneau, Thomas Lumley", 
        `year`=2019, 
        `title`="survival: Survival Analysis", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=survival", 
        `url`="https://CRAN.R-project.org/package=survival"), 
    `survminer`=list(
        `type`="software", 
        `author`="Alboukadel Kassambara and Marcin Kosinski and Przemyslaw Biecek", 
        `year`=2019, 
        `title`="survminer: Drawing Survival Curves using 'ggplot2'", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=survminer", 
        `url`="https://CRAN.R-project.org/package=survminer"), 
    `ggalluvial`=list(
        `type`="software", 
        `author`="Jason Cory Brunson", 
        `year`=2019, 
        `title`="ggalluvial: Alluvial Plots in 'ggplot2'.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ggalluvial", 
        `url`="https://CRAN.R-project.org/package=ggalluvial"), 
    `explore`=list(
        `type`="software", 
        `author`="Roland Krasser", 
        `year`=2020, 
        `title`="explore: Simplifies Exploratory Data Analysis.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=explore", 
        `url`="https://CRAN.R-project.org/package=explore"), 
    `FFTrees`=list(
        `type`="software", 
        `author`="Nathaniel Phillips, Hansjoerg Neth, Jan Woike and Wolfgang Gaissmaer", 
        `year`=2019, 
        `title`="FFTrees: Generate, Visualise, and Evaluate Fast-and-Frugal Decision Trees", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=FFTrees", 
        `url`="https://CRAN.R-project.org/package=FFTrees"), 
    `rpart`=list(
        `type`="software", 
        `author`="Terry Therneau and Beth Atkinson", 
        `year`=2019, 
        `title`="rpart: Recursive Partitioning and Regression Trees.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=rpart", 
        `url`="https://CRAN.R-project.org/package=rpart"), 
    `rpart.plot`=list(
        `type`="software", 
        `author`="Stephen Milborrow", 
        `year`=2019, 
        `title`="rpart.plot: Plot 'rpart' Models: An Enhanced Version of 'plot.rpart'", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=rpart.plot", 
        `url`="https://CRAN.R-project.org/package=rpart.plot"), 
    `gtsummary`=list(
        `type`="software", 
        `author`="Daniel D. Sjoberg, Margie Hannum, Karissa Whiting and Emily C. Zabor", 
        `year`=2020, 
        `title`="gtsummary: Presentation-Ready Data Summary and Analytic Result Tables", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=gtsummary", 
        `url`="https://CRAN.R-project.org/package=gtsummary"), 
    `rmngb`=list(
        `type`="software", 
        `author`="Antoine Filipovic Pierucci", 
        `year`=2014, 
        `title`="rmngb: Miscellaneous Collection of Functions for Medical Data Analysis", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=rmngb", 
        `url`="https://CRAN.R-project.org/package=rmngb"), 
    `RVAideMemoire`=list(
        `type`="software", 
        `author`="Maxime Herv\u00E9", 
        `year`=2020, 
        `title`="RVAideMemoire: Testing and Plotting Procedures for Biostatistics", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=RVAideMemoire", 
        `url`="https://CRAN.R-project.org/package=RVAideMemoire"), 
    `chisq.posthoc.test`=list(
        `type`="software", 
        `author`="Daniel Ebbert", 
        `year`=2019, 
        `title`="chisq.posthoc.test: A Post Hoc Analysis for Pearson's Chi-Squared Test for Count Data", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=chisq.posthoc.test", 
        `url`="https://CRAN.R-project.org/package=chisq.posthoc.test"), 
    `easyalluvial`=list(
        `type`="software", 
        `author`="Bjoern Koneswarakantha", 
        `year`=2019, 
        `title`="easyalluvial: Generate Alluvial Plots with a Single Line of Code.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=easyalluvial", 
        `url`="https://CRAN.R-project.org/package=easyalluvial"), 
    `parcats`=list(
        `type`="software", 
        `author`="Bjoern Koneswarakantha", 
        `year`=2019, 
        `title`="parcats: Interactive Parallel Categories Diagrams for 'easyalluvial'", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=parcats", 
        `url`="https://CRAN.R-project.org/package=parcats"), 
    `plotROC`=list(
        `type`="software", 
        `author`="Michael C. Sachs", 
        `year`=2017, 
        `title`="plotROC: A Tool for Plotting ROC Curves.Journal of Statistical Software, Code Snippets, 79(2), 1-19. doi:10.18637/jss.v079.c02", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=plotROC", 
        `url`="https://CRAN.R-project.org/package=plotROC"), 
    `RGraphGallery`=list(
        `type`="website", 
        `author`="Holtz Yan", 
        `year`=2020, 
        `title`="The R Graph Gallery", 
        `publisher`="A website that displays hundreds of R charts https://www.r-graph-gallery.com", 
        `url`="https://github.com/holtzy/R-graph-gallery"), 
    `hrbrthemes`=list(
        `type`="software", 
        `author`="Bob Rudis", 
        `year`=2020, 
        `title`="hrbrthemes: Additional Themes, Theme Components and Utilities for 'ggplot2'.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=hrbrthemes", 
        `url`="https://CRAN.R-project.org/package=hrbrthemes"), 
    `retractcheck`=list(
        `type`="software", 
        `author`="Chris Hartgerink and Frederik Aust", 
        `year`=2019, 
        `title`="retractcheck: Retraction Scanner", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=retractcheck", 
        `url`="https://CRAN.R-project.org/package=retractcheck"), 
    `RefManageR`=list(
        `type`="software", 
        `author`="McLean MW", 
        `year`=2017, 
        `title`="RefManageR: Import and Manage BibTeX and BibLaTeX References in R. The Journal of Open Source Software.", 
        `doi`="10.21105/joss.00338", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=RefManageR", 
        `url`="https://CRAN.R-project.org/package=RefManageR"), 
    `rcrossref`=list(
        `type`="software", 
        `author`="Scott Chamberlain and Hao Zhu and Najko Jahn and Carl Boettiger and Karthik Ram", 
        `year`=2020, 
        `title`="rcrossref: Client for Various 'CrossRef' 'APIs'", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=rcrossref", 
        `url`="https://CRAN.R-project.org/package=rcrossref"), 
    `epiR`=list(
        `type`="software", 
        `author`="Mark Stevenson with contributions from Telmo Nunes, Cord Heuer, Jonathon Marshall, Javier Sanchez, Ron Thornton, Jeno Reiczigel, Jim Robison-Cox, Paola Sebastiani, Peter Solymos, Kazuki Yoshida, Geoff Jones, Sarah Pirikahu, Simon Firestone, Ryan Kyle, Johann Popp, Mathew Jay and Charles Reynard.", 
        `year`=2020, 
        `title`="epiR: Tools for the Analysis of Epidemiological Data.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=epiR", 
        `url`="https://CRAN.R-project.org/package=epiR"), 
    `KMunicate`=list(
        `type`="software", 
        `author`="Alessandro Gasparini", 
        `year`=2020, 
        `title`="KMunicate: KMunicate-Style Kaplan\u2013Meier Plots", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=KMunicate", 
        `url`="https://CRAN.R-project.org/package=KMunicate"), 
    `KMunicate2`=list(
        `type`="article", 
        `author`="Morris TP, Jarvis CI, Cragg W, et al", 
        `title`="Proposals on Kaplan\u2013Meier plots in medical research and a survey of stakeholder views: KMunicate", 
        `year`=2019, 
        `publisher`="BMJ Open 2019;9:e030215.", 
        `doi`="10.1136/bmjopen-2019-030215", 
        `url`="https://bmjopen.bmj.com/content/9/9/e030215"), 
    `Fagan`=list(
        `type`="software", 
        `author`="Adam Chekroud", 
        `title`="nomogrammer: Fagan's nomograms with ggplot2", 
        `publisher`="GitHub", 
        `year`=2020, 
        `url`="https://github.com/achekroud/nomogrammer"), 
    `Fagan2`=list(
        `type`="article", 
        `author`=NULL, 
        `title`="StATS: What is a Fagan nomogram?", 
        `publisher`="website", 
        `year`=2020, 
        `url`="http://www.pmean.com/definitions/fagan.htm"), 
    `benford.analysis`=list(
        `type`="software", 
        `author`="Carlos Cinelli", 
        `year`=2020, 
        `title`="benford.analysis: Benford Analysis for Data Validation and Forensic Analytics", 
        `publisher`="[R package]. Retrieved from http://github.com/carloscinelli/benford.analysis", 
        `url`="http://github.com/carloscinelli/benford.analysis"), 
    `vtree`=list(
        `type`="software", 
        `author`="Nick Barrowman", 
        `year`=2020, 
        `title`="vtree: Display Information About Nested Subsets of a Data Frame", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=vtree", 
        `url`="https://CRAN.R-project.org/package=vtree"), 
    `PathologyKappa`=list(
        `type`="article", 
        `title`="Pathologists should probably forget about kappa. Percent agreement, diagnostic specificity and related metrics provide more clinically applicable measures of interobserver variability", 
        `year`=2020, 
        `author`=NULL, 
        `publisher`="Annals of Diagnostic Pathology", 
        `volume`=47, 
        `url`="https://www.sciencedirect.com/science/article/abs/pii/S1092913420301040"), 
    `DiagnosticTests`=list(
        `type`="article", 
        `title`="The Interpretation of SARS-CoV-2 Diagnostic Tests", 
        `year`=2020, 
        `author`="Stites EC, Wilen CB.", 
        `publisher`="Med (N Y).", 
        `doi`="10.1016/j.medj.2020.08.001", 
        `url`="https://www.cell.com/med/fulltext/S2666-6340(20)30016-7"), 
    `dichotomizing`=list(
        `type`="article", 
        `title`="Dichotomizing continuous predictors in multiple regression: a bad idea.", 
        `year`=2006, 
        `author`="Royston, P., Altman, D.G. and Sauerbrei, W.", 
        `publisher`="Statist. Med.", 
        `volume`=25, 
        `pages`="127-141", 
        `doi`="10.1002/sim.2331", 
        `url`="https://onlinelibrary.wiley.com/doi/abs/10.1002/sim.2331"), 
    `bbccookbook`=list(
        `type`="article", 
        `title`="BBC Visual and Data Journalism cookbook for R graphics", 
        `year`=2019, 
        `author`="BBC data team", 
        `url`="https://bbc.github.io/rcookbook/"), 
    `bbplot`=list(
        `type`="software", 
        `author`="Nassos Stylianou and Will william.dahlgreen@bbc.co.uk Dahlgreen and Robert robert.cuffe@bbc.co.uk Cuffe and Tom Calver and Ransome Mpini", 
        `year`=2020, 
        `title`="bbplot: MAKING GGPLOT GRAPHICS IN BBC NEWS STYLE", 
        `publisher`="[R package]. Retrieved from https://github.com/bbc/bbplot", 
        `url`="https://github.com/bbc/bbplot"), 
    `venn`=list(
        `type`="software", 
        `author`="Linlin Yan", 
        `year`=2020, 
        `title`="Venn Diagram by ggplot2, with really easy-to-use API", 
        `publisher`="[R package]. Retrieved from https://github.com/yanlinlin82/ggvenn", 
        `url`="https://github.com/yanlinlin82/ggvenn"), 
    `upset`=list(
        `type`="software", 
        `author`="Jake R Conway, Alexander Lex, Nils Gehlenborg", 
        `year`=2017, 
        `title`="UpSetR: An R Package for the Visualization of Intersecting Sets and their Properties", 
        `doi`="10.1093/bioinformatics/btx364", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=UpSetR", 
        `url`="https://CRAN.R-project.org/package=UpSetR"), 
    `whoisinthisstudy`=list(
        `type`="article", 
        `author`="Hayes-Larson E, Kezios KL, Mooney SJ, Lovasi G.", 
        `year`=2019, 
        `title`="Who is in this study, anyway? Guidelines for a useful Table 1.", 
        `publisher`="J Clin Epidemiol.", 
        `volume`=114, 
        `pages`="125-132", 
        `doi`="10.1016/j.jclinepi.2019.06.011", 
        `url`="https://pubmed.ncbi.nlm.nih.gov/31229583/"), 
    `recist`=list(
        `type`="article", 
        `author`="Eisenhauer EA, Therasse P, Bogaerts J, Schwartz LH, Sargent D, Ford R, Dancey J, Arbuck S, Gwyther S, Mooney M, Rubinstein L, Shankar L, Dodd L, Kaplan R, Lacombe D, Verweij J.", 
        `year`=2009, 
        `title`="New response evaluation criteria in solid tumours: revised RECIST guideline (version 1.1).", 
        `publisher`="Eur J Cancer.", 
        `volume`="45(2)", 
        `pages`="228-47", 
        `doi`="10.1016/j.ejca.2008.10.026", 
        `url`="https://pubmed.ncbi.nlm.nih.gov/19097774/"), 
    `ClinicoPathJamoviModule`=list(
        `type`="software", 
        `author`="Serdar Balci", 
        `year`=2022, 
        `title`="ClinicoPath jamovi Module doi:10.5281/zenodo.3997188", 
        `publisher`="[R package]. Retrieved from https://github.com/sbalci/ClinicoPathJamoviModule", 
        `doi`="10.17605/OSF.IO/9SZUD", 
        `url`="https://www.serdarbalci.com/ClinicoPathJamoviModule/"))


File: R\agepyramid.b.R
--------------------------------------------------
Content of R\agepyramid.b.R:
#' @title Age Pyramid
#' @importFrom R6 R6Class
#' @import jmvcore
#'

# https://stackoverflow.com/questions/14680075/simpler-population-pyramid-in-ggplot2

agepyramidClass <- if (requireNamespace('jmvcore')) R6::R6Class(
    "agepyramidClass",
    inherit = agepyramidBase,
    private = list(
        .run = function() {


            # Error Message ----
            if ( (is.null(self$options$age) || is.null(self$options$gender)) )
                return()

            if (nrow(self$data) == 0) stop("Data contains no (complete) rows")


            # Read data ----

            mydata <- self$data

            age <- self$options$age

            gender <- self$options$gender

            mydata <- jmvcore::select(mydata, c(age, gender))

            mydata <- jmvcore::naOmit(mydata)

            mydata[["Age"]] <- jmvcore::toNumeric(mydata[[age]])

            mydata[["Gender"]] <- as.factor(mydata[[gender]])

            mydata <- mydata %>%
                dplyr::mutate(
                    Gender2 = dplyr::case_when(
                        Gender == self$options$female ~ "Female",
                        TRUE ~ "Male"
                        ))


            mydata[["Pop"]] <- cut(mydata[["Age"]],
                                 include.lowest = TRUE,
                                 right = TRUE,
                                 breaks = c(
                                     seq(from = 0,
                                         to = max(mydata[["Age"]], na.rm = TRUE),
                                         by = 5
                                     ),
                                     max(mydata[["Age"]], na.rm = TRUE)
                                 ),
                                 ordered_result = TRUE
            )


            plotData <- mydata %>%
                dplyr::select(Gender = Gender2,
                              Pop
                              ) %>%
                dplyr::group_by(Gender, Pop) %>%
                dplyr::count()

            image <- self$results$plot
            image$setState(plotData)



            plotData2 <- plotData %>%
                tidyr::pivot_wider(data = .,
                                   names_from = Gender,
                                   values_from = n) %>%
                dplyr::arrange(dplyr::desc(Pop))



            plotData2 <- as.data.frame(plotData2) %>%
                tibble::rownames_to_column(.data = .) %>%
                dplyr::filter(!is.na(Pop)) %>%
                dplyr::mutate(
                    Pop = as.character(Pop)
                )



            pyramidTable <- self$results$pyramidTable

            data_frame <- plotData2
            for(i in seq_along(data_frame[,1,drop=T])) {
                pyramidTable$addRow(rowKey = i, values = c(data_frame[i,]))
            }



        }

        ,
        .plot = function(image, ggtheme, theme, ...) {


            # Error Message ----
            if ( (is.null(self$options$age) || is.null(self$options$gender)) )
                return()

            if (nrow(self$data) == 0) stop("Data contains no (complete) rows")


            # read data ----

            plotData <- image$state

            plot <- ggplot2::ggplot(data = plotData,
                           mapping = ggplot2::aes(
                               x = Pop,
                               y = ifelse(
                                   test = Gender == "Female",
                                   yes = -n,
                                   no = n
                               ),
                               fill = Gender
                           )) +
                ggplot2::geom_col() +
                ggplot2::coord_flip() +
                ggplot2::scale_y_continuous(labels = abs,
                                            limits = max(plotData$n) * c(-1, 1)
                                            ) +
                ggplot2::labs(x = "Age",
                              y = "Population"
                              )


         plot <- plot + ggtheme

         print(plot)
         TRUE

        }


        )
)


File: R\agepyramid.h.R
--------------------------------------------------
Content of R\agepyramid.h.R:

# This file is automatically generated, you probably don't want to edit this

agepyramidOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "agepyramidOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            age = NULL,
            gender = NULL,
            female = NULL, ...) {

            super$initialize(
                package="ClinicoPathDescriptives",
                name="agepyramid",
                requiresData=TRUE,
                ...)

            private$..age <- jmvcore::OptionVariable$new(
                "age",
                age,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..gender <- jmvcore::OptionVariable$new(
                "gender",
                gender,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..female <- jmvcore::OptionLevel$new(
                "female",
                female,
                variable="(gender)")

            self$.addOption(private$..age)
            self$.addOption(private$..gender)
            self$.addOption(private$..female)
        }),
    active = list(
        age = function() private$..age$value,
        gender = function() private$..gender$value,
        female = function() private$..female$value),
    private = list(
        ..age = NA,
        ..gender = NA,
        ..female = NA)
)

agepyramidResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "agepyramidResults",
    inherit = jmvcore::Group,
    active = list(
        pyramidTable = function() private$.items[["pyramidTable"]],
        plot = function() private$.items[["plot"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Age Pyramid",
                refs=list(
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Table$new(
                options=options,
                name="pyramidTable",
                title="Population Data",
                rows=0,
                columns=list(
                    list(
                        `name`="Pop", 
                        `title`="Population", 
                        `type`="text"),
                    list(
                        `name`="Female", 
                        `title`="Female", 
                        `type`="number"),
                    list(
                        `name`="Male", 
                        `title`="Male", 
                        `type`="number")),
                clearWith=list(
                    "age",
                    "gender",
                    "female")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot",
                title="Age Pyramid",
                width=600,
                height=450,
                renderFun=".plot",
                requiresData=TRUE,
                clearWith=list(
                    "age",
                    "gender",
                    "female")))}))

agepyramidBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "agepyramidBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPathDescriptives",
                name = "agepyramid",
                version = c(1,0,0),
                options = options,
                results = agepyramidResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Age Pyramid
#'
#' 
#' @param data The data as a data frame.
#' @param age a string naming the variable from \code{data} that contains the
#'   continuous values used for the report
#' @param gender a string naming the variable from \code{data} that contains
#'   the categorical values used for the report
#' @param female a string naming the level from \code{gender} that contains
#'   the level female
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$pyramidTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$plot} \tab \tab \tab \tab \tab an image \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$pyramidTable$asDF}
#'
#' \code{as.data.frame(results$pyramidTable)}
#'
#' @export
agepyramid <- function(
    data,
    age,
    gender,
    female) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("agepyramid requires jmvcore to be installed (restart may be required)")

    if ( ! missing(age)) age <- jmvcore::resolveQuo(jmvcore::enquo(age))
    if ( ! missing(gender)) gender <- jmvcore::resolveQuo(jmvcore::enquo(gender))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(age), age, NULL),
            `if`( ! missing(gender), gender, NULL))

    for (v in gender) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- agepyramidOptions$new(
        age = age,
        gender = gender,
        female = female)

    analysis <- agepyramidClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\alluvial.b.R
--------------------------------------------------
Content of R\alluvial.b.R:
#' @title Alluvial Plot
#' @return Alluvial Plot
#' @importFrom R6 R6Class
#' @import jmvcore
#' @import ggplot2
#' @importFrom magrittr %>%
#'

alluvialClass <- if (requireNamespace('jmvcore')) R6::R6Class(
    "alluvialClass",
    inherit = alluvialBase,
    private = list(
        .run = function() {

            # Error Message ----


            if (is.null(self$options$vars)) {
                # ToDo Message ----
                todo <- "
                <br>Welcome to ClinicoPath
                <br><br>
                This tool will help you form Alluvial Diagrams (Alluvial Plots).
                <hr><br>
                "

                html <- self$results$todo
                html$setContent(todo)

            } else {
                todo <- ""
                html <- self$results$todo
                html$setContent(todo)



                if (nrow(self$data) == 0) stop("Data contains no (complete) rows")



            }

        }

            ,

            .plot = function(image, ggtheme, theme, ...) {
                # the plot function ----


             #Errors ----

                if (is.null(self$options$vars) )
                    return()

                if (nrow(self$data) == 0)
                    stop('Data contains no (complete) rows')

            # Prepare Data ----

            varsName <- self$options$vars

            mydata <- jmvcore::select(self$data, c(varsName))

            fill <- jmvcore::composeTerm(self$options$fill)


            # Exclude NA ----

            excl <- self$options$excl

            if (excl) {mydata <- jmvcore::naOmit(mydata)}

            # verbose ----
            # verbose <- FALSE
            # verb <- self$options$verb
            # if (isTRUE(verb)) verbose <- TRUE

            # fill_by ----

            fill <- jmvcore::composeTerm(self$options$fill)


            #bin ----

            bin <- self$options$bin

            if (bin == "default") bin <- c("LL", "ML", "M", "MH", "HH")



            # easyalluvial ----
            # https://erblast.github.io/easyalluvial/

            plot <-
                easyalluvial::alluvial_wide( data = mydata,
                                             max_variables = 8,
                                             fill_by = fill,
                                             verbose = TRUE,
                                             # verbose = verb,
                                             bin_labels = bin
                )


            # marginal table ----

            marg <- self$options$marg

            if (marg) {
                plot <- easyalluvial::add_marginal_histograms(p = plot,
                                                              data_input = mydata,
                                                              keep_labels = TRUE,
                                                              top = TRUE,
                                                              plot = TRUE)
                    }

            # Plot orientation ----


            orient <- self$options$orient

            if (orient == "vert") {
                plot <- plot
            } else {
                plot <- plot +
                    ggplot2::coord_flip()
            }




            # # flip coordinates
            #
            # flip <- self$options$flip
            #
            # if (flip) {
            #     plot <- plot +
            #         ggplot2::coord_flip()
            #         # ggplot2::theme_minimal()
            # }




            # # select theme ----
            #
            # themex <- self$options$themex
            #
            #
            # if (themex == "jamovi") {
            #     plot <- plot + ggtheme
            # } else if (marg || themex == "easyalluvial") {
            #     plot <- plot
            # # } else if (themex == "ipsum") {
            # #     plot <- plot + hrbrthemes::theme_ipsum()
            # } else if (themex == "grey") {
            #     plot <- plot + ggplot2::theme_grey()
            # } else if (themex == "gray") {
            #     plot <- plot + ggplot2::theme_gray()
            # } else if (themex == "bw") {
            #     plot <- plot + ggplot2::theme_bw()
            # } else if (themex == "linedraw") {
            #     plot <- plot + ggplot2::theme_linedraw()
            # } else if (themex == "light") {
            #     plot <- plot + ggplot2::theme_light()
            # } else if (themex == "dark") {
            #     plot <- plot + ggplot2::theme_dark()
            # } else if (themex == "minimal") {
            #     plot <- plot + ggplot2::theme_minimal()
            # } else if (themex == "classic") {
            #     plot <- plot + ggplot2::theme_classic()
            # } else if (themex == "void") {
            #     plot <- plot + ggplot2::theme_void()
            # } else if (themex == "test") {
            #     plot <- plot + ggplot2::theme_test()
            # }

            # originaltheme <- self$options$originaltheme
            #
            # if (!originaltheme) {
            #     plot <- plot + ggtheme
            # }


            # add title ----

            mytitle <- self$options$mytitle

            # mytitle <- jmvcore::composeTerm(components = mytitle)


            # use title ----

            usetitle <- self$options$usetitle

            if (marg && usetitle)
                stop("Please do not use Marginal plots with Custom title")


            if (!marg && usetitle) {
                plot <- plot +
                    ggplot2::ggtitle(mytitle)
            }



            # Print Plot ----
            print(plot)
            TRUE
        }

        ,

        .plot2 = function(image, ggtheme, theme, ...) {
            # the plot function ----

            #Errors ----

            if (is.null(self$options$condensationvar) || is.null(self$options$vars))
                return()

            if (nrow(self$data) == 0)
                stop('Data contains no (complete) rows')

            # Prepare Data ----

            condvarName <- self$options$condensationvar

            condvarName <- jmvcore::composeTerm(components = condvarName)

            mydata <- self$data


            # easyalluvial ----

            plot2 <-
                easyalluvial::plot_condensation(df = mydata,
                                                first = .data[[condvarName]])

            # Print Plot ----
            print(plot2)
            TRUE
        }
        )
)




# #Errors ----
#
# if (is.null(self$options$vars) )
#     return()
#
# if (nrow(self$data) == 0)
#     stop('Data contains no (complete) rows')
#
# # Prepare Data ----
#
# varsName <- self$options$vars
#
# mydata <- jmvcore::select(self$data, c(varsName))
#
#
#
# # Exclude NA ----
#
# excl <- self$options$excl
#
# if (excl) {mydata <- jmvcore::naOmit(mydata)}
#
#
# # easyalluvial ----
# # https://erblast.github.io/easyalluvial/
#
# plot <-
#     easyalluvial::alluvial_wide( data = mydata,
#                                  max_variables = 6,
#                                  fill_by = 'first_variable'
#     )
#
#
# # marginal table ----
#
# marg <- self$options$marg
#
# if (marg) {
#     plot <- plot %>%
#         easyalluvial::add_marginal_histograms(mydata)
# }
#
#
#
# # Interactive ----
#
# inter <- self$options$inter
#
# if (inter) {
#     plot <-
#         parcats::parcats(plot,
#                          data_input = mydata)
# }
#
#
# plothtml <- plot
#
# html <- self$results$plothtml
# html$setContent(plothtml)
#

# # Interactive ----
#
# inter <- self$options$inter
#
# if (inter) {
#     plot <-
#         parcats::parcats(plot,
#                          data_input = mydata)
# }






File: R\alluvial.h.R
--------------------------------------------------
Content of R\alluvial.h.R:

# This file is automatically generated, you probably don't want to edit this

alluvialOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "alluvialOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            vars = NULL,
            condensationvar = NULL,
            excl = FALSE,
            marg = FALSE,
            fill = "first_variable",
            bin = "default",
            orient = "vert",
            usetitle = FALSE,
            mytitle = "Alluvial Plot", ...) {

            super$initialize(
                package="ClinicoPathDescriptives",
                name="alluvial",
                requiresData=TRUE,
                ...)

            private$..vars <- jmvcore::OptionVariables$new(
                "vars",
                vars)
            private$..condensationvar <- jmvcore::OptionVariable$new(
                "condensationvar",
                condensationvar)
            private$..excl <- jmvcore::OptionBool$new(
                "excl",
                excl,
                default=FALSE)
            private$..marg <- jmvcore::OptionBool$new(
                "marg",
                marg,
                default=FALSE)
            private$..fill <- jmvcore::OptionList$new(
                "fill",
                fill,
                options=list(
                    "first_variable",
                    "last_variable",
                    "all_flows",
                    "values"),
                default="first_variable")
            private$..bin <- jmvcore::OptionList$new(
                "bin",
                bin,
                options=list(
                    "default",
                    "mean",
                    "median",
                    "min_max",
                    "cuts"),
                default="default")
            private$..orient <- jmvcore::OptionList$new(
                "orient",
                orient,
                options=list(
                    "horr",
                    "vert"),
                default="vert")
            private$..usetitle <- jmvcore::OptionBool$new(
                "usetitle",
                usetitle,
                default=FALSE)
            private$..mytitle <- jmvcore::OptionString$new(
                "mytitle",
                mytitle,
                default="Alluvial Plot")

            self$.addOption(private$..vars)
            self$.addOption(private$..condensationvar)
            self$.addOption(private$..excl)
            self$.addOption(private$..marg)
            self$.addOption(private$..fill)
            self$.addOption(private$..bin)
            self$.addOption(private$..orient)
            self$.addOption(private$..usetitle)
            self$.addOption(private$..mytitle)
        }),
    active = list(
        vars = function() private$..vars$value,
        condensationvar = function() private$..condensationvar$value,
        excl = function() private$..excl$value,
        marg = function() private$..marg$value,
        fill = function() private$..fill$value,
        bin = function() private$..bin$value,
        orient = function() private$..orient$value,
        usetitle = function() private$..usetitle$value,
        mytitle = function() private$..mytitle$value),
    private = list(
        ..vars = NA,
        ..condensationvar = NA,
        ..excl = NA,
        ..marg = NA,
        ..fill = NA,
        ..bin = NA,
        ..orient = NA,
        ..usetitle = NA,
        ..mytitle = NA)
)

alluvialResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "alluvialResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        plot = function() private$.items[["plot"]],
        plot2 = function() private$.items[["plot2"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Alluvial Diagrams",
                refs=list(
                    "easyalluvial",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do",
                clearWith=list(
                    "vars")))
            self$add(jmvcore::Image$new(
                options=options,
                title="Alluvial Diagrams",
                name="plot",
                width=600,
                height=450,
                renderFun=".plot",
                requiresData=TRUE,
                clearWith=list(
                    "vars",
                    "excl",
                    "marg",
                    "verb",
                    "fill",
                    "bin",
                    "orient",
                    "usetitle",
                    "mytitle")))
            self$add(jmvcore::Image$new(
                options=options,
                title="`Condensation Plot ${condensationvar}`",
                name="plot2",
                width=600,
                height=450,
                renderFun=".plot2",
                requiresData=TRUE,
                clearWith=list(
                    "vars",
                    "condensationvar"),
                visible="(condensationvar)"))}))

alluvialBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "alluvialBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPathDescriptives",
                name = "alluvial",
                version = c(1,0,0),
                options = options,
                results = alluvialResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Alluvial Diagrams
#'
#' 
#' @param data The data as a data frame.
#' @param vars a string naming the variables from \code{data} that contains
#'   the values used for the Alluvial Diagram.
#' @param condensationvar The primary variable to be used for condensation.
#' @param excl Exclude missing values from the analysis.
#' @param marg Include marginal plots.
#' @param fill A list for the argument fill for selecting the variable to be
#'   represented by color. Default is 'first_variable'.
#' @param bin labels for the bins from low to high
#' @param orient Orientation of the plot. Default is 'vertical'.
#' @param usetitle Use a custom title for the plot.
#' @param mytitle Title for the plot.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$plot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plot2} \tab \tab \tab \tab \tab an image \cr
#' }
#'
#' @export
alluvial <- function(
    data,
    vars,
    condensationvar,
    excl = FALSE,
    marg = FALSE,
    fill = "first_variable",
    bin = "default",
    orient = "vert",
    usetitle = FALSE,
    mytitle = "Alluvial Plot") {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("alluvial requires jmvcore to be installed (restart may be required)")

    if ( ! missing(vars)) vars <- jmvcore::resolveQuo(jmvcore::enquo(vars))
    if ( ! missing(condensationvar)) condensationvar <- jmvcore::resolveQuo(jmvcore::enquo(condensationvar))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(vars), vars, NULL),
            `if`( ! missing(condensationvar), condensationvar, NULL))


    options <- alluvialOptions$new(
        vars = vars,
        condensationvar = condensationvar,
        excl = excl,
        marg = marg,
        fill = fill,
        bin = bin,
        orient = orient,
        usetitle = usetitle,
        mytitle = mytitle)

    analysis <- alluvialClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\benford.b.R
--------------------------------------------------
Content of R\benford.b.R:

benfordClass <- if (requireNamespace('jmvcore')) R6::R6Class(
    "benfordClass",
    inherit = benfordBase,
    private = list(
        .run = function() {



            todo <- glue::glue("
                               <br>
                               See
                               <a href = 'https://github.com/carloscinelli/benford.analysis'>Package documentation</a> for interpratation.
                               ",
                               # states that:
                               # <br>
                               # After that you have the main statistics of the log mantissa of the data. If the data follows Benfords Law, the numbers should be close to:
                               # <br>
                               #
                               # <table>
                               # <tr>
                               # <th>Statistics</th>
                               # <th>Value</th>
                               # </tr>
                               # <tr>
                               # <td>Mean</td>
                               # <td>0.5</td>
                               # </tr>
                               # <tr>
                               # <td>Variance</td>
                               # <td>1/12 (0.08333…)</td>
                               # </tr>
                               # <tr>
                               # <td>Ex. Kurtosis</td>
                               # <td>-1.2</td>
                               # </tr>
                               # <tr>
                               # <td>Skewness</td>
                               # <td>0</td>
                               # </tr>
                               # </table>
                               # <br>
                               # <hr>
                               # <br>,

                               "<br>
                               Also see <a href = 'https://www.iamnagdev.com/?p=926'>this blog post</a>.
                               <br>
                               <hr>
                               ")

            self$results$todo$setContent(todo)


            # Error Message ----

            if ( is.null(self$options$var) )
                return()

            if (nrow(self$data) == 0) stop("Data contains no (complete) rows")

            # Read data ----

            mydata <- self$data

            # var <- self$options$var

            # var <- jmvcore::composeTerm(components = var)

            var <- jmvcore::constructFormula(terms = self$options$var)

            var <- jmvcore::toNumeric(mydata[[self$options$var]])

            bfd.cp <- benford.analysis::benford(data = var)

            self$results$text$setContent(bfd.cp)

            # Suspects ----

            suspects <- benford.analysis::getSuspects(bfd = bfd.cp, data = mydata)

            self$results$text2$setContent(suspects)

            # Prepare Data for Plot ----

            plotData <- bfd.cp


            # li <- self$options$li
            #
            # if (li) {
            #
            #   # load image
            #   im <- load.image(file.choose()) %>% grayscale()
            #
            #   # perform (DCT)
            #   im_df <- DCT2D(im) %>% as.data.frame()
            #
            #   # apply benford law
            #   bfd.im = benford(im_df$value, number.of.digits = 1, discrete = T, round = 1, sign = "both")
            #   bfd.im
            #
            #
            #   self$results$text$setContent(bfd.im)
            #
            #
            #   # Prepare Data for Plot ----
            #
            #   plotData <- bfd.im
            #
            # }



            # Data for plot ----

            image <- self$results$plot
            image$setState(plotData)





        },

        .plot = function(image, ggtheme, theme, ...) {


            # Error Message ----
            if ( is.null(self$options$var) )
                return()

            if (nrow(self$data) == 0) stop("Data contains no (complete) rows")


            # read data ----

            plotData <- image$state

            plot <- plot(plotData)

            print(plot)
            TRUE

        }


        )
)


File: R\benford.h.R
--------------------------------------------------
Content of R\benford.h.R:

# This file is automatically generated, you probably don't want to edit this

benfordOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "benfordOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            var = NULL, ...) {

            super$initialize(
                package="ClinicoPathDescriptives",
                name="benford",
                requiresData=TRUE,
                ...)

            private$..var <- jmvcore::OptionVariable$new(
                "var",
                var,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))

            self$.addOption(private$..var)
        }),
    active = list(
        var = function() private$..var$value),
    private = list(
        ..var = NA)
)

benfordResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "benfordResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        text = function() private$.items[["text"]],
        text2 = function() private$.items[["text2"]],
        plot = function() private$.items[["plot"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Benford Analysis",
                refs=list(
                    "benford.analysis",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text",
                title="Benford Analysis"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text2",
                title="Suspects"))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot",
                title="Benford Analysis",
                width=600,
                height=450,
                renderFun=".plot",
                requiresData=TRUE))}))

benfordBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "benfordBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPathDescriptives",
                name = "benford",
                version = c(1,0,0),
                options = options,
                results = benfordResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Benford Analysis
#'
#' 
#' @param data The data as a data frame.
#' @param var a string naming the variable from \code{data} that contains the
#'   continuous values used for the report
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$text} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$text2} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$plot} \tab \tab \tab \tab \tab an image \cr
#' }
#'
#' @export
benford <- function(
    data,
    var) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("benford requires jmvcore to be installed (restart may be required)")

    if ( ! missing(var)) var <- jmvcore::resolveQuo(jmvcore::enquo(var))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(var), var, NULL))


    options <- benfordOptions$new(
        var = var)

    analysis <- benfordClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\ClinicoPathDescriptives-package.R
--------------------------------------------------
Content of R\ClinicoPathDescriptives-package.R:
#' \code{ClinicoPathDescriptives}
#'
#' @title ClinicoPathDescriptives: Analysis for Clinicopathological Research
#'
#' @description `ClinicoPathDescriptives` ClinicoPathDescriptives help researchers to generate natural
#' language summaries of their dataset, generate cross tables with statistical
#' tests, and survival analysis with survival tables, survival plots,
#' and natural language summaries.
#'
# @details The main functions are-
# \itemize{
#   \item \code{\link[tableone]{tableone}} function to produce Table One.
#  }
#'
#' For more documentation, see the
#' \href{https://sbalci.github.io/ClinicoPathJamoviModule/}{ClinicoPathJamoviModule Website}.
#' also see the \href{https://sbalci.github.io/ClinicoPathDescriptives/}{ClinicoPathDescriptives Website}.
#'
#' @docType package
#' @aliases ClinicoPathDescriptives ClinicoPathDescriptives-package
#' @name ClinicoPathDescriptives-package
"_PACKAGE"


File: R\crosstable.b.R
--------------------------------------------------
Content of R\crosstable.b.R:
#' @title Cross Table
#' @importFrom R6 R6Class
#' @import jmvcore
#' @importFrom chisq.posthoc.test chisq.posthoc.test
#'

crosstableClass <- if (requireNamespace('jmvcore'))
    R6::R6Class(
        "crosstableClass",
        inherit = crosstableBase,
        private = list(
            # labelData ----

            .labelData = function() {
                # Prepare data for analysis
                mydata <- self$data

                # mydata <- as.data.frame(self$data, stringsAsFactors = TRUE)  # Ensure data is data.frame

                ## Get rownames to data
                # mydata$rownames <- rownames(mydata)

                ## Correct variable names and labels
                # Get original variable names
                original_names <- names(mydata)

                # Save original names as a named vector where the names are the original names,
                # and the values are the labels you want to set, which are also the original names.
                labels <- setNames(original_names, original_names)

                # Clean variable names
                mydata <- mydata %>% janitor::clean_names()

                # Now apply the labels to the cleaned names.
                # Since the variable names have been cleaned, you must match the labels to the cleaned names.
                # The labels vector should have names that are the cleaned names and values that are the original names.
                corrected_labels <-
                    setNames(original_names, names(mydata))

                # Apply the corrected labels
                mydata <- labelled::set_variable_labels(.data = mydata, .labels = corrected_labels)

                # Retrieve all variable labels
                all_labels <- labelled::var_label(mydata)

                # # Retrieve the variable name from the label
                # # Tek değişken için
                # dependent_variable_name_from_label <-
                #     names(all_labels)[all_labels == self$options$outcome]
                #
                # # Retrieve the variable names vector from the label vector
                # # Birden fazla değişkenler için
                # labels <- self$options$explanatory
                #
                # explanatory_variable_names <-
                #     names(all_labels)[match(labels, all_labels)]


                myvars <-  self$options$vars
                myvars <-
                    names(all_labels)[match(myvars, all_labels)]


                mygroup <-
                    names(all_labels)[all_labels == self$options$group]


                return(list(
                    "mydata" = mydata
                    ,
                    "myvars" = myvars
                    ,
                    "mygroup" = mygroup
                ))


            }



            ,
            .run = function() {
                # Select Style ----

                sty <- self$options$sty


                if (is.null(self$options$vars) ||
                    is.null(self$options$group)) {
                    # ToDo Message ----

                    todo <- glue::glue(
                        "
                <br>
                <br>Welcome to ClinicoPath.<br>
                This tool will help you form a Cross Table.<br>
                The functions select hypothesis tests automatically. You may see different results with different tables. Please verify your data distribution and appropriateness of the test accordingly. You may find Statkat module useful.<br>
                Please cite the packages and jamovi using references below.<br><hr>"
                    )

                    html <- self$results$todo
                    html$setContent(todo)
                    return()

                } else {
                    todo <- ""
                    html <- self$results$todo
                    html$setContent(todo)
                }


                if (sty == "finalfit") {
                    todo2 <- glue::glue(
                        "
                    <br>
                    <b>finalfit</b> uses
                    <em>aov (analysis of variance) or t.test for Welch two sample t-test. Note continuous non-parametric test is always Kruskal Wallis (kruskal.test) which in two-group setting is equivalent to Mann-Whitney U /Wilcoxon rank sum test</em>. See full documentation <a href= 'https://finalfit.org/reference/summary_factorlist.html'>here</a>.
                    "
                    )

                }


                if (sty != "finalfit") {
                    todo2 <- glue::glue("")
                }

                html <- self$results$todo2
                html$setContent(todo2)

                # Error Message ----

                if (nrow(self$data) == 0)
                    stop("Data contains no (complete) rows")





                # Read Labelled Data ----

                cleaneddata <- private$.labelData()

                mydata <- cleaneddata$mydata
                myvars <- cleaneddata$myvars
                mygroup <- cleaneddata$mygroup



                # Prepare Data ----

                # mydata <- self$data

                # formulaR <- jmvcore::constructFormula(terms = self$options$vars)
                # formulaL <- jmvcore::constructFormula(terms = self$options$group)

                formula <- jmvcore::constructFormula(
                    terms = myvars,
                    #self$options$vars,
                    dep = mygroup #self$options$group
                    )


                    # formula <- paste(formulaL, '~', formulaR)
                    formula <- as.formula(formula)


                    # self$results$r_cleaneddata$setContent(
                    #     list(
                    #         "mydata" = head(mydata)
                    #         , "myvars" = myvars
                    #         , "mygroup" = mygroup
                    #         , "formula" = formula
                    #         , "names" = names(mydata)
                    #         , "mygroup2" = mydata[[mygroup]][1:10]
                    #
                    #         ))
















                    # Exclude NA ----

                    excl <- self$options$excl

                    if (excl) {
                        mydata <- jmvcore::naOmit(mydata)
                    }



                    # tab3 <- CreateTableOne(vars = myVars, strata = "trt" , data = pbc, factorVars = catVars)


                    ## Arsenal Table ----

                    if (sty == "arsenal") {
                        tablearsenal <- arsenal::tableby(
                            formula = formula,
                            data = mydata,
                            total = TRUE,
                            digits = 1,
                            digits.count = 1
                        )

                        tablearsenal <- summary(tablearsenal, text = 'html', pfootnote = 'html')

                        # tablearsenal_output <- capture.output(tablearsenal)

                        # self$results$tablearsenal_output$setContent(tablearsenal_output)


                        # tablearsenal <-
                        #     kableExtra::kable(tablearsenal,
                        #                       format = "html",
                        #                       digits = 1,
                        #                       escape = FALSE
                        #                       )


                        tablearsenal <- capture.output(tablearsenal)

                        self$results$tablestyle1$setContent(tablearsenal)


                    } else if (sty == "finalfit") {
                        ## FinalFit ----
                        # https://finalfit.org/articles/tables_gallery.html#cross-tables
                        # https://finalfit.org/reference/summary_factorlist.html


                        myvars <- jmvcore::composeTerm(
                            components = myvars #self$options$vars
                            )

                            myvars <- jmvcore::decomposeTerm(term = myvars)

                            # myvars <- jmvcore::decomposeFormula(formula = self$options$vars)
                            # myvars <- unlist(myvars)

                            mydata %>%
                                finalfit::summary_factorlist(
                                    .data = .,
                                    dependent = mygroup,
                                    #self$options$group,
                                    explanatory = myvars,
                                    total_col = TRUE,
                                    p = TRUE,
                                    add_dependent_label = TRUE,
                                    na_include = FALSE,
                                    na_to_p = FALSE,
                                    cont = self$options$cont,
                                    cont_nonpara = NULL,
                                    cont_cut = 5,
                                    cont_range = TRUE,

                                    p_cont_para = "aov",
                                    p_cat = self$options$pcat,

                                    dependent_label_prefix = "Dependent: ",
                                    dependent_label_suffix = "",
                                    row_totals_colname = "Total N",
                                    row_missing_colname = "Missing N",


                                    column = TRUE,

                                    orderbytotal = FALSE,
                                    digits = c(1, 1, 3, 1, 0),


                                    na_include_dependent = FALSE,
                                    na_complete_cases = FALSE,
                                    fit_id = FALSE,

                                    na_to_prop = TRUE,


                                    add_col_totals = TRUE,
                                    include_col_totals_percent = TRUE,
                                    col_totals_rowname = NULL,
                                    col_totals_prefix = "",
                                    add_row_totals = FALSE,
                                    include_row_totals_percent = TRUE,
                                    include_row_missing_col = TRUE,

                                    catTest = NULL,
                                    weights = NULL







                                ) -> tablefinalfit








                            tablefinalfit <- kableExtra::kable(
                                tablefinalfit,
                                format = "html",
                                digits = 1,
                                escape = FALSE
                            )


                            self$results$tablestyle2$setContent(tablefinalfit)


                            } else if (sty == "gtsummary") {
                                ## gtsummary ----

                                # http://www.danieldsjoberg.com/gtsummary/articles/gallery.html


                                tablegtsummary <-
                                    gtsummary::tbl_summary(data = mydata, by = mygroup)



                                #                            , #self$options$group,
                                #                            statistic = list(
                                #                                gtsummary::all_continuous() ~ "{mean} ({sd})",
                                #                                gtsummary::all_categorical() ~ "{n} / {N} ({p}%)"
                                #                            ),
                                #                            digits = gtsummary::all_continuous() ~ 2,
                                #                            missing_text = "(Missing)"
                                #
                                #                            ) %>%
                                #     gtsummary::modify_header(
                                #         update = gtsummary::all_stat_cols() ~ structure("**{level}** N =  {n} ({style_percent(p)}%)", class = "from_markdown")
                                #         # stat_by =
                                #         #                          gt::md("**{level}** N =  {n} ({style_percent(p)}%)")
                                #                                   ) %>%
                                #     gtsummary::add_n(x = .) %>%
                                #     gtsummary::add_overall() %>%
                                #     gtsummary::bold_labels(x = .) %>%
                                #     gtsummary::add_p(x = .,
                                #                      pvalue_fun =
                                #                          purrr::partial(
                                #                              gtsummary::style_pvalue,
                                #                              digits = 2)
                                #                      ) %>%
                                #     gtsummary::add_q()
                                # # %>%
                                # #     gtsummary::bold_labels() %>%
                                # #     gtsummary::bold_levels() %>%
                                # #     gtsummary::bold_p()


                                tablegtsummary <-
                                    gtsummary::as_kable_extra(tablegtsummary)


                                self$results$tablestyle3$setContent(tablegtsummary)


                            } else if (sty %in% c("nejm", "lancet", "hmisc")) {
                                sty <- jmvcore::composeTerm(components = self$options$sty)


                                ## tangram ----


                                tabletangram <-
                                    tangram::html5(
                                        tangram::tangram(
                                            formula,
                                            mydata,
                                            transform = tangram::hmisc,
                                            id = "tbl3",
                                            test = TRUE,
                                            digits = 1,
                                            include_p = TRUE
                                        ),
                                        fragment = TRUE,
                                        style = sty,
                                        caption = paste0("Cross Table for Dependent ", mygroup #self$options$group
                                                         ),
                                                         id = "tbl3")

                                        self$results$tablestyle4$setContent(tabletangram)


                                        # export <- self$options$export
                                        # if (export)
                                        # {
                                        #     if (.Platform$OS.type == "windows") {
                                        #         stopifnot(file.exists("C:\\temp2"))
                                        #         write(
                                        #             x = tabletangram,
                                        #             file = "C:\\temp2\\ClinicoPathCrossTable.html"
                                        #         )
                                        #     } else {
                                        #     write(x = tabletangram,
                                        #           file = "~/Documents/ClinicoPathCrossTable.html"
                                        #           )
                                        #     }
                                        # }


                                        }
                    ## tableone ----
                    # tab3 <- CreateTableOne(vars = myVars, strata = "trt" , data = pbc, factorVars = catVars)



                    # # posthoc
                    #
                    # if (self$options$perform_posthoc &&
                    #     !is.null(self$options$primary_var) &&
                    #     !is.null(self$options$secondary_var)) {
                    #
                    #     tryCatch({
                    #         # Get variable names for labels
                    #         primary_name <- self$options$primary_var
                    #         secondary_name <- self$options$secondary_var
                    #
                    #         # Create contingency table
                    #         cont_table <- table(
                    #             self$data[[primary_name]],
                    #             self$data[[secondary_name]]
                    #         )
                    #
                    #         # Check if table is valid for analysis
                    #         if(nrow(cont_table) > 0 && ncol(cont_table) > 0) {
                    #             # Perform residuals analysis
                    #             residuals_results <- chisq.posthoc.test::chisq.posthoc.test(
                    #                 x = cont_table,
                    #                 method = "bonferroni",
                    #                 round = 3
                    #             )
                    #
                    #             # Format and display results
                    #             posthoc_html <- private$.formatPostHocResults(
                    #                 residuals_results,
                    #                 variable_names = c(primary_name, secondary_name)
                    #             )
                    #
                    #             self$results$posthoc$setContent(posthoc_html)
                    #         } else {
                    #             self$results$posthoc$setContent(
                    #                 "<div class='error'>Unable to perform post-hoc analysis: Invalid contingency table</div>"
                    #             )
                    #         }
                    #     }, error = function(e) {
                    #         self$results$posthoc$setContent(
                    #             sprintf("<div class='error'>Error in post-hoc analysis: %s</div>", e$message)
                    #         )
                    #     })
                    # }


                    # # Pairwise Tests
                    #
                    # if (self$options$perform_posthoc) {
                    #     # Perform Chi-Square Test
                    #
                    #     data_posthoc <- self$data
                    #
                    #     primary_var <- self$options$primary_var
                    #     secondary_var <- self$options$secondary_var
                    #
                    #
                    #     cont_table <- table(data_posthoc[[primary_var]], data_posthoc[[secondary_var]])
                    #
                    #     chi_square_test <- chisq.test(cont_table)
                    #
                    #
                    #
                    #     basic_analysis <- private$.performCrossTableAnalysis(data_posthoc, secondary_var, primary_var)
                    #     self$results$basic_analysis$setContent(basic_analysis)
                    #
                    #
                    #
                    #
                    #
                    #     # Get number of groups
                    #     n_groups <- length(unique(data_posthoc[[secondary_var]]))
                    #
                    #
                    #     # Perform post-hoc analysis if more than 2 groups
                    #     # if (n_groups > 2 && self$options$posthoc != "none")
                    #
                    #
                    #     posthoc_html <- private$.performPostHoc(
                    #         cont_table = cont_table,
                    #         data = data_posthoc,
                    #         group_var = secondary_var,
                    #         response_var = primary_var
                    #     )
                    #
                    #     # Combine main table with post-hoc results
                    #     final_html <- paste0(
                    #         '<br><hr><br>',
                    #         '<div class="posthoc-section">',
                    #         '<h4>Post-hoc Analysis</h4>',
                    #         posthoc_html,
                    #         '</div>'
                    #     )
                    #
                    #     self$results$posthoc$setContent(final_html)
                    # }

                            }

        #     ,
        #     # formatPostHocResults
        #     .formatPostHocResults = function(residuals_results, variable_names) {
        #         # Create both views of the same data
        #         html <- paste0(
        #             '<div class="posthoc-analysis">',
        #
        #             # First view - Grade focus
        #             sprintf('<h3>Chi-square Post-hoc Analysis Results</h3>
        #         <table class="table table-striped">
        #         <thead>
        #             <tr>
        #                 <th>%s</th>
        #                 <th>Measure</th>
        #                 <th>%s Absent</th>
        #                 <th>%s Present</th>
        #             </tr>
        #         </thead>
        #         <tbody>',
        #                     variable_names[1], variable_names[2], variable_names[2]),
        #             # Note the change from self$ to private$ here:
        #             private$.formatResidualRows(residuals_results),
        #             '</tbody></table>',
        #
        #             # Interpretation guide
        #             '<h4>How to Interpret These Results:</h4>
        # <ul>
        #     <li><strong>Residuals:</strong> Show how much each combination differs from expected values
        #         <ul>
        #             <li>Values greater than 1.96 or less than -1.96 indicate significant differences</li>
        #             <li>Positive values: more cases than expected</li>
        #             <li>Negative values: fewer cases than expected</li>
        #         </ul>
        #     </li>
        #     <li><strong>P-values:</strong> Show statistical significance after Bonferroni correction
        #         <ul>
        #             <li>Values less than 0.05 would indicate significant differences</li>
        #             <li>All values = 1.000 here indicate no significant differences</li>
        #         </ul>
        #     </li>
        # </ul>',
        #
        #             # Summary
        #             '<div class="summary-box">
        # <h4>Summary of Your Results:</h4>
        # <p>',
        #             # Note the change from self$ to private$ here:
        #             private$.generateResultsSummary(residuals_results, variable_names),
        #             '</p>
        # </div>',
        #
        #             # Second view
        #             sprintf('<h3>Chi-square Post-hoc Analysis - %s Focus</h3>', variable_names[2]),
        #             # Note the change from self$ to private$ here:
        #             private$.formatAlternativeView(residuals_results, variable_names),
        #             '</div>',
        #
        #             # Styling remains the same
        #             '<style>
        # .posthoc-analysis {
        #     font-family: Arial, sans-serif;
        #     margin: 20px 0;
        # }
        # .posthoc-analysis table {
        #     width: 100%;
        #     border-collapse: collapse;
        #     margin: 15px 0;
        # }
        # .posthoc-analysis th, .posthoc-analysis td {
        #     padding: 8px;
        #     text-align: left;
        #     border: 1px solid #ddd;
        # }
        # .posthoc-analysis th {
        #     background-color: #f5f5f5;
        # }
        # .summary-box {
        #     background-color: #f8f9fa;
        #     border-radius: 5px;
        #     padding: 15px;
        #     margin: 20px 0;
        # }
        # .interpretation-box {
        #     background-color: #e9ecef;
        #     padding: 15px;
        #     margin: 10px 0;
        #     border-radius: 5px;
        # }
        # </style>'
        #         )
        #
        #         return(html)
        #     }



            # ,
            # .generateResultsSummary = function(results, variable_names) {
            #     # Extract max absolute residual
            #     max_residual <- max(abs(results$residuals))
            #
            #     summary <- sprintf(
            #         "No significant associations were found between %s and %s status. All residuals are well below the critical value of ±1.96, and all adjusted p-values are 1.000, indicating that the distribution of %s is similar across all grades.",
            #         variable_names[1],
            #         variable_names[2],
            #         variable_names[2]
            #     )
            #
            #     return(summary)
            # }

            # ,
            # .formatAlternativeView = function(residuals_results, variable_names) {
            #     # Format second view focusing on the other variable
            #     html <- paste0(
            #         '<div class="interpretation-box">',
            #         sprintf('<h4>Interpretation of %s Effects:</h4>', variable_names[2]),
            #         '<ul>',
            #         sprintf('<li><strong>%s Absent:</strong><br>', variable_names[2]),
            #         self$formatEffectInterpretation(residuals_results, "absent"),
            #         '</li>',
            #         sprintf('<li><strong>%s Present:</strong><br>', variable_names[2]),
            #         self$formatEffectInterpretation(residuals_results, "present"),
            #         '</li>',
            #         '<li><strong>Statistical Significance:</strong><br>',
            #         'All residuals are well below critical value (±1.96)<br>',
            #         'All p-values = 1.000 indicate no significant deviations<br>',
            #         sprintf(
            #             '%s distribution is similar across all grades',
            #             variable_names[2]
            #         ),
            #         '</li>',
            #         '</ul>',
            #         '</div>'
            #     )
            #     return(html)
            # }


        #     ,
        #     # .performCrossTableAnalysis
        #     .performCrossTableAnalysis = function(data, group_var, response_var) {
        #         # Create the contingency table
        #         cont_table <- table(data[[response_var]], data[[group_var]])
        #         # Get margins
        #         row_totals <- rowSums(cont_table)
        #         col_totals <- colSums(cont_table)
        #         n <- sum(cont_table)
        #
        #         # Calculate expected frequencies
        #         expected <- outer(row_totals, col_totals) / n
        #
        #         # Check conditions for Chi-Square vs Fisher's
        #         expected_less_than_5 <- sum(expected < 5)
        #         percent_less_than_5 <- (expected_less_than_5 / length(expected)) * 100
        #         min_expected <- min(expected)
        #
        #         # Perform Chi-Square test
        #         chi_result <- chisq.test(cont_table)
        #
        #         # Perform Fisher's exact test if needed
        #         fisher_needed <- (percent_less_than_5 > 20) ||
        #             (min_expected < 1)
        #         if (fisher_needed) {
        #             fisher_result <- fisher.test(cont_table, simulate.p.value = TRUE)
        #         }
        #
        #         # Create detailed HTML output
        #         html <- paste0(
        #             '<div class="analysis-results">',
        #
        #             # 1. Cross-tabulation
        #             '<section class="cross-table">',
        #             '<h4>Contingency Table Analysis</h4>',
        #             '<p>The following table shows the distribution of cases across TStage levels and groups:</p>',
        #             kableExtra::kable(cont_table, format = "html", caption = "Cross-tabulation of TStage by Group") %>%
        #                 kableExtra::kable_styling(bootstrap_options = c("striped", "hover")),
        #             '</section><br>',
        #
        #             # 2. Data description
        #             '<section class="data-description">',
        #             '<h4>Data Description</h4>',
        #             sprintf(
        #                 '<p>The analysis includes %d total observations distributed across %d rows and %d columns. ',
        #                 n,
        #                 nrow(cont_table),
        #                 ncol(cont_table)
        #             ),
        #             'The data represents the relationship between TStage and group membership.</p>',
        #             '</section><br>',
        #
        #             # 3. Chi-Square Test Results
        #             '<section class="chi-square">',
        #             '<h4>Chi-Square Test of Independence</h4>',
        #             '<p>Test results:</p>',
        #             sprintf(
        #                 '<ul>',
        #                 '<li>Chi-square statistic = %.3f</li>',
        #                 '<li>Degrees of freedom = %d</li>',
        #                 '<li>p-value = %.3f</li>',
        #                 '</ul>',
        #                 chi_result$statistic,
        #                 chi_result$parameter,
        #                 chi_result$p.value
        #             ),
        #             '<p><strong>Interpretation:</strong> ',
        #             if (chi_result$p.value < 0.05) {
        #                 'There is a significant association between TStage and group membership (p < 0.05).'
        #             } else {
        #                 'There is no significant association between TStage and group membership (p ≥ 0.05).'
        #             },
        #             '</p>',
        #             '</section><br>',
        #
        #             # 4. Assumptions Check
        #             '<section class="assumptions">',
        #             '<h4>Chi-Square Test Assumptions</h4>',
        #             sprintf(
        #                 '<ul>',
        #                 '<li>Minimum expected frequency: %.2f</li>',
        #                 '<li>Number of cells with expected frequency < 5: %d (%.1f%%)</li>',
        #                 '</ul>',
        #                 min_expected,
        #                 expected_less_than_5,
        #                 percent_less_than_5
        #             ),
        #             if (fisher_needed) {
        #                 paste0(
        #                     '<p><strong>Note:</strong> Chi-Square test assumptions are violated ',
        #                     '(>20% cells have expected frequencies <5 or minimum expected frequency <1). ',
        #                     'Fisher\'s Exact Test is recommended and provided below.</p>'
        #                 )
        #             } else {
        #                 '<p><strong>Note:</strong> Chi-Square test assumptions are met.</p>'
        #             },
        #             '</section><br>'
        #         )
        #
        #         # 5. Fisher's Exact Test if needed
        #         if (fisher_needed) {
        #             html <- paste0(
        #                 html,
        #                 '<section class="fisher">',
        #                 '<h4>Fisher\'s Exact Test</h4>',
        #                 sprintf(
        #                     '<p>Fisher\'s Exact Test p-value = %.3f</p>',
        #                     fisher_result$p.value
        #                 ),
        #                 '<p><strong>Interpretation:</strong> ',
        #                 if (fisher_result$p.value < 0.05) {
        #                     'There is a significant association between TStage and group membership (p < 0.05).'
        #                 } else {
        #                     'There is no significant association between TStage and group membership (p ≥ 0.05).'
        #                 },
        #                 '</p>',
        #                 '</section>'
        #             )
        #         }
        #
        #         html <- paste0(html, '</div>')
        #
        #         # Add some CSS styling
        #         html <- paste0(
        #             '<style>
        # .analysis-results {
        #     font-family: Arial, sans-serif;
        #     line-height: 1.6;
        #     max-width: 800px;
        #     margin: 0 auto;
        # }
        # .analysis-results section {
        #     margin-bottom: 20px;
        #     padding: 15px;
        #     background: #f8f9fa;
        #     border-radius: 5px;
        # }
        # .analysis-results h4 {
        #     color: #2c3e50;
        #     margin-bottom: 15px;
        # }
        # .analysis-results ul {
        #     margin-left: 20px;
        # }
        # </style>',
        #             html
        #         )
        #
        #         return(html)
        #     }






            # ,
            # # Format residuals results
            # .formatResiduals = function(results) {
            #     # Format residuals results as HTML table
            #     html <- kableExtra::kable(results,
            #                               format = "html",
            #                               caption = "Cell Residuals Analysis",
            #                               digits = 3) %>%
            #         kableExtra::kable_styling(
            #             bootstrap_options = c("striped", "hover", "condensed"),
            #             full_width = FALSE
            #         ) %>%
            #         kableExtra::add_footnote(
            #             c(
            #                 "Residuals > |1.96| indicate significant deviation",
            #                 "P-values adjusted using Bonferroni correction"
            #             ),
            #             notation = "symbol"
            #         )
            #
            #     return(html)
            # }



            # ,
            # # Update the .performPairwiseTests function
            # .performPairwiseTests = function(data, group_var, response_var) {
            #     # Get all valid levels (excluding NA)
            #     group_levels <- sort(unique(data[[group_var]]))
            #     group_levels <- group_levels[!is.na(group_levels)]
            #     results <- list()
            #
            #     for (i in 1:(length(group_levels) - 1)) {
            #         for (j in (i + 1):length(group_levels)) {
            #             # Create subset excluding NA values
            #             subset_data <- subset(data,
            #                                   data[[group_var]] %in% c(group_levels[i], group_levels[j]) &
            #                                       !is.na(data[[response_var]]))
            #
            #             if (nrow(subset_data) > 0) {
            #                 table_ij <- table(subset_data[[group_var]], subset_data[[response_var]])
            #
            #                 test <- suppressWarnings(chisq.test(table_ij))
            #
            #                 comparison_name <- sprintf("TStage %s vs %s", group_levels[i], group_levels[j])
            #                 results[[comparison_name]] <- list(
            #                     chi_square = test$statistic,
            #                     df = test$parameter,
            #                     p_value = test$p.value,
            #                     n1 = sum(subset_data[[group_var]] == group_levels[i]),
            #                     n2 = sum(subset_data[[group_var]] == group_levels[j])
            #                 )
            #             }
            #         }
            #     }
            #     return(results)
            # }

            # ,
            # # Update the .formatPairwise function
            # .formatPairwise = function(results) {
            #     # Convert list to data frame
            #     df <- do.call(rbind, lapply(names(results), function(name) {
            #         data.frame(
            #             Comparison = name,
            #             N1 = results[[name]]$n1,
            #             N2 = results[[name]]$n2,
            #             ChiSquare = round(results[[name]]$chi_square, 3),
            #             df = results[[name]]$df,
            #             p_value = round(results[[name]]$p_value, 3),
            #             stringsAsFactors = FALSE
            #         )
            #     }))
            #
            #     # Format as HTML table with better explanations
            #     html <- paste0(
            #         '<h4>Pairwise Chi-square Tests</h4>',
            #         '<p>Each row represents a comparison between two TStage levels:</p>',
            #         kableExtra::kable(
            #             df,
            #             format = "html",
            #             col.names = c(
            #                 "Comparison",
            #                 "N (Group 1)",
            #                 "N (Group 2)",
            #                 "Chi-Square",
            #                 "df",
            #                 "p-value"
            #             )
            #         ) %>%
            #             kableExtra::kable_styling(
            #                 bootstrap_options = c("striped", "hover", "condensed"),
            #                 full_width = FALSE
            #             ) %>%
            #             kableExtra::add_footnote(
            #                 c(
            #                     "p-values are unadjusted for multiple comparisons",
            #                     "Consider using Bonferroni correction by multiplying p-values by number of comparisons"
            #                 )
            #             )
            #     )
            #     return(html)
            # }

        #     ,
        #     # .performPostHoc function
        # .performPostHoc = function(cont_table, data, group_var, response_var) {
        #     # Get variable names for nice display
        #     var1_name <- response_var
        #     var2_name <- group_var
        #
        #     # Perform Chi-square test
        #     chi_result <- suppressWarnings(chisq.test(cont_table))
        #
        #     # Check if Fisher's exact test is needed
        #     expected <- chi_result$expected
        #     fisher_needed <- (sum(expected < 5) / length(expected)) > 0.2
        #
        #     if(fisher_needed) {
        #         fisher_result <- fisher.test(cont_table, simulate.p.value = TRUE)
        #     }
        #
        #     # Start building HTML output
        #     html <- paste0(
        #         '<div class="analysis-container">',
        #         '<h3>Statistical Analysis Results</h3>',
        #         '<div class="main-test">',
        #         sprintf('<h4>Cross-tabulation of %s by %s</h4>', var1_name, var2_name),
        #         '<table class="cross-table">',
        #         private$.formatContingencyTable(cont_table),
        #         '</table>',
        #
        #         '<div class="test-results">',
        #         sprintf('<h4>%s Results</h4>',
        #                 if(fisher_needed) "Fisher's Exact Test" else "Chi-square Test"),
        #         '<ul>',
        #         if(!fisher_needed) {
        #             sprintf(
        #                 paste(
        #                     '<li>Chi-square statistic: %.3f</li>',
        #                     '<li>Degrees of freedom: %d</li>',
        #                     '<li>p-value: %.3f</li>'
        #                 ),
        #                 chi_result$statistic,
        #                 chi_result$parameter,
        #                 chi_result$p.value
        #             )
        #         } else {
        #             sprintf('<li>Fisher\'s Exact Test p-value: %.3f</li>',
        #                     fisher_result$p.value)
        #         },
        #         '</ul>',
        #         sprintf('<p><strong>Interpretation:</strong> %s</p>',
        #                 private$.generateSummaryText(chi_result, fisher_needed,
        #                                           if(fisher_needed) fisher_result else NULL)),
        #         '</div>'
        #     )
        #
        #     # Add post-hoc analysis based on method selection
        #     if(self$options$posthoc_method %in% c("both", "residuals")) {
        #         residuals_results <- chisq.posthoc.test::chisq.posthoc.test(
        #             cont_table, method = "bonferroni")
        #
        #         html <- paste0(html,
        #                        '<div class="post-hoc-residuals">',
        #                        '<h4>Standardized Residuals Analysis</h4>',
        #                        private$.formatResiduals(residuals_results),
        #                        '</div>'
        #         )
        #     }
        #
        #     if(self$options$posthoc_method %in% c("both", "pairwise")) {
        #         pairwise_results <- private$.performPairwiseTests(
        #             data, group_var, response_var)
        #
        #         html <- paste0(html,
        #                        '<div class="post-hoc-pairwise">',
        #                        '<h4>Pairwise Comparisons</h4>',
        #                        private$.formatPairwise(pairwise_results),
        #                        '</div>'
        #         )
        #     }
        #
        #     # Add styling
        #     html <- paste0(html,
        #                    '<style>
        # .analysis-container {
        #     font-family: Arial, sans-serif;
        #     max-width: 900px;
        #     margin: 20px auto;
        #     padding: 20px;
        # }
        # .cross-table, .results-table {
        #     width: 100%;
        #     border-collapse: collapse;
        #     margin: 15px 0;
        # }
        # .cross-table th, .cross-table td,
        # .results-table th, .results-table td {
        #     padding: 8px;
        #     border: 1px solid #ddd;
        #     text-align: center;
        # }
        # .cross-table th {
        #     background-color: #f5f5f5;
        # }
        # .main-test, .post-hoc-residuals, .post-hoc-pairwise {
        #     background: #fff;
        #     padding: 20px;
        #     margin: 20px 0;
        #     border-radius: 5px;
        #     box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        # }
        # h3, h4 {
        #     color: #2c3e50;
        #     margin-bottom: 15px;
        # }
        # .test-results {
        #     background: #f8f9fa;
        #     padding: 15px;
        #     border-radius: 5px;
        #     margin: 15px 0;
        # }
        # </style>',
        #                    '</div>'
        #     )
        #
        #     return(html)
        # }

        # ,
        # # Helper function to format contingency table
        # .formatContingencyTable = function(cont_table) {
        #     # Create header row
        #     header <- sprintf(
        #         '<tr><th></th>%s</tr>',
        #         paste(sprintf('<th>%s</th>', colnames(cont_table)), collapse='')
        #     )
        #
        #     # Create data rows
        #     rows <- character()
        #     for(i in 1:nrow(cont_table)) {
        #         rows <- c(rows, sprintf(
        #             '<tr><th>%s</th>%s</tr>',
        #             rownames(cont_table)[i],
        #             paste(sprintf('<td>%d</td>', cont_table[i,]), collapse='')
        #         ))
        #     }
        #
        #     return(paste(c(header, rows), collapse='\n'))
        # }

            # ,
            # # Add these helper functions to the private list
            # .formatResidualRows = function(results) {
            #     # Get all unique levels from the results
            #     levels <- unique(rownames(results$observed))
            #
            #     rows <- character()
            #     for (level in levels) {
            #         # Get residuals and p-values for this level
            #         residuals <- results$stdres[level, ]
            #         p_values <- results$pvalues[level, ]
            #
            #         # Create row for residuals
            #         residual_row <- sprintf(
            #             '<tr><td rowspan="2">%s</td><td>Residuals</td>%s</tr>',
            #             level,
            #             paste(sprintf('<td>%.3f</td>', residuals), collapse = '')
            #         )
            #
            #         # Create row for p-values
            #         pvalue_row <- sprintf('<tr><td>p-values</td>%s</tr>',
            #                               paste(sprintf('<td>%.3f</td>', p_values), collapse = ''))
            #
            #         rows <- c(rows, residual_row, pvalue_row)
            #     }
            #
            #     return(paste(rows, collapse = '\n'))
            # }

            # ,
            # .formatEffectInterpretation = function(residuals_results, type) {
            #     interpretations <- character()
            #
            #     # Get relevant rows from results
            #     observed <- residuals_results$observed
            #     residuals <- residuals_results$stdres
            #
            #     # For each level in the primary variable
            #     for (i in 1:nrow(residuals)) {
            #         level <- rownames(residuals)[i]
            #         res <- residuals[i, ]
            #
            #         # Generate interpretation based on residual values
            #         effects <- character()
            #         for (j in 1:length(res)) {
            #             if (abs(res[j]) > 0) {
            #                 # Only mention non-zero effects
            #                 direction <- if (res[j] < 0)
            #                     "under-represented"
            #                 else
            #                     "over-represented"
            #                 strength <- if (abs(res[j]) < 0.5)
            #                     "slightly"
            #                 else
            #                     if (abs(res[j]) < 1.0)
            #                         "moderately"
            #                 else
            #                     if (abs(res[j]) < 1.96)
            #                         "notably"
            #                 else
            #                     "significantly"
            #
            #                 effects <- c(effects,
            #                              sprintf("%s %s (%.3f)", strength, direction, res[j]))
            #             }
            #         }
            #
            #         if (length(effects) > 0) {
            #             interpretations <- c(interpretations,
            #                                  sprintf(
            #                                      "%s in %s (%s)",
            #                                      level,
            #                                      colnames(residuals)[j],
            #                                      paste(effects, collapse = ", ")
            #                                  ))
            #         }
            #     }
            #
            #     return(paste(interpretations, collapse = "<br>"))
            # }

            # ,
            # .generateSummaryText = function(chi_result,
            #                                 fisher_needed,
            #                                 fisher_result = NULL) {
            #     if (fisher_needed && !is.null(fisher_result)) {
            #         test_type <- "Fisher's Exact Test"
            #         p_value <- fisher_result$p.value
            #     } else {
            #         test_type <- "Chi-square Test"
            #         p_value <- chi_result$p.value
            #     }
            #
            #     if (p_value < 0.05) {
            #         return(
            #             sprintf(
            #                 "The %s shows a significant association (p = %.3f).
            # This suggests the variables are not independent.",
            #                 test_type,
            #                 p_value
            #             )
            #         )
            #     } else {
            #         return(
            #             sprintf(
            #                 "The %s shows no significant association (p = %.3f).
            # This suggests the variables may be independent.",
            #                 test_type,
            #                 p_value
            #             )
            #         )
            #     }
            # }


            )
                )


File: R\crosstable.h.R
--------------------------------------------------
Content of R\crosstable.h.R:

# This file is automatically generated, you probably don't want to edit this

crosstableOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "crosstableOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            vars = NULL,
            group = NULL,
            sty = "nejm",
            excl = FALSE,
            cont = "mean",
            pcat = "chisq", ...) {

            super$initialize(
                package="ClinicoPathDescriptives",
                name="crosstable",
                requiresData=TRUE,
                ...)

            private$..vars <- jmvcore::OptionVariables$new(
                "vars",
                vars)
            private$..group <- jmvcore::OptionVariable$new(
                "group",
                group,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..sty <- jmvcore::OptionList$new(
                "sty",
                sty,
                options=list(
                    "arsenal",
                    "finalfit",
                    "gtsummary",
                    "nejm",
                    "lancet",
                    "hmisc"),
                default="nejm")
            private$..excl <- jmvcore::OptionBool$new(
                "excl",
                excl,
                default=FALSE)
            private$..cont <- jmvcore::OptionList$new(
                "cont",
                cont,
                options=list(
                    "mean",
                    "median"),
                default="mean")
            private$..pcat <- jmvcore::OptionList$new(
                "pcat",
                pcat,
                options=list(
                    "chisq",
                    "fisher"),
                default="chisq")

            self$.addOption(private$..vars)
            self$.addOption(private$..group)
            self$.addOption(private$..sty)
            self$.addOption(private$..excl)
            self$.addOption(private$..cont)
            self$.addOption(private$..pcat)
        }),
    active = list(
        vars = function() private$..vars$value,
        group = function() private$..group$value,
        sty = function() private$..sty$value,
        excl = function() private$..excl$value,
        cont = function() private$..cont$value,
        pcat = function() private$..pcat$value),
    private = list(
        ..vars = NA,
        ..group = NA,
        ..sty = NA,
        ..excl = NA,
        ..cont = NA,
        ..pcat = NA)
)

crosstableResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "crosstableResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        todo2 = function() private$.items[["todo2"]],
        tablestyle1 = function() private$.items[["tablestyle1"]],
        tablestyle2 = function() private$.items[["tablestyle2"]],
        tablestyle3 = function() private$.items[["tablestyle3"]],
        tablestyle4 = function() private$.items[["tablestyle4"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="`Cross Table - ${group}`",
                refs=list(
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do",
                clearWith=list(
                    "vars",
                    "group")))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo2",
                title="To Do",
                clearWith=list(
                    "vars",
                    "group",
                    "sty")))
            self$add(jmvcore::Html$new(
                options=options,
                name="tablestyle1",
                title="`Cross Table - ${group}`",
                clearWith=list(
                    "vars",
                    "group",
                    "sty"),
                visible="(sty:arsenal)",
                refs="arsenal"))
            self$add(jmvcore::Html$new(
                options=options,
                name="tablestyle2",
                title="`Cross Table - ${group}`",
                clearWith=list(
                    "vars",
                    "group",
                    "cont",
                    "pcat",
                    "sty"),
                visible="(sty:finalfit)",
                refs="finalfit"))
            self$add(jmvcore::Html$new(
                options=options,
                name="tablestyle3",
                title="`Cross Table - ${group}`",
                clearWith=list(
                    "vars",
                    "group",
                    "sty"),
                visible="(sty:gtsummary)",
                refs="gtsummary"))
            self$add(jmvcore::Html$new(
                options=options,
                name="tablestyle4",
                title="`Cross Table - ${group}`",
                clearWith=list(
                    "vars",
                    "group",
                    "sty"),
                visible="(sty:nejm || sty:lancet || sty:hmisc)",
                refs="tangram"))}))

crosstableBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "crosstableBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPathDescriptives",
                name = "crosstable",
                version = c(1,0,0),
                options = options,
                results = crosstableResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Cross Tables
#'
#' Function for making Cross Tables.
#'
#' @examples
#' \donttest{
#' # example will be added
#'}
#' @param data The data as a data frame.
#' @param vars variable in the rows
#' @param group variable in the column
#' @param sty .
#' @param excl .
#' @param cont .
#' @param pcat .
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$todo2} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$tablestyle1} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$tablestyle2} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$tablestyle3} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$tablestyle4} \tab \tab \tab \tab \tab a html \cr
#' }
#'
#' @export
crosstable <- function(
    data,
    vars,
    group,
    sty = "nejm",
    excl = FALSE,
    cont = "mean",
    pcat = "chisq") {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("crosstable requires jmvcore to be installed (restart may be required)")

    if ( ! missing(vars)) vars <- jmvcore::resolveQuo(jmvcore::enquo(vars))
    if ( ! missing(group)) group <- jmvcore::resolveQuo(jmvcore::enquo(group))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(vars), vars, NULL),
            `if`( ! missing(group), group, NULL))

    for (v in group) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- crosstableOptions$new(
        vars = vars,
        group = group,
        sty = sty,
        excl = excl,
        cont = cont,
        pcat = pcat)

    analysis <- crosstableClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\data-histopathology.R
--------------------------------------------------
Content of R\data-histopathology.R:
#' @title histopathology
#'
#' @description Fake histopathology research data.
#' @usage data(histopathology)
#' @format A data frame
"histopathology"


File: R\data-treatmentResponse.R
--------------------------------------------------
Content of R\data-treatmentResponse.R:
#' #' @title treatmentResponse
#' #'
#' #' @description Fake response to treatment research data.
#' #' @usage data(treatmentResponse)
#' #' @format A data frame
#' "treatmentResponse"


File: R\posthoc_utils.R
--------------------------------------------------
Content of R\posthoc_utils.R:
#' Perform cell residuals analysis
#' @param cont_table Contingency table
#' @param method Method for p-value adjustment
#' @return List with residuals and p-values
perform_residuals_analysis <- function(cont_table, method = "bonferroni") {
  results <- chisq.posthoc.test::chisq.posthoc.test(
    x = cont_table,
    method = method,
    round = 3
  )
  return(results)
}

#' Perform pairwise chi-square tests
#' @param data Data frame
#' @param group_var Group variable name
#' @param response_var Response variable name
#' @param method Method for p-value adjustment
#' @return List of pairwise comparison results
perform_pairwise_tests <- function(data, group_var, response_var, method = "bonferroni") {
  group_levels <- unique(data[[group_var]])
  n_groups <- length(group_levels)
  results <- list()

  if(n_groups > 2) {
    # Perform pairwise comparisons
    for(i in 1:(n_groups-1)) {
      for(j in (i+1):n_groups) {
        subset_data <- data[data[[group_var]] %in% c(group_levels[i], group_levels[j]),]
        subtable <- table(subset_data[[group_var]], subset_data[[response_var]])

        test_result <- suppressWarnings(chisq.test(subtable))

        comparison_name <- paste(group_levels[i], "vs", group_levels[j])
        results[[comparison_name]] <- list(
          comparison = comparison_name,
          chi_square = test_result$statistic,
          df = test_result$parameter,
          p_value = test_result$p.value
        )
      }
    }

    # Adjust p-values
    p_values <- sapply(results, function(x) x$p_value)
    adjusted_p_values <- p.adjust(p_values, method = method)

    # Add adjusted p-values
    for(i in seq_along(results)) {
      results[[i]]$adjusted_p_value <- adjusted_p_values[i]
    }
  }

  return(results)
}

#' Format post-hoc results as HTML
#' @param residuals_results Results from residuals analysis
#' @param pairwise_results Results from pairwise tests
#' @return HTML string
format_posthoc_html <- function(residuals_results = NULL, pairwise_results = NULL) {
  html_parts <- list()

  if(!is.null(residuals_results)) {
    # Format residuals table
    res_table <- kableExtra::kable(
      residuals_results,
      format = "html",
      caption = "Cell Residuals Analysis",
      digits = 3
    ) %>%
      kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))

    html_parts$residuals <- res_table
  }

  if(!is.null(pairwise_results) && length(pairwise_results) > 0) {
    # Create data frame from pairwise results
    pair_df <- do.call(rbind, lapply(pairwise_results, function(x) {
      data.frame(
        Comparison = x$comparison,
        ChiSquare = round(x$chi_square, 3),
        df = x$df,
        p_value = round(x$p_value, 3),
        adjusted_p = round(x$adjusted_p_value, 3)
      )
    }))

    # Format pairwise table
    pair_table <- kableExtra::kable(
      pair_df,
      format = "html",
      caption = "Pairwise Comparisons",
      col.names = c("Comparison", "Chi-Square", "df", "p-value", "Adjusted p-value")
    ) %>%
      kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))

    html_parts$pairwise <- pair_table
  }

  # Combine results based on what's available
  if(length(html_parts) == 2) {
    # Both analyses
    html_output <- paste0(
      '<div class="posthoc-analyses">',
      '<div class="residuals-section">',
      html_parts$residuals,
      '</div><br><br>',
      '<div class="pairwise-section">',
      html_parts$pairwise,
      '</div>',
      '</div>'
    )
  } else {
    # Single analysis
    html_output <- paste0(
      '<div class="posthoc-analyses">',
      html_parts[[1]],
      '</div>'
    )
  }

  return(html_output)
}


File: R\reportcat.b.R
--------------------------------------------------
Content of R\reportcat.b.R:
#' @title Summary of Categorical Variables
#' @return Text
#'
#' @importFrom R6 R6Class
#' @import jmvcore
#' @importFrom magrittr %>%
#' @importFrom gtExtras gt_plt_summary
#'

reportcatClass <- if (requireNamespace('jmvcore')) R6::R6Class(
    "reportcatClass",
    inherit = reportcatBase,
    private = list(
        .run = function() {


            # # Error Message ----
            #
            # if (nrow(self$data) == 0) stop("Data contains no (complete) rows")
            #
            # if ( (is.null(self$options$vars) || is.null(self$options$facs)) && is.null(self$options$target) ) {
            #     # ToDo Message ----
            #     todo <- "
            #         <br>Welcome to ClinicoPath
            #                   <br><br>
            #                   This tool will help you form an Alluvial Plots.
            #                   "
            #     html <- self$results$todo
            #     html$setContent(todo)
            #
            # } else {
            #     todo <- ""
            #     html <- self$results$todo
            #     html$setContent(todo)
            #
            #
            #
            # }








            if (length(self$options$vars) == 0) {
                # ToDo Message ----

                todo <- "
                <br>Welcome to ClinicoPath
                          <br><br>
                          This tool will help you to write a general summary of variables
                              in your data.
                          <br><br>
                          Select the 'Variables' you want to include in the summary. Nominal, Ordinal and Categorical variables are allowed.
                          <hr><br>
                          "

                html <- self$results$todo
                html$setContent(todo)
                return()
            } else {

                todo <- ""
                html <- self$results$todo
                html$setContent(todo)



                if (nrow(self$data) == 0)
                    stop('Data contains no (complete) rows')



            mydata <- self$data

            # med <- self$options$med
            # cent <- self$options$cent
            # disp <- self$options$disp
            # ran <- self$options$ran
            # distr <- self$options$distr
            # lev <- self$options$lev
            # n_ch <- self$options$n_ch
            # mis <- self$options$mis

            formula <- jmvcore::constructFormula(terms = self$options$vars)

            myvars <- jmvcore::decomposeFormula(formula = formula)

            myvars <- unlist(myvars)


            # myreport <- mydata %>%
            #     select(myvars) %>%
            #     report::report(.,
            #                    median = FALSE,
            #                    centrality = TRUE,
            #                    dispersion = TRUE,
            #                    range = TRUE,
            #                    distribution = FALSE,
            #                    levels_percentage = FALSE,
            #                    n_entries = 3,
            #                    missing_percentage = FALSE
            # #                    median = med,
            # #                    centrality = cent,
            # #                    dispersion = disp,
            # #                    range = ran,
            # #                    distribution = distr,
            # #                    levels_percentage = lev,
            # #                    n_characters = n_ch,
            # #                    missing_percentage = mis
            #                    )
            #
            # results1 <- myreport



            # results1 <- mydata %>%
            #     explore::describe(.) %>%
            #     dplyr::filter(na > 0)


            # for (fac in facs)
            #     data[[fac]] <- as.factor(data[[fac]])



            # catsummary function
            catsummary <- function(myvar) {




                leng <- length(mydata[[myvar]])

                miss <- sum(is.na(mydata[[myvar]]))

                valid <- leng - miss

                nlev <- nlevels(as.factor(mydata[[myvar]]))

                summar <- summary(as.factor(mydata[[myvar]])) %>%
                    as.table() %>%
                    tibble::as_tibble(.name_repair = "unique") %>%
                    dplyr::filter(.[[1]] != "NA's") %>%
                    dplyr::arrange(dplyr::desc(n))

                summar$validtotal <- valid

                description <- summar %>%
                    dplyr::mutate(
                        percent = n/validtotal
                    ) %>%
                    dplyr::mutate(
                        description = glue::glue(
                            "{...1}: n = {n}, {scales::percent(percent)}. "
                        )
                    ) %>%
                    dplyr::select(description) %>%
                    dplyr::pull(.)


                sentence1 <- paste0(
                    myvar, " has ", leng, " observations and ", nlev, " levels. "
                )

                sentence3 <- paste0("There are ", miss, " missing values.")

                sentence <- c(
                    sentence1,
                    unlist(description),
                    sentence3
                )

                return(paste0(sentence, collapse = ""))

            }



            results <- purrr::map(.x = myvars, .f = catsummary)

            results1 <- unlist(results)

            self$results$text$setContent(results1)

            }



            plot_mydata <- mydata %>%
                gtExtras::gt_plt_summary()

            print_plot_mydata <- print(plot_mydata)

            plot_mydata <- htmltools::HTML(print_plot_mydata[["children"]][[2]])

            self$results$text1$setContent(plot_mydata)

        }


        )
)


File: R\reportcat.h.R
--------------------------------------------------
Content of R\reportcat.h.R:

# This file is automatically generated, you probably don't want to edit this

reportcatOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "reportcatOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            vars = NULL, ...) {

            super$initialize(
                package="ClinicoPathDescriptives",
                name="reportcat",
                requiresData=TRUE,
                ...)

            private$..vars <- jmvcore::OptionVariables$new(
                "vars",
                vars,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))

            self$.addOption(private$..vars)
        }),
    active = list(
        vars = function() private$..vars$value),
    private = list(
        ..vars = NA)
)

reportcatResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "reportcatResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        text = function() private$.items[["text"]],
        text1 = function() private$.items[["text1"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Summary of Categorical Variables",
                refs=list(
                    "report",
                    "gtExtras",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do",
                clearWith=list(
                    "vars")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text",
                title=""))
            self$add(jmvcore::Html$new(
                options=options,
                name="text1",
                title="Categorical Data"))}))

reportcatBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "reportcatBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPathDescriptives",
                name = "reportcat",
                version = c(1,0,0),
                options = options,
                results = reportcatResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Summary of Categorical Variables
#'
#' Function for Generating Summaries for Categorical Variables.
#'
#' @examples
#' \donttest{
#' # example will be added
#'}
#' @param data the data as a data frame
#' @param vars string naming the variables from \code{data} that contains the
#'   values used for the report.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$text} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$text1} \tab \tab \tab \tab \tab a html \cr
#' }
#'
#' @export
reportcat <- function(
    data,
    vars) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("reportcat requires jmvcore to be installed (restart may be required)")

    if ( ! missing(vars)) vars <- jmvcore::resolveQuo(jmvcore::enquo(vars))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(vars), vars, NULL))

    for (v in vars) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- reportcatOptions$new(
        vars = vars)

    analysis <- reportcatClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\summarydata.b.R
--------------------------------------------------
Content of R\summarydata.b.R:
#' @title Summary of Continuous Variables
#' @return Text
#'
#' @importFrom R6 R6Class
#' @import jmvcore
#' @importFrom magrittr %>%
#' @importFrom gtExtras gt_plt_summary
#'

summarydataClass <- if (requireNamespace("jmvcore")) R6::R6Class("summarydataClass",
    inherit = summarydataBase, private = list(.run = function() {



        # # Error Message ----
        #
        # if (nrow(self$data) == 0) stop("Data contains no (complete) rows")
        #
        # if ( (is.null(self$options$vars) || is.null(self$options$facs)) && is.null(self$options$target) ) {
        #     # ToDo Message ----
        #     todo <- "
        #         <br>Welcome to ClinicoPath
        #                   <br><br>
        #                   This tool will help you form an Alluvial Plots.
        #                   "
        #     html <- self$results$todo
        #     html$setContent(todo)
        #
        # } else {
        #     todo <- ""
        #     html <- self$results$todo
        #     html$setContent(todo)
        #
        #
        #
        # }






        if (length(self$options$vars) == 0) {
            todo <- "
                <br>Welcome to ClinicoPath
                          <br><br>
                          This tool will help you to write descriptive statistics for numeric variables.
                          <br><br>
                          Please cite the packages and jamovi using references below.
                          "

            html <- self$results$todo
            html$setContent(todo)
            return()

        } else {
            todo <- ""
            html <- self$results$todo
            html$setContent(todo)

            if (nrow(self$data) == 0) stop("Data contains no (complete) rows")


            mydata <- self$data

            myvars <- jmvcore::constructFormula(terms = self$options$vars)

            myvars <- jmvcore::decomposeFormula(formula = myvars)

            myvars <- unlist(myvars)

            # ?ave

            # grvar <- jmvcore::constructFormula(terms = self$options$grvar)
            #
            # grvar <- jmvcore::decomposeFormula(formula = grvar)
            #
            # grvar <- unlist(grvar)
            #
            # results <- stats::ave(x = jmvcore::toNumeric(mydata[[myvars]]),
            #                       mydata[[grvar]],
            #                       FUN = function(x) mean(x, na.rm = TRUE)
            #                       )

            # mysummary function
            mysummary <- function(myvar) {

                mean_x <- round(mean(jmvcore::toNumeric(mydata[[myvar]]),
                  na.rm = TRUE), digits = 1)

                sd_x <- round(sd(x = jmvcore::toNumeric(mydata[[myvar]]),
                  na.rm = TRUE), digits = 1)

                median_x <- round(median(jmvcore::toNumeric(mydata[[myvar]]),
                  na.rm = TRUE), digits = 1)

                min_x <- round(min(jmvcore::toNumeric(mydata[[myvar]]), na.rm = TRUE),
                  digits = 1)

                max_x <- round(max(jmvcore::toNumeric(mydata[[myvar]]), na.rm = TRUE),
                  digits = 1)

                print(paste0("Mean of ", myvar, " is: ", mean_x, " \U00B1 ", sd_x,
                  ". (Median: ", median_x, " [Min: ", min_x, " - ", "Max: ",
                  max_x, "])", collapse = " "))
            }

            results <- purrr::map(.x = myvars, .f = mysummary)

            results <- unlist(results)

            self$results$text$setContent(results)





            plot_mydata <- mydata %>%
                gtExtras::gt_plt_summary()


            print_plot_mydata <- print(plot_mydata)

            plot_mydata <- htmltools::HTML(print_plot_mydata[["children"]][[2]])

            self$results$text1$setContent(plot_mydata)







        }


    }))


File: R\summarydata.h.R
--------------------------------------------------
Content of R\summarydata.h.R:

# This file is automatically generated, you probably don't want to edit this

summarydataOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "summarydataOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            vars = NULL, ...) {

            super$initialize(
                package="ClinicoPathDescriptives",
                name="summarydata",
                requiresData=TRUE,
                ...)

            private$..vars <- jmvcore::OptionVariables$new(
                "vars",
                vars,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))

            self$.addOption(private$..vars)
        }),
    active = list(
        vars = function() private$..vars$value),
    private = list(
        ..vars = NA)
)

summarydataResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "summarydataResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        text = function() private$.items[["text"]],
        text1 = function() private$.items[["text1"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Summary of Continuous Variables",
                refs=list(
                    "gtExtras",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text",
                title=""))
            self$add(jmvcore::Html$new(
                options=options,
                name="text1",
                title="Continuous Data Plots"))}))

summarydataBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "summarydataBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPathDescriptives",
                name = "summarydata",
                version = c(1,0,0),
                options = options,
                results = summarydataResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Summary of Continuous Variables
#'
#' Function for Generating Summaries for Continuous Variables.
#'
#' @examples
#' \donttest{
#' # example will be added
#'}
#' @param data The data as a data frame.
#' @param vars a string naming the variables from \code{data} that contains
#'   the continuous values used for the report
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$text} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$text1} \tab \tab \tab \tab \tab a html \cr
#' }
#'
#' @export
summarydata <- function(
    data,
    vars) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("summarydata requires jmvcore to be installed (restart may be required)")

    if ( ! missing(vars)) vars <- jmvcore::resolveQuo(jmvcore::enquo(vars))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(vars), vars, NULL))


    options <- summarydataOptions$new(
        vars = vars)

    analysis <- summarydataClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\tableone.b.R
--------------------------------------------------
Content of R\tableone.b.R:
#' @title Table One
#'
#' @return Table
#'
#' @importFrom R6 R6Class
#' @importFrom jmvcore toNumeric
#'


tableoneClass <- if (requireNamespace("jmvcore")) R6::R6Class("tableoneClass",
    inherit = tableoneBase, private = list(.run = function() {

        # Error Message ----

            if (nrow(self$data) == 0) stop("Data contains no (complete) rows")



        if (is.null(self$options$vars)) {

            # ToDo Message ----


            todo <- "
                <br>Welcome to ClinicoPath
                          <br><br>
                          This tool will help you form a Table One, which is almost always used in clinicopathological research manuscripts.
                          <br><br>
                          Select the 'Variables' you want to include in the table. Numeric, Ordinal, and Categorical variables are allowed.
                          Select the 'Table Style' for different package outputs.
                          <br><br>
                          Missing values are excluded by default. You may reinclude them.
                          Please note that excluded cases are removed from other variables as well.
                          <br><br>
                          Please cite the packages and jamovi using references below.
                          "

            html <- self$results$todo
            html$setContent(todo)

        } else {

            todo <- ""
        html <- self$results$todo
        html$setContent(todo)


        # Prepare Data ----

            varsName <- self$options$vars

            data <- jmvcore::select(self$data, c(varsName))


            # Exclude NA

            excl <- self$options$excl

            if (excl) {data <- jmvcore::naOmit(data)}


            # Select Style ----

            sty <- self$options$sty

            # tableone ----

            if (sty == "t1") {

            mytable <- tableone::CreateTableOne(data = data)

            self$results$tablestyle1$setContent(mytable)

                # gtsummary ----

            } else if (sty == "t2") {


                mytable <- gtsummary::tbl_summary(data = data)
                mytable <- gtsummary::as_kable_extra(mytable)

                self$results$tablestyle2$setContent(mytable)

            # arsenal ----

            } else if (sty == "t3") {



                formula <- jmvcore::constructFormula(terms = self$options$vars)
                formula <- paste('~', formula)
                formula <- as.formula(formula)
                mytable <- arsenal::tableby(formula = formula,
                                            data = data,
                                            total = TRUE,
                                            digits = 1,
                                            digits.count = 0,
                                            digits.pct = 1
                )

                mytable <- summary(mytable, text = "html")

                mytable <- kableExtra::kable(mytable, format = "html",
                                               digits = 1,
                                               escape = FALSE)

                self$results$tablestyle3$setContent(mytable)


            }  else if (sty == "t4") {


                # janitor ----

                tablelist <- list()

                for (i in 1:length(varsName)) {

                    var <- varsName[i]

                    table <- data %>%
                        janitor::tabyl(dat = ., var) %>%
                        janitor::adorn_totals("row") %>%
                        janitor::adorn_pct_formatting(dat = .)

                    tablelist[[var]] <- table

                }

                mytable <- tablelist

                self$results$tablestyle4$setContent(mytable)


            }


    }
    }
    ))


File: R\tableone.h.R
--------------------------------------------------
Content of R\tableone.h.R:

# This file is automatically generated, you probably don't want to edit this

tableoneOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "tableoneOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            vars = NULL,
            sty = "t1",
            excl = FALSE, ...) {

            super$initialize(
                package="ClinicoPathDescriptives",
                name="tableone",
                requiresData=TRUE,
                ...)

            private$..vars <- jmvcore::OptionVariables$new(
                "vars",
                vars)
            private$..sty <- jmvcore::OptionList$new(
                "sty",
                sty,
                options=list(
                    "t1",
                    "t2",
                    "t3",
                    "t4"),
                default="t1")
            private$..excl <- jmvcore::OptionBool$new(
                "excl",
                excl,
                default=FALSE)

            self$.addOption(private$..vars)
            self$.addOption(private$..sty)
            self$.addOption(private$..excl)
        }),
    active = list(
        vars = function() private$..vars$value,
        sty = function() private$..sty$value,
        excl = function() private$..excl$value),
    private = list(
        ..vars = NA,
        ..sty = NA,
        ..excl = NA)
)

tableoneResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "tableoneResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        tablestyle1 = function() private$.items[["tablestyle1"]],
        tablestyle2 = function() private$.items[["tablestyle2"]],
        tablestyle3 = function() private$.items[["tablestyle3"]],
        tablestyle4 = function() private$.items[["tablestyle4"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Table One",
                refs=list(
                    "ClinicoPathJamoviModule",
                    "whoisinthisstudy"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="tablestyle1",
                title="",
                clearWith=list(
                    "vars",
                    "excl"),
                visible="(sty:t1)",
                refs="tableone"))
            self$add(jmvcore::Html$new(
                options=options,
                name="tablestyle2",
                title="",
                clearWith=list(
                    "vars",
                    "excl"),
                visible="(sty:t2)",
                refs="gtsummary"))
            self$add(jmvcore::Html$new(
                options=options,
                name="tablestyle3",
                title="",
                clearWith=list(
                    "vars",
                    "excl"),
                visible="(sty:t3)",
                refs="arsenal"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="tablestyle4",
                title="",
                clearWith=list(
                    "vars",
                    "excl"),
                visible="(sty:t4)",
                refs="janitor"))}))

tableoneBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "tableoneBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPathDescriptives",
                name = "tableone",
                version = c(0,0,1),
                options = options,
                results = tableoneResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Table One
#'
#' Function for making Table One.
#'
#' @examples
#' \donttest{
#' data('histopathology')
#' dat <- as.data.frame(histopathology)
#' ClinicoPath::tableone(
#' data = dat,
#' vars = vars(Sex, PreinvasiveComponent, LVI, PNI, Grade, Age),
#' sty = "t3",
#' excl = TRUE)
#'}
#' @param data The data as a data frame.
#' @param vars a string naming the variables from \code{data} that contains
#'   the values used for the Table One.
#' @param sty a string naming the style of the table.
#' @param excl a boolean argument whether to exclude missing values. Default
#'   is false.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$tablestyle1} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$tablestyle2} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$tablestyle3} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$tablestyle4} \tab \tab \tab \tab \tab a preformatted \cr
#' }
#'
#' @export
tableone <- function(
    data,
    vars,
    sty = "t1",
    excl = FALSE) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("tableone requires jmvcore to be installed (restart may be required)")

    if ( ! missing(vars)) vars <- jmvcore::resolveQuo(jmvcore::enquo(vars))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(vars), vars, NULL))


    options <- tableoneOptions$new(
        vars = vars,
        sty = sty,
        excl = excl)

    analysis <- tableoneClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\tumor_response_examples.R
--------------------------------------------------
Content of R\tumor_response_examples.R:
#' Example Tumor Response Datasets
#'
#' Example datasets demonstrating different scenarios for tumor response analysis
#'
#' @format A list containing 4 data frames:
#' \describe{
#'   \item{raw_with_time}{Raw tumor measurements with time points (20 obs. of 3 variables)}
#'   \item{raw_no_time}{Raw tumor measurements without time (10 obs. of 2 variables)}
#'   \item{percent_with_time}{Pre-calculated response percentages with time (20 obs. of 3 variables)}
#'   \item{percent_no_time}{Pre-calculated response percentages without time (10 obs. of 2 variables)}
#' }
#' @details
#' Each dataset represents a different scenario:
#' \itemize{
#'   \item raw_with_time: Longitudinal raw measurements
#'   \item raw_no_time: Single timepoint raw measurements
#'   \item percent_with_time: Longitudinal percentage changes
#'   \item percent_no_time: Single timepoint percentage changes
#' }
#'
#' @examples
#' data(tumor_response_examples)
#' head(tumor_response_examples$raw_with_time)
#' head(tumor_response_examples$percent_no_time)
"tumor_response_examples"


File: R\utils.R
--------------------------------------------------
Content of R\utils.R:
#' Perform pairwise chi-square tests with proper handling of contingency tables
#' @param data Data frame containing the variables
#' @param group_var Name of the grouping variable
#' @param response_var Name of the response variable
#' @param adjust_method Method for p-value adjustment (default: "bonferroni")
#' @return List containing summary and detailed results
# Enhanced pairwise chi-square test function with improved formatting
perform_pairwise_chisq <- function(data, group_var, response_var, adjust_method = "bonferroni") {
    # Get unique groups (excluding NA)
    groups <- sort(unique(data[[group_var]]))
    groups <- groups[!is.na(groups)]
    n_groups <- length(groups)

    # Initialize results storage
    results <- list()
    pvalues <- c()
    comparisons <- c()
    chi_squares <- c()
    dfs <- c()

    # Perform pairwise comparisons
    for (i in 1:(n_groups-1)) {
        for (j in (i+1):n_groups) {
            # Subset data for current pair
            pair_data <- subset(data, data[[group_var]] %in% c(groups[i], groups[j]))

            # Create contingency table
            cont_table <- table(pair_data[[group_var]], pair_data[[response_var]])

            # Perform chi-square test
            test_result <- suppressWarnings(chisq.test(cont_table, correct = TRUE))

            # Store results
            comparison_name <- paste(groups[i], "vs", groups[j])
            chi_squares <- c(chi_squares, round(test_result$statistic, 3))
            pvalues <- c(pvalues, test_result$p.value)
            dfs <- c(dfs, test_result$parameter)
            comparisons <- c(comparisons, comparison_name)
        }
    }

    # Adjust p-values
    adjusted_pvalues <- p.adjust(pvalues, method = adjust_method)

    # Create formatted table
    formatted_results <- data.frame(
        Comparison = comparisons,
        ChiSquare = chi_squares,
        df = dfs,
        p_value = round(pvalues, 3),
        adjusted_p_value = round(adjusted_pvalues, 3),
        stringsAsFactors = FALSE
    )

    # Add significance symbols
    formatted_results$significance <- ifelse(
        formatted_results$adjusted_p_value < 0.001, "***",
        ifelse(formatted_results$adjusted_p_value < 0.01, "**",
        ifelse(formatted_results$adjusted_p_value < 0.05, "*", "ns"))
    )

    # Format as HTML table
    html_table <- kableExtra::kable(formatted_results,
        format = "html",
        caption = "Pairwise Chi-square Tests",
        col.names = c("Comparison", "Chi-Square", "df", "p-value", "Adjusted p-value", "Significance"),
        align = c("l", "r", "r", "r", "r", "c")
    ) %>%
    kableExtra::kable_styling(
        bootstrap_options = c("striped", "hover", "condensed"),
        full_width = FALSE,
        position = "left"
    ) %>%
    kableExtra::column_spec(2:5, width = "100px") %>%
    kableExtra::add_footnote(
        c("Significance codes: *** p<0.001, ** p<0.01, * p<0.05, ns p≥0.05",
          paste("P-values adjusted using", adjust_method, "method")),
        notation = "symbol"
    )

    return(list(
        table = html_table,
        raw_results = formatted_results
    ))
}

# Function to combine arsenal table with pairwise results
format_arsenal_output <- function(mytable, pairwise_results = NULL) {
    # Get arsenal table HTML
    main_table <- summary(mytable, text = "html")

    if (!is.null(pairwise_results)) {
        # Combine tables with proper spacing and styling
        html_output <- paste0(
            '<div class="arsenal-output">',
            main_table,
            '<br><div class="pairwise-tests">',
            pairwise_results$table,
            '</div></div>'
        )
    } else {
        html_output <- paste0(
            '<div class="arsenal-output">',
            main_table,
            '</div>'
        )
    }

    return(html_output)
}


File: R\vartree.b.R
--------------------------------------------------
Content of R\vartree.b.R:
#' @title Variable Tree
#'
#' @importFrom R6 R6Class
#' @import jmvcore

vartreeClass <- if (requireNamespace('jmvcore')) R6::R6Class(
    "vartreeClass",
    inherit = vartreeBase,
    private = list(

        # # init ----
        #
        # .init = function() {
        #     varslen <- length(self$options$vars)
        #
        #     self$results$text1$setSize(400, varslen * 600)
        #
        # }
        # ,




        .run = function() {


            if ( is.null(self$options$vars) ) {
                # ToDo Message ----
                todo <- "
                <br>Welcome to ClinicoPath Descriptives Module
                          <br><br>
                          This tool will help you form a Variable Tree.
                          "
                html <- self$results$todo
                html$setContent(todo)
                return()

            } else {
                todo <- ""
                html <- self$results$todo
                html$setContent(todo)

            }

            # Error Message ----

            if (nrow(self$data) == 0) stop("Data contains no (complete) rows")

            # Read Data ----

            mydata <- self$data

            # Read Arguments ----

            horizontal <- self$options$horizontal
            sline <- self$options$sline
            mytitle <- self$options$mytitle
            myvars <-  self$options$vars
            percvar <- self$options$percvar
            summaryvar <- self$options$summaryvar

            # Default Arguments ----

            # prunesmaller ----
            xprunesmaller <- NULL
            useprunesmaller <- self$options$useprunesmaller
            if (useprunesmaller) {
                xprunesmaller <- self$options$prunesmaller
            }


            xsplitspaces  <-  TRUE
            xprune <- list()
            xprunebelow <- list()
            xkeep <- list()
            xfollow <- list()
            xlabelnode <- list()
            xtlabelnode <- NULL
            xlabelvar <- NULL
            xvarminwidth <- NULL
            xvarminheight <- NULL
            xvarlabelloc <- NULL
            xfillcolor <- "white"
            xfillcolor <- NULL
            xfillnodes <- TRUE
            xNAfillcolor <- "white"
            xrootfillcolor <- "#EFF3FF"
            xpalette <- NULL
            xgradient <- TRUE
            xrevgradient <- FALSE
            xsinglecolor <- 2
            xcolorvarlabels <- TRUE
            xtitle <- ""
            xsameline <- FALSE
            xcheck.is.na <- FALSE

            xptable <- FALSE
            xshowroot <- TRUE
            xtext <- list()
            xttext <- list()
            xplain <- FALSE
            xsqueeze <- 1
            xshowvarinnode <- FALSE
            xshowvarnames <- TRUE
            xshowpct <- TRUE
            xshowlpct <- TRUE
            xshowcount <- TRUE
            xshowlegend <- FALSE
            xvarnamepointsize <- 18
            xHTMLtext <- FALSE
            xdigits <- 0
            xcdigits <- 1
            xsplitwidth <- 20
            xlsplitwidth <- 15
            # vsplitwidth in 5.0.0
            xgetscript <- FALSE
            xnodesep <- 0.5
            xranksep <- 0.5
            xmargin <- 0.2
            xhoriz <- TRUE
            xsummary <- ""
            xrunsummary <- NULL
            xretain <- NULL
            xgraphattr <- ""
            xnodeattr <- ""
            xedgeattr <- ""
            xcolor <- c("blue", "forestgreen", "red", "orange", "pink")
            xcolornodes <- FALSE
            xmincount <- 1
            xmaxcount <- NULL
            xshowempty <- FALSE
            xrounded <- TRUE
            xnodefunc <- NULL
            xnodeargs <- NULL
            xchoicechecklist <- TRUE
            xarrowhead <- "normal"
            xfolder <- NULL
            xpngknit <- TRUE
            xas.if.knit <- FALSE
            xmaxNodes <- 1000
            xparent <- 1
            xlast <- 1
            xroot <- TRUE


            # Exclude NA ----

            excl <- self$options$excl

            if (excl) {mydata <- jmvcore::naOmit(mydata)}

            # Prepare Data ----

            mydata <- jmvcore::select(df = mydata, columnNames = c(myvars, percvar, summaryvar))

            # Prepare Formula ----

            formula <- jmvcore::constructFormula(terms = self$options$vars)

            myvars1 <- jmvcore::decomposeFormula(formula = formula)

            myvars1 <- unlist(myvars1)

            myvars1 <- paste0(myvars1, collapse = " ")


                # myvars2 <- self$options$vars
                # myvars2 <- unlist(myvars2)
                #
                # myvars2 <- paste0(myvars2, collapse = " ")

            # Percentage Variable ----
            if ( !is.null(self$options$percvar) ) {
                percvar <- self$options$percvar
                xsummary <- paste0(percvar,"=", self$options$percvarLevel
                                   #, "\n%pct%"
                                   )

                # summary=c("Score \nScore: mean (SD) %meanx% (%SD%)","Pre \nPre: range %range%"))



            }


            # Continuous Variable for Summaries ----

            if ( !is.null(self$options$summaryvar) ) {
                summaryvar <- self$options$summaryvar

                summarylocation <- self$options$summarylocation

                if (summarylocation == "leafonly") {
                    summarylocation1 <- "%leafonly%"
                } else if (summarylocation == "allnodes") {
                    summarylocation1 <- "%allnodes%"
                }

                xsummary <- paste0(
                    summaryvar," \n\n",
                    summaryvar, "\n",
                    "mean=%mean%", "\n",
                    "SD=%SD%", "\n",
                    # "Range=%range%", "\n",
                    # "mv=%mv%",
                    summarylocation1, "\n"
                    )
            }



            # Prune Below ----

            if ( !is.null(self$options$prunebelow) ) {

                prunebelow <- self$options$prunebelow
                prunebelow <- jmvcore::composeTerm(prunebelow)

                pruneLevel1 <- self$options$pruneLevel1
                pruneLevel1 <- jmvcore::composeTerm(pruneLevel1)

                pruneLevel2 <- self$options$pruneLevel2
                pruneLevel2 <- jmvcore::composeTerm(pruneLevel2)

                xprunebelow <-  paste0("list(", prunebelow,"=c('", pruneLevel1, "','", pruneLevel2,"'))")

                }


            # Follow Below ----

            if ( !is.null(self$options$follow) ) {

                follow <- self$options$follow
                follow <- jmvcore::composeTerm(follow)

                followLevel1 <- self$options$followLevel1
                followLevel1 <- jmvcore::composeTerm(followLevel1)

                followLevel2 <- self$options$followLevel2
                followLevel2 <- jmvcore::composeTerm(followLevel2)

                xfollow <-  paste0("list(", follow,"=c('", followLevel1, "','", followLevel2,"'))")

            }


            # run vtree function ----

            results <- vtree::vtree(
                z = mydata,
                vars = myvars1,
                sameline = sline,
                title = mytitle,
                horiz = horizontal,
                showvarnames = self$options$varnames,
                showlegend = self$options$legend,
                showpct = self$options$pct,
                splitspaces = xsplitspaces,
                # prune = list(),
                prunebelow = eval(parse(text = xprunebelow)),
                # keep = list(),
                follow = eval(parse(text = xfollow)),
                prunesmaller = xprunesmaller,
                # labelnode = list(),
                # tlabelnode = NULL,
                # labelvar = NULL,
                # varminwidth = NULL,
                # varminheight = NULL,
                # varlabelloc = NULL,
                # fillcolor = "white",
                # fillcolor = NULL,
                # fillnodes = TRUE,
                # NAfillcolor = "white",
                # rootfillcolor = "#EFF3FF",
                # palette = NULL,
                # gradient = TRUE,
                # revgradient = FALSE,
                # singlecolor = 2,
                # colorvarlabels = TRUE,
                # title = "",
                # sameline = FALSE,
                # Venn = self$options$venntable,
                # check.is.na = FALSE,
                seq = self$options$sequence,
                pattern = self$options$pattern,
                ptable = self$options$ptable,
                # showroot = TRUE,
                # text = list(),
                # ttext = list(),
                # plain = FALSE,
                # squeeze = 1,
                # showvarinnode = FALSE,
                shownodelabels = self$options$nodelabel,
                # showvarnames = TRUE,
                # showpct = TRUE,
                # showlpct = TRUE,
                showcount = self$options$showcount,
                # showlegend = FALSE,
                varnamepointsize = 18,
                # HTMLtext = FALSE,
                # digits = 0,
                # cdigits = 1,
                # splitwidth = 20,
                # lsplitwidth = 15,
                # getscript = FALSE,
                # nodesep = 0.5,
                # ranksep = 0.5,
                # margin = 0.2,
                vp = self$options$vp,
                # horiz = TRUE,
                summary = xsummary,
                # runsummary = NULL,
                # retain = NULL,
                # imagewidth = self$options$width,
                # imageheight = self$options$height,
                # graphattr = "",
                # nodeattr = "",
                # edgeattr = "",
                # color = c("blue", "forestgreen", "red", "orange", "pink"),
                # colornodes = FALSE,
                # mincount = 1,
                # maxcount,
                # showempty = FALSE,
                # rounded = TRUE,
                # nodefunc = NULL,
                # nodeargs = NULL,
                # choicechecklist = TRUE,
                # arrowhead = "normal",
                # folder,
                # pngknit = TRUE,
                # as.if.knit = FALSE,
                # maxNodes = 1000,
                # parent = 1,
                # last = 1,
                root = xroot
            )


            # export as svg ----
            results1 <- DiagrammeRsvg::export_svg(gv = results)
            self$results$text1$setContent(print(results1))


            # ptable ----
            if (self$options$ptable) {
                self$results$text2$setContent(results)
            }


            # # venntable ----
            # if (self$options$ptable && self$options$venntable) {
            #     results2 <- print(vtree::VennTable(results), quote = FALSE)
            #     self$results$text3$setContent(results2)
            # }


        }

        )
)


File: R\vartree.h.R
--------------------------------------------------
Content of R\vartree.h.R:

# This file is automatically generated, you probably don't want to edit this

vartreeOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "vartreeOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            vars = NULL,
            percvar = NULL,
            percvarLevel = NULL,
            summaryvar = NULL,
            prunebelow = NULL,
            pruneLevel1 = NULL,
            pruneLevel2 = NULL,
            follow = NULL,
            followLevel1 = NULL,
            followLevel2 = NULL,
            excl = FALSE,
            vp = TRUE,
            horizontal = FALSE,
            sline = TRUE,
            varnames = FALSE,
            nodelabel = TRUE,
            pct = FALSE,
            showcount = TRUE,
            legend = FALSE,
            pattern = FALSE,
            sequence = FALSE,
            ptable = FALSE,
            mytitle = "",
            useprunesmaller = FALSE,
            prunesmaller = 5,
            summarylocation = "leafonly", ...) {

            super$initialize(
                package="ClinicoPathDescriptives",
                name="vartree",
                requiresData=TRUE,
                ...)

            private$..vars <- jmvcore::OptionVariables$new(
                "vars",
                vars,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..percvar <- jmvcore::OptionVariable$new(
                "percvar",
                percvar,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..percvarLevel <- jmvcore::OptionLevel$new(
                "percvarLevel",
                percvarLevel,
                variable="(percvar)")
            private$..summaryvar <- jmvcore::OptionVariable$new(
                "summaryvar",
                summaryvar,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..prunebelow <- jmvcore::OptionVariable$new(
                "prunebelow",
                prunebelow,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..pruneLevel1 <- jmvcore::OptionLevel$new(
                "pruneLevel1",
                pruneLevel1,
                variable="(prunebelow)",
                allowNone=TRUE)
            private$..pruneLevel2 <- jmvcore::OptionLevel$new(
                "pruneLevel2",
                pruneLevel2,
                variable="(prunebelow)",
                allowNone=TRUE)
            private$..follow <- jmvcore::OptionVariable$new(
                "follow",
                follow,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..followLevel1 <- jmvcore::OptionLevel$new(
                "followLevel1",
                followLevel1,
                variable="(follow)",
                allowNone=TRUE)
            private$..followLevel2 <- jmvcore::OptionLevel$new(
                "followLevel2",
                followLevel2,
                variable="(follow)",
                allowNone=TRUE)
            private$..excl <- jmvcore::OptionBool$new(
                "excl",
                excl,
                default=FALSE)
            private$..vp <- jmvcore::OptionBool$new(
                "vp",
                vp,
                default=TRUE)
            private$..horizontal <- jmvcore::OptionBool$new(
                "horizontal",
                horizontal,
                default=FALSE)
            private$..sline <- jmvcore::OptionBool$new(
                "sline",
                sline,
                default=TRUE)
            private$..varnames <- jmvcore::OptionBool$new(
                "varnames",
                varnames,
                default=FALSE)
            private$..nodelabel <- jmvcore::OptionBool$new(
                "nodelabel",
                nodelabel,
                default=TRUE)
            private$..pct <- jmvcore::OptionBool$new(
                "pct",
                pct,
                default=FALSE)
            private$..showcount <- jmvcore::OptionBool$new(
                "showcount",
                showcount,
                default=TRUE)
            private$..legend <- jmvcore::OptionBool$new(
                "legend",
                legend,
                default=FALSE)
            private$..pattern <- jmvcore::OptionBool$new(
                "pattern",
                pattern,
                default=FALSE)
            private$..sequence <- jmvcore::OptionBool$new(
                "sequence",
                sequence,
                default=FALSE)
            private$..ptable <- jmvcore::OptionBool$new(
                "ptable",
                ptable,
                default=FALSE)
            private$..mytitle <- jmvcore::OptionString$new(
                "mytitle",
                mytitle,
                default="")
            private$..useprunesmaller <- jmvcore::OptionBool$new(
                "useprunesmaller",
                useprunesmaller,
                default=FALSE)
            private$..prunesmaller <- jmvcore::OptionInteger$new(
                "prunesmaller",
                prunesmaller,
                default=5)
            private$..summarylocation <- jmvcore::OptionList$new(
                "summarylocation",
                summarylocation,
                options=list(
                    "allnodes",
                    "leafonly"),
                default="leafonly")

            self$.addOption(private$..vars)
            self$.addOption(private$..percvar)
            self$.addOption(private$..percvarLevel)
            self$.addOption(private$..summaryvar)
            self$.addOption(private$..prunebelow)
            self$.addOption(private$..pruneLevel1)
            self$.addOption(private$..pruneLevel2)
            self$.addOption(private$..follow)
            self$.addOption(private$..followLevel1)
            self$.addOption(private$..followLevel2)
            self$.addOption(private$..excl)
            self$.addOption(private$..vp)
            self$.addOption(private$..horizontal)
            self$.addOption(private$..sline)
            self$.addOption(private$..varnames)
            self$.addOption(private$..nodelabel)
            self$.addOption(private$..pct)
            self$.addOption(private$..showcount)
            self$.addOption(private$..legend)
            self$.addOption(private$..pattern)
            self$.addOption(private$..sequence)
            self$.addOption(private$..ptable)
            self$.addOption(private$..mytitle)
            self$.addOption(private$..useprunesmaller)
            self$.addOption(private$..prunesmaller)
            self$.addOption(private$..summarylocation)
        }),
    active = list(
        vars = function() private$..vars$value,
        percvar = function() private$..percvar$value,
        percvarLevel = function() private$..percvarLevel$value,
        summaryvar = function() private$..summaryvar$value,
        prunebelow = function() private$..prunebelow$value,
        pruneLevel1 = function() private$..pruneLevel1$value,
        pruneLevel2 = function() private$..pruneLevel2$value,
        follow = function() private$..follow$value,
        followLevel1 = function() private$..followLevel1$value,
        followLevel2 = function() private$..followLevel2$value,
        excl = function() private$..excl$value,
        vp = function() private$..vp$value,
        horizontal = function() private$..horizontal$value,
        sline = function() private$..sline$value,
        varnames = function() private$..varnames$value,
        nodelabel = function() private$..nodelabel$value,
        pct = function() private$..pct$value,
        showcount = function() private$..showcount$value,
        legend = function() private$..legend$value,
        pattern = function() private$..pattern$value,
        sequence = function() private$..sequence$value,
        ptable = function() private$..ptable$value,
        mytitle = function() private$..mytitle$value,
        useprunesmaller = function() private$..useprunesmaller$value,
        prunesmaller = function() private$..prunesmaller$value,
        summarylocation = function() private$..summarylocation$value),
    private = list(
        ..vars = NA,
        ..percvar = NA,
        ..percvarLevel = NA,
        ..summaryvar = NA,
        ..prunebelow = NA,
        ..pruneLevel1 = NA,
        ..pruneLevel2 = NA,
        ..follow = NA,
        ..followLevel1 = NA,
        ..followLevel2 = NA,
        ..excl = NA,
        ..vp = NA,
        ..horizontal = NA,
        ..sline = NA,
        ..varnames = NA,
        ..nodelabel = NA,
        ..pct = NA,
        ..showcount = NA,
        ..legend = NA,
        ..pattern = NA,
        ..sequence = NA,
        ..ptable = NA,
        ..mytitle = NA,
        ..useprunesmaller = NA,
        ..prunesmaller = NA,
        ..summarylocation = NA)
)

vartreeResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "vartreeResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        text1 = function() private$.items[["text1"]],
        text2 = function() private$.items[["text2"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Variable Tree",
                refs=list(
                    "vtree",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do"))
            self$add(jmvcore::Html$new(
                options=options,
                name="text1",
                title="Variable Tree"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text2",
                title="Pattern Table",
                visible="(ptable)"))}))

vartreeBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "vartreeBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPathDescriptives",
                name = "vartree",
                version = c(1,0,0),
                options = options,
                results = vartreeResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Variable Tree
#'
#' Function for Generating Tree Summaries of Variables.
#'
#' @examples
#' \donttest{
#' # example will be added
#'}
#' @param data The data as a data frame.
#' @param vars .
#' @param percvar .
#' @param percvarLevel .
#' @param summaryvar .
#' @param prunebelow .
#' @param pruneLevel1 .
#' @param pruneLevel2 .
#' @param follow .
#' @param followLevel1 .
#' @param followLevel2 .
#' @param excl .
#' @param vp .
#' @param horizontal .
#' @param sline .
#' @param varnames .
#' @param nodelabel .
#' @param pct .
#' @param showcount .
#' @param legend .
#' @param pattern .
#' @param sequence .
#' @param ptable .
#' @param mytitle .
#' @param useprunesmaller .
#' @param prunesmaller .
#' @param summarylocation .
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$text1} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$text2} \tab \tab \tab \tab \tab a preformatted \cr
#' }
#'
#' @export
vartree <- function(
    data,
    vars,
    percvar,
    percvarLevel,
    summaryvar,
    prunebelow,
    pruneLevel1,
    pruneLevel2,
    follow,
    followLevel1,
    followLevel2,
    excl = FALSE,
    vp = TRUE,
    horizontal = FALSE,
    sline = TRUE,
    varnames = FALSE,
    nodelabel = TRUE,
    pct = FALSE,
    showcount = TRUE,
    legend = FALSE,
    pattern = FALSE,
    sequence = FALSE,
    ptable = FALSE,
    mytitle = "",
    useprunesmaller = FALSE,
    prunesmaller = 5,
    summarylocation = "leafonly") {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("vartree requires jmvcore to be installed (restart may be required)")

    if ( ! missing(vars)) vars <- jmvcore::resolveQuo(jmvcore::enquo(vars))
    if ( ! missing(percvar)) percvar <- jmvcore::resolveQuo(jmvcore::enquo(percvar))
    if ( ! missing(summaryvar)) summaryvar <- jmvcore::resolveQuo(jmvcore::enquo(summaryvar))
    if ( ! missing(prunebelow)) prunebelow <- jmvcore::resolveQuo(jmvcore::enquo(prunebelow))
    if ( ! missing(follow)) follow <- jmvcore::resolveQuo(jmvcore::enquo(follow))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(vars), vars, NULL),
            `if`( ! missing(percvar), percvar, NULL),
            `if`( ! missing(summaryvar), summaryvar, NULL),
            `if`( ! missing(prunebelow), prunebelow, NULL),
            `if`( ! missing(follow), follow, NULL))

    for (v in vars) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])
    for (v in percvar) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])
    for (v in prunebelow) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])
    for (v in follow) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- vartreeOptions$new(
        vars = vars,
        percvar = percvar,
        percvarLevel = percvarLevel,
        summaryvar = summaryvar,
        prunebelow = prunebelow,
        pruneLevel1 = pruneLevel1,
        pruneLevel2 = pruneLevel2,
        follow = follow,
        followLevel1 = followLevel1,
        followLevel2 = followLevel2,
        excl = excl,
        vp = vp,
        horizontal = horizontal,
        sline = sline,
        varnames = varnames,
        nodelabel = nodelabel,
        pct = pct,
        showcount = showcount,
        legend = legend,
        pattern = pattern,
        sequence = sequence,
        ptable = ptable,
        mytitle = mytitle,
        useprunesmaller = useprunesmaller,
        prunesmaller = prunesmaller,
        summarylocation = summarylocation)

    analysis <- vartreeClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\venn.b.R
--------------------------------------------------
Content of R\venn.b.R:
#' @title Venn Diagram
#' @importFrom R6 R6Class
#' @import jmvcore
#' @importFrom dplyr inner_join
#'


vennClass <- if (requireNamespace('jmvcore'))
    R6::R6Class(
        "vennClass",
        inherit = vennBase,
        private = list(
            .run = function() {
                # Error Message ----


                if (is.null(self$options$var1) || is.null(self$options$var2)) {
                    # ToDo Message ----
                    todo <- "
                <br>Welcome to ClinicoPath
                <br><br>
                This tool will help you form Venn Diagrams.
                <hr><br>
                "

                    html <- self$results$todo
                    html$setContent(todo)

                } else {
                    todo <- ""
                    html <- self$results$todo
                    html$setContent(todo)



                    if (nrow(self$data) == 0)
                        stop("Data contains no (complete) rows")


                    # Read data ----

                    mydata <- self$data

                    var1 <- self$options$var1
                    var1true <- self$options$var1true

                    var2 <- self$options$var2
                    var2true <- self$options$var2true

                    var3 <- self$options$var3
                    var3true <- self$options$var3true

                    var4 <- self$options$var4
                    var4true <- self$options$var4true

                    # mydata <- jmvcore::select(df = mydata,
                    #                           columnNames = c(var1, var2, var3, var4))

                    mydata <- jmvcore::naOmit(mydata)


                    if (!is.null(self$options$var1)) {
                        mydata[[var1]] <-
                            ifelse(test = mydata[[var1]] == var1true, TRUE, FALSE)
                    }

                    if (!is.null(self$options$var2)) {
                        mydata[[var2]] <-
                            ifelse(test = mydata[[var2]] == var2true, TRUE, FALSE)
                    }

                    if (!is.null(self$options$var3)) {
                        mydata[[var3]] <-
                            ifelse(test = mydata[[var3]] == var3true, TRUE, FALSE)
                    }

                    if (!is.null(self$options$var4)) {
                        mydata[[var4]] <-
                            ifelse(test = mydata[[var4]] == var4true, TRUE, FALSE)
                    }

                    # myoutput1 <- list(
                    #     "mydata" = head(mydata),
                    #     "names" = names(mydata)
                    # )


                    # self$results$output1$setContent(myoutput1)


                    plotData <- list("mydata" = mydata,
                                     "names" = names(mydata)
                                     )

                    image <- self$results$plot
                    image$setState(plotData)



                    mydata2 <- mydata %>%
                        dplyr::mutate(dplyr::across(.cols = dplyr::everything(), ~as.integer(.)))


                    plotData2 <- list("mydata" = mydata2,
                                     "names" = names(mydata2)
                    )

                    image2 <- self$results$plot2
                    image2$setState(plotData2)


                }

            }

            ,

            .plot = function(image, ggtheme, theme, ...) {
                # the plot function ----


                #Errors ----

                if (is.null(self$options$var1) || is.null(self$options$var2))
                    return()

                if (nrow(self$data) == 0)
                    stop('Data contains no (complete) rows')


                # Prepare Data ----

                results <- image$state

                mydata2 <- results$mydata

                namescolumn2 <- results$names

                # Venn Diagram by ggplot2, with really easy-to-use API.
                # https://github.com/yanlinlin82/ggvenn

                plot <-
                    ggvenn::ggvenn(data = mydata2,
                                   columns = namescolumn2)


                plot <-
                    plot +
                    ggtheme +
                    ggplot2::theme(axis.line.x = ggplot2::element_blank(),
                                   axis.text.x = ggplot2::element_blank(),
                                   axis.ticks.x = ggplot2::element_blank(),
                                   axis.title.x = ggplot2::element_blank(),
                                   axis.line.y = ggplot2::element_blank(),
                                   axis.text.y = ggplot2::element_blank(),
                                   axis.ticks.y = ggplot2::element_blank(),
                                   axis.title.y = ggplot2::element_blank()
                                   )

                # Print Plot ----
                print(plot)
                TRUE
            }


            ,

            .plot2 = function(image, ggtheme, theme, ...) {
                # the plot2 function ----


                #Errors ----

                if (is.null(self$options$var1) || is.null(self$options$var2))
                    return()

                if (nrow(self$data) == 0)
                    stop('Data contains no (complete) rows')


                # Prepare Data ----

                results <- image$state

                mydata2 <- results$mydata

                # namescolumn2 <- results$names

                plot2 <- UpSetR::upset(mydata2, order.by = "freq")

                # Print plot2 ----
                print(plot2)
                TRUE
            }
        )
    )


File: R\venn.h.R
--------------------------------------------------
Content of R\venn.h.R:

# This file is automatically generated, you probably don't want to edit this

vennOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "vennOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            var1 = NULL,
            var1true = NULL,
            var2 = NULL,
            var2true = NULL,
            var3 = NULL,
            var3true = NULL,
            var4 = NULL,
            var4true = NULL, ...) {

            super$initialize(
                package="ClinicoPathDescriptives",
                name="venn",
                requiresData=TRUE,
                ...)

            private$..var1 <- jmvcore::OptionVariable$new(
                "var1",
                var1,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..var1true <- jmvcore::OptionLevel$new(
                "var1true",
                var1true,
                variable="(var1)")
            private$..var2 <- jmvcore::OptionVariable$new(
                "var2",
                var2,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..var2true <- jmvcore::OptionLevel$new(
                "var2true",
                var2true,
                variable="(var2)")
            private$..var3 <- jmvcore::OptionVariable$new(
                "var3",
                var3,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..var3true <- jmvcore::OptionLevel$new(
                "var3true",
                var3true,
                variable="(var3)")
            private$..var4 <- jmvcore::OptionVariable$new(
                "var4",
                var4,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..var4true <- jmvcore::OptionLevel$new(
                "var4true",
                var4true,
                variable="(var4)")

            self$.addOption(private$..var1)
            self$.addOption(private$..var1true)
            self$.addOption(private$..var2)
            self$.addOption(private$..var2true)
            self$.addOption(private$..var3)
            self$.addOption(private$..var3true)
            self$.addOption(private$..var4)
            self$.addOption(private$..var4true)
        }),
    active = list(
        var1 = function() private$..var1$value,
        var1true = function() private$..var1true$value,
        var2 = function() private$..var2$value,
        var2true = function() private$..var2true$value,
        var3 = function() private$..var3$value,
        var3true = function() private$..var3true$value,
        var4 = function() private$..var4$value,
        var4true = function() private$..var4true$value),
    private = list(
        ..var1 = NA,
        ..var1true = NA,
        ..var2 = NA,
        ..var2true = NA,
        ..var3 = NA,
        ..var3true = NA,
        ..var4 = NA,
        ..var4true = NA)
)

vennResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "vennResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        plot = function() private$.items[["plot"]],
        plot2 = function() private$.items[["plot2"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Venn Diagram",
                refs=list(
                    "ClinicoPathJamoviModule"),
                clearWith=list(
                    "var1",
                    "var2",
                    "var3",
                    "var4",
                    "var1true",
                    "var2true",
                    "var3true",
                    "var4true"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do"))
            self$add(jmvcore::Image$new(
                options=options,
                title="Venn Diagram",
                name="plot",
                width=700,
                height=450,
                renderFun=".plot",
                requiresData=TRUE,
                refs=list(
                    "venn")))
            self$add(jmvcore::Image$new(
                options=options,
                title="Upset Diagram",
                name="plot2",
                width=700,
                height=450,
                renderFun=".plot2",
                requiresData=TRUE,
                refs=list(
                    "upset")))}))

vennBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "vennBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPathDescriptives",
                name = "venn",
                version = c(1,0,0),
                options = options,
                results = vennResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Venn Diagram
#'
#' 
#' @param data The data as a data frame.
#' @param var1 a string naming the variable from \code{data} that contains the
#'   the first variable used for the report
#' @param var1true a string naming the level from \code{var1} that contains
#'   the the true level
#' @param var2 a string naming the variable from \code{data} that contains the
#'   the second variable used for the report
#' @param var2true a string naming the level from \code{var2} that contains
#'   the the true level
#' @param var3 a string naming the variable from \code{data} that contains the
#'   the third variable used for the report
#' @param var3true a string naming the level from \code{var3} that contains
#'   the the true level
#' @param var4 a string naming the variable from \code{data} that contains the
#'   the fourth variable used for the report
#' @param var4true a string naming the level from \code{var4} that contains
#'   the the true level
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$plot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plot2} \tab \tab \tab \tab \tab an image \cr
#' }
#'
#' @export
venn <- function(
    data,
    var1,
    var1true,
    var2,
    var2true,
    var3,
    var3true,
    var4,
    var4true) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("venn requires jmvcore to be installed (restart may be required)")

    if ( ! missing(var1)) var1 <- jmvcore::resolveQuo(jmvcore::enquo(var1))
    if ( ! missing(var2)) var2 <- jmvcore::resolveQuo(jmvcore::enquo(var2))
    if ( ! missing(var3)) var3 <- jmvcore::resolveQuo(jmvcore::enquo(var3))
    if ( ! missing(var4)) var4 <- jmvcore::resolveQuo(jmvcore::enquo(var4))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(var1), var1, NULL),
            `if`( ! missing(var2), var2, NULL),
            `if`( ! missing(var3), var3, NULL),
            `if`( ! missing(var4), var4, NULL))

    for (v in var1) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])
    for (v in var2) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])
    for (v in var3) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])
    for (v in var4) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- vennOptions$new(
        var1 = var1,
        var1true = var1true,
        var2 = var2,
        var2true = var2true,
        var3 = var3,
        var3true = var3true,
        var4 = var4,
        var4true = var4true)

    analysis <- vennClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\waterfall.b.R
--------------------------------------------------
Content of R\waterfall.b.R:
#' @title Treatment Response Waterfall Plot
#' @importFrom R6 R6Class
#' @import jmvcore
#' @description Creates waterfall and spider plots to visualize tumor response data following RECIST criteria
#' @param data Data frame containing response data
#' @param patientID Column name for patient identifiers
#' @param response Column name for response values (raw measurements or percent change)
#' @param timeVar Optional column name for time points
#' @param inputType Whether values are raw measurements or pre-calculated percentages
#' @return A list containing plot object and summary statistics
#' @examples
#' data <- data.frame(
#'   PatientID = paste0("PT", 1:10),
#'   Response = c(-100, -45, -30, -20, -10, 0, 10, 20, 30, 40),
#'   Time = c(1,2,3,4,5,6,7,8,9,10)
#' )
#' waterfall(data, "PatientID", "Response", "Time")



waterfallClass <- if (requireNamespace('jmvcore')) R6::R6Class(
    "waterfallClass",
    inherit = waterfallBase,
    private = list(



      # getDataCondition ----
      .getDataCondition = function(timeVar, inputType) {
        if (!is.null(timeVar)) {
          if (inputType == "raw") {
            return("time_raw")
          } else {
            return("time_percentage")
          }
        } else {
          if (inputType == "raw") {
            return("notime_raw")
          } else {
            return("notime_percentage")
          }
        }
      },


      # # validate input data format ----
      # .validateData = function(df, patientID, inputType, responseVar, timeVar = NULL) {
      #   ## Check for required columns ----
      #   if (!responseVar %in% names(df)) {
      #     stop("Response variable not found in data")
      #   }
      #
      #   ## Convert response to numeric ----
      #   df[[responseVar]] <- jmvcore::toNumeric(df[[responseVar]])
      #
      #   ## Validate measurements based on input type ----
      #   if (inputType == "raw") {
      #     # Check for non-positive baselines
      #     baseline_vals <- df %>%
      #       dplyr::group_by(.data[[patientID]]) %>%
      #       dplyr::summarise(baseline = dplyr::first(measurement)) %>%
      #       dplyr::pull(baseline)
      #
      #     if (any(baseline_vals <= 0, na.rm=TRUE)) {
      #       stop("Cannot calculate percentage change from zero or negative baseline values")
      #     }
      #   } else {
      #     # For percentage data, check range
      #     if (any(abs(df[[responseVar]]) > 100, na.rm=TRUE)) {
      #       warning("Some percentage values exceed ±100%")
      #     }
      #   }
      #
      #   ## Validate time variable if present ----
      #   if (!is.null(timeVar)) {
      #     if (!timeVar %in% names(df)) {
      #       stop("Time variable not found in data")
      #     }
      #     df[[timeVar]] <- jmvcore::toNumeric(df[[timeVar]])
      #   }
      #
      #   return(df)
      # },


      # .validateData = function(df, patientID, inputType, responseVar, timeVar = NULL) {
      #   # Check if required variables exist in dataframe
      #   required_vars <- c(patientID, responseVar)
      #   missing_vars <- required_vars[!required_vars %in% names(df)]
      #   if (length(missing_vars) > 0) {
      #     stop(sprintf("Required variables not found in data: %s",
      #                  paste(missing_vars, collapse = ", ")))
      #   }
      #
      #   # Convert response variable to numeric
      #   df[[responseVar]] <- jmvcore::toNumeric(df[[responseVar]])
      #
      #   # Validate based on input type
      #   if (inputType == "raw") {
      #     # For raw measurements, check baseline values
      #     baseline_data <- df %>%
      #       dplyr::group_by(.data[[patientID]]) %>%
      #       dplyr::summarise(
      #         baseline = dplyr::first(.data[[responseVar]]),  # Use responseVar instead of measurement
      #         .groups = "drop"
      #       )
      #
      #     # Check for invalid baselines
      #     if (any(baseline_data$baseline <= 0, na.rm = TRUE)) {
      #       problem_patients <- baseline_data %>%
      #         dplyr::filter(baseline <= 0) %>%
      #         dplyr::pull(!!patientID)
      #
      #       stop(sprintf(
      #         "Cannot calculate percentage change for patients with zero or negative baseline values: %s",
      #         paste(problem_patients, collapse = ", ")
      #       ))
      #     }
      #   } else {
      #     # For percentage data, validate range
      #     invalid_values <- df %>%
      #       dplyr::filter(abs(.data[[responseVar]]) > 100) %>%
      #       dplyr::select(!!patientID, !!responseVar)
      #
      #     if (nrow(invalid_values) > 0) {
      #       warning(sprintf(
      #         "Some percentage values exceed ±100%%:\n%s",
      #         paste(capture.output(print(invalid_values)), collapse = "\n")
      #       ))
      #     }
      #   }
      #
      #   # Validate time variable if present
      #   if (!is.null(timeVar)) {
      #     if (!timeVar %in% names(df)) {
      #       stop(sprintf("Time variable '%s' not found in data", timeVar))
      #     }
      #
      #     # Convert time to numeric
      #     df[[timeVar]] <- jmvcore::toNumeric(df[[timeVar]])
      #
      #     # Check for negative time values
      #     if (any(df[[timeVar]] < 0, na.rm = TRUE)) {
      #       warning("Negative time values found - consider using non-negative values for time")
      #     }
      #
      #     # Check time variable is properly ordered
      #     time_check <- df %>%
      #       dplyr::group_by(.data[[patientID]]) %>%
      #       dplyr::arrange(.data[[timeVar]]) %>%
      #       dplyr::summarise(
      #         has_duplicates = any(duplicated(.data[[timeVar]])),
      #         is_ordered = all(diff(.data[[timeVar]]) >= 0),
      #         .groups = "drop"
      #       )
      #
      #     if (any(time_check$has_duplicates)) {
      #       warning("Duplicate time points found for some patients")
      #     }
      #
      #     if (!all(time_check$is_ordered)) {
      #       warning("Time points are not in ascending order for all patients")
      #     }
      #   }
      #
      #   return(df)
      # }
      #



#
#       .validateData = function(df, patientID, inputType, responseVar, timeVar = NULL) {
#         # Check if raw measurements require time variable
#         if (inputType == "raw" && is.null(timeVar)) {
#           stop(paste(
#             "Time variable is required for raw measurements.",
#             "This is necessary to:",
#             "1. Identify baseline measurements (time = 0)",
#             "2. Calculate correct percentage changes",
#             "3. Track response progression",
#             "\nPlease add a time variable to analyze raw measurements.",
#             sep = "\n"
#           ))
#         }
#
#         # Check if required variables exist in dataframe
#         required_vars <- c(patientID, responseVar)
#         if (inputType == "raw") {
#           required_vars <- c(required_vars, timeVar)  # Make timeVar mandatory for raw measurements
#         }
#
#         missing_vars <- required_vars[!required_vars %in% names(df)]
#         if (length(missing_vars) > 0) {
#           stop(sprintf("Required variables not found in data: %s",
#                        paste(missing_vars, collapse = ", ")))
#         }
#
#         # Convert response variable to numeric
#         df[[responseVar]] <- jmvcore::toNumeric(df[[responseVar]])
#
#         # For raw measurements, perform additional time-based validations
#         if (inputType == "raw") {
#           # Convert time to numeric
#           df[[timeVar]] <- jmvcore::toNumeric(df[[timeVar]])
#
#           # Check for baseline measurements (time = 0) for each patient
#           baseline_check <- df %>%
#             dplyr::group_by(.data[[patientID]]) %>%
#             dplyr::summarise(
#               has_baseline = any(.data[[timeVar]] == 0),
#               .groups = "drop"
#             )
#
#           patients_without_baseline <- baseline_check %>%
#             dplyr::filter(!has_baseline) %>%
#             dplyr::pull(!!patientID)
#
#           if (length(patients_without_baseline) > 0) {
#             stop(sprintf(
#               "Missing baseline measurements (time = 0) for patients: %s\nBaseline measurements are required for calculating percentage changes.",
#               paste(patients_without_baseline, collapse = ", ")
#             ))
#           }
#
#           # Validate measurement values at baseline
#           baseline_values <- df %>%
#             dplyr::filter(.data[[timeVar]] == 0) %>%
#             dplyr::select(!!patientID, !!responseVar)
#
#           invalid_baselines <- baseline_values %>%
#             dplyr::filter(.data[[responseVar]] <= 0)
#
#           if (nrow(invalid_baselines) > 0) {
#             stop(sprintf(
#               "Invalid baseline measurements (zero or negative) found for patients: %s\nBaseline measurements must be positive to calculate percentage changes.",
#               paste(invalid_baselines[[patientID]], collapse = ", ")
#             ))
#           }
#         } else {
#           # For percentage data, validate range
#           invalid_values <- df %>%
#             dplyr::filter(abs(.data[[responseVar]]) > 100) %>%
#             dplyr::select(!!patientID, !!responseVar)
#
#           if (nrow(invalid_values) > 0) {
#             warning(sprintf(
#               "Some percentage values exceed ±100%%:\n%s",
#               paste(capture.output(print(invalid_values)), collapse = "\n")
#             ))
#           }
#         }
#
#         return(df)
#       }
#






.validateData = function(df, patientID, inputType, responseVar, timeVar = NULL) {
  validation_messages <- character()  # Store all validation messages
  data_valid <- TRUE  # Track if data meets requirements

  # For raw measurements, check time variable requirement
  if (inputType == "raw") {
    if (is.null(timeVar)) {
      validation_messages <- c(validation_messages, paste(
        "\nTime Variable Required for Raw Measurements:",
        "\nWhen using raw tumor measurements, a time variable is essential to:",
        "\n• Identify baseline measurements (time = 0)",
        "\n• Calculate accurate percentage changes",
        "\n• Track response progression over time",
        "\n\nRecommended Data Format:",
        "\nPatientID  Time  Measurement",
        "\nPT1        0     50          (baseline)",
        "\nPT1        2     25          (2 months)",
        "\nPT1        4     10          (4 months)"
      ))
      data_valid <- FALSE
    } else {
      # Check time variable exists in data
      if (!timeVar %in% names(df)) {
        validation_messages <- c(validation_messages, sprintf(
          "\nTime variable '%s' not found in the data. Please ensure the time variable is correctly specified.",
          timeVar
        ))
        data_valid <- FALSE
      } else {
        # Convert and check time values
        df[[timeVar]] <- jmvcore::toNumeric(df[[timeVar]])

        # Check for baseline measurements
        baseline_check <- df %>%
          dplyr::group_by(.data[[patientID]]) %>%
          dplyr::summarise(
            has_baseline = any(.data[[timeVar]] == 0),
            .groups = "drop"
          )

        patients_without_baseline <- baseline_check %>%
          dplyr::filter(!has_baseline) %>%
          dplyr::pull(!!patientID)

        if (length(patients_without_baseline) > 0) {
          validation_messages <- c(validation_messages, paste(
            "\nMissing Baseline Measurements:",
            sprintf("\nThe following patients lack baseline (time = 0) measurements: %s",
                    paste(patients_without_baseline, collapse = ", ")),
            "\n\nWhy this matters:",
            "\n• Baseline measurements are the reference point for calculating changes",
            "\n• Without baseline values, percentage changes cannot be calculated accurately",
            "\n• Please ensure each patient has a measurement at time = 0"
          ))
          data_valid <- FALSE
        }
      }
    }
  }

  # For percentage data, check for out-of-range values
  if (inputType == "percentage") {
    df[[responseVar]] <- jmvcore::toNumeric(df[[responseVar]])
    invalid_values <- df %>%
      dplyr::filter(abs(.data[[responseVar]]) > 100) %>%
      dplyr::select(!!patientID, !!responseVar)

    if (nrow(invalid_values) > 0) {
      validation_messages <- c(validation_messages, paste(
        "\nUnusual Percentage Values Detected:",
        "\nSome response values exceed the typical ±100% range.",
        "\nThis might indicate:",
        "\n• Data entry errors",
        "\n• Incorrect calculation of percentage changes",
        "\n• Special cases requiring review",
        "\n\nAffected measurements:",
        paste(capture.output(print(invalid_values)), collapse = "\n")
      ))
    }
  }

  # Set attributes to communicate validation results
  attr(df, "validation_messages") <- validation_messages
  attr(df, "data_valid") <- data_valid

  return(df)
}










      ,
      # process data into required format ----

      # .processData = function(df, patientID, inputType, responseVar, timeVar = NULL) {
      #   if (inputType == "raw") {
      #     ## Calculate percentage changes from raw measurements
      #     df <- df %>%
      #       dplyr::group_by(.data[[patientID]]) %>%
      #       dplyr::arrange(.data[[patientID]], .data[[timeVar]]) %>%
      #       dplyr::mutate(
      #         baseline = dplyr::first(measurement),
      #         response = ((measurement - baseline) / baseline) * 100
      #       ) %>%
      #       dplyr::ungroup()
      #   } else {
      #     ## Data already in percentage format
      #     df$response <- df[[responseVar]]
      #   }
      #
      #   ## Calculate RECIST categories
      #   df$category <- factor(
      #     cut(df$response,
      #         breaks = c(-Inf, -100, -30, 20, Inf),
      #         labels = c("CR", "PR", "SD", "PD"),
      #         right = TRUE),
      #     levels = c("CR", "PR", "SD", "PD", "NA")
      #   )
      #
      #   ## Create two datasets for two plots
      #   df_waterfall <- df %>%
      #     dplyr::group_by(.data[[patientID]]) %>%
      #     dplyr::filter(abs(response) == max(abs(response))) %>%
      #     dplyr::ungroup()
      #
      #   df_spider <- df
      #
      #   return(list(
      #     waterfall = df_waterfall,
      #     spider = df_spider
      #   ))
      # },


      .processData = function(df, patientID, inputType, responseVar, timeVar = NULL) {
        # Validate input parameters first
        if (is.null(patientID) || is.null(responseVar)) {
          stop("Patient ID and response variables are required")
        }

        # For raw measurements, calculate percentage change from baseline
        if (inputType == "raw") {
          processed_df <- df %>%
            dplyr::group_by(!!rlang::sym(patientID)) %>%
            dplyr::arrange(!!rlang::sym(patientID))

          # Add time variable if present
          if (!is.null(timeVar)) {
            processed_df <- processed_df %>%
              dplyr::arrange(!!rlang::sym(timeVar))
          }

          processed_df <- processed_df %>%
            dplyr::mutate(
              baseline = dplyr::first(!!rlang::sym(responseVar)),
              response = ((!!rlang::sym(responseVar) - baseline) / baseline) * 100
            ) %>%
            dplyr::ungroup()
        } else {
          # Data is already in percentage format
          processed_df <- df %>%
            dplyr::mutate(
              response = !!rlang::sym(responseVar)
            )
        }

        # Calculate RECIST categories
        df_waterfall <- processed_df %>%
          dplyr::group_by(!!rlang::sym(patientID)) %>%
          dplyr::filter(abs(response) == max(abs(response), na.rm = TRUE)) %>%
          dplyr::ungroup() %>%
          dplyr::mutate(
            category = factor(
              cut(response,
                  breaks = c(-Inf, -100, -30, 20, Inf),
                  labels = c("CR", "PR", "SD", "PD"),
                  right = TRUE),
              levels = c("CR", "PR", "SD", "PD", "NA")
            )
          )

        # Prepare spider plot data
        df_spider <- processed_df

        # Add informative attributes about the processing
        attr(df_waterfall, "input_type") <- inputType
        attr(df_spider, "input_type") <- inputType

        if (!is.null(timeVar)) {
          attr(df_spider, "time_variable") <- timeVar
        }

        return(list(
          waterfall = df_waterfall,
          spider = df_spider
        ))
      }

      ,
      # calculate clinical metrics ----
      .calculateMetrics = function(df) {
        ## Calculate response rates ----
        cats <- c("CR", "PR", "SD", "PD")
        summary_table <- data.frame(
          category = cats,
          n = sapply(cats, function(x) sum(df$category == x, na.rm = TRUE)),
          stringsAsFactors = FALSE
        )
        summary_table$percent <- summary_table$n / sum(summary_table$n) * 100

        ## Calculate ORR and DCR ----
        ORR <- round(sum(summary_table$n[summary_table$category %in% c("CR", "PR")]) /
                       sum(summary_table$n) * 100, 1)

        DCR <- round(sum(summary_table$n[summary_table$category %in% c("CR", "PR", "SD")]) /
                       sum(summary_table$n) * 100, 1)

        return(list(
          summary = summary_table,
          ORR = ORR,
          DCR = DCR
        ))
      },


      # Main run function ----
      .run = function() {

        ## Messages ----

        inputType <- self$options$inputType
        timeVar <- NULL
        hasTime <- !is.null(self$options$timeVar)

        if (hasTime) {
         timeVar <- self$options$timeVar
          }

        condition <- private$.getDataCondition(timeVar, inputType)

        ### Generate appropriate guidance message ----
        guideMsg <- switch(condition,
                                     "time_raw" = "
        <br><b>Current Setup:</b>
        <br>- Time variable detected - Spider plot enabled
        <br>- Using raw measurements - Will calculate percentage changes
        <br>- Baseline measurements will be taken from Time = 0",

                                     "time_percentage" = "
        <br><b>Current Setup:</b>
        <br>- Time variable detected - Spider plot enabled
        <br>- Using pre-calculated percentages
        <br>- Values at Time = 0 should be 0 (baseline)",

                                     "notime_raw" = "
        <br><b>Current Setup:</b>
        <br>- No time variable - Only waterfall plot available
        <br>- Using raw measurements - Will calculate percentage changes
        <br>- First measurement for each patient will be used as baseline",

                                     "notime_percentage" = "
        <br><b>Current Setup:</b>
        <br>- No time variable - Only waterfall plot available
        <br>- Using pre-calculated percentages
        <br>- Values should already represent change from baseline"
                  )

                  if(hasTime) {
                    spiderMsg <-  "
        <br><b>Spider Plot:</b> Available - Select Show Spider Plot in options"
                  } else {
                    spiderMsg <- "<br><b>Spider Plot:</b> Not available - Add time variable to enable"
                  }


        ### Update todo text to include condition-specific guidance ----
                  todo <- paste0(
                    "<br>Welcome to ClinicoPath Treatment Response Analysis",
                    "<br><br>",
                    "<b>Current Input Type:</b> ",
                    if(inputType == "raw") {
                      "Raw Measurements - Values will be converted to percentage change from baseline"
                    } else {
                      "Percentage Changes - Values will be used as-is"
                    },
                    guideMsg,
                    spiderMsg)



        ### Generate initial guidance message based on setup ----

        if (self$options$inputType == "raw") {
          todo <- paste0(todo,
                         "<br><hr><br>",
                         "Using raw measurements - will calculate percentage changes")
        } else {
          todo <- paste0(todo,
                         "<br><hr><br>",
                         "Using pre-calculated percentage changes")
        }


        ### Add more context to guidance message ----
        if (!is.null(self$options$timeVar)) {
          todo <- paste0(todo, "\nTime variable detected - Spider plot enabled")
        }


        todo <- paste0(
                    todo,
                    "<br>Welcome to ClinicoPath Treatment Response Analysis",
                    "<br><br>",
                    "<b>Current Input Type:</b> ",
                    if(inputType == "raw") {
                      "Raw Measurements - Values will be converted to percentage change from baseline"
                    } else {
                      "Percentage Changes - Values will be used as-is"
                    },
                    "
        <br><br>
        This tool creates two types of visualizations for tumor response data:
        <br><br>
        <b>1. Waterfall Plot</b>
        <br>- Shows best response for each patient
        <br>- Requires one measurement per patient (for single timepoint data)
        <br>- Shows percentage change from baseline
        <br><br>
        <b>2. Spider Plot</b>
        <br>- Shows response trajectories over time
        <br>- Requires multiple measurements per patient (one for each timepoint)
        <br>- Shows change over time
        <br><br>
        <b>Data Input Options:</b>
        <br>1. <b>Percentage Changes:</b>
        <br>- Values already calculated as percent change from baseline
        <br>- Negative values = decrease (improvement)
        <br>- Example: -30 means 30% decrease from baseline
        <br><br>
        2. <b>Raw Measurements:</b>
        <br>- Actual tumor measurements (e.g., mm, cm, sum of diameters)
        <br>- Tool will automatically calculate percent change from baseline
        <br>- Baseline is assumed to be first measurement (Time = 0)
        <br><br>
        <b>Required Variables:</b>
        <br>- <b>Patient ID:</b> Unique identifier for each patient
        <br>- <b>Response Value:</b> Either percentage change or raw measurements
        <br>- <b>Time Variable:</b> Required only for Spider Plot (e.g., months from baseline)
        <br><br>
        <b>RECIST Response Categories:</b>
        <br>- Complete Response (CR): -100% (complete disappearance)
        <br>- Partial Response (PR): ≥30% decrease
        <br>- Stable Disease (SD): Between -30% and +20% change
        <br>- Progressive Disease (PD): ≥20% increase
        <br><br>
        <b>Data Format Examples:</b>
        <pre>
        1. Using Percentage Changes:        2. Using Raw Measurements:
        PatientID Time Response            PatientID Time Measurement
        PT1      0     0                  PT1      0    50
        PT1      2    -45                 PT1      2    27.5
        PT1      4    -80                 PT1      4    10
        PT2      0     0                  PT2      0    40
        PT2      2    -20                 PT2      2    32
        </pre>
        <hr>
        "
                    )




                         "<br>
                        <b>TODO</b>
                        <br>
                        Add Statistical Annotations:
        Response Duration:


        Enhanced Clinical Categories:


        Add Reference Lines:


        Interactive Features:


        Add Data Quality Checks:


                        Add Best Overall Response Analysis:




                        - Longitudinal analysis support<br>

                        - RECISTEvaluation:<br>
          - Target lesion measurements<br>
          - Response categorization<br>
          - Spider plots for tumor size changes<br>
        <br>
        - TumorGrowthKinetics:<br>
          - Growth rate calculations<br>
          - Doubling time estimation<br>
          - Growth curves<br>
        <br>
        <br>
        - PrognosticModeling:<br>
          - Risk score calculation<br>
          - Nomogram generation<br>
          - Calibration plots<br>
          - Decision curve analysis<br>
        <br>
                        <hr><br>
                        "






        ### Update todo text ----
        self$results$todo$setContent(todo)
        # html <- self$results$todo
        # html$setContent(todo)

        ## Validate inputs ----
        if (is.null(self$options$patientID) || is.null(self$options$responseVar)) {
          return()
        }

        if (nrow(self$data) == 0) {
          stop('Data contains no complete rows')
        }







        if (is.null(self$options$patientID) || is.null(self$options$responseVar)) {
          # Show initial guidance message
          todo <- paste(
            "Welcome to the Treatment Response Analysis Tool",
            "\n\nThis tool helps you visualize and analyze tumor response data.",
            "\n\nTo get started, please provide:",
            "\n• Patient ID variable",
            "\n• Response measurements",
            if (self$options$inputType == "raw") {
              "\n• Time variable (required for raw measurements)"
            } else {
              ""
            }
          )
          self$results$todo$setContent(todo)
          return()
        }

        if (nrow(self$data) == 0) {
          self$results$todo$setContent("No data available for analysis. Please provide data.")
          return()
        }

        # Validate data
        validated_data <- private$.validateData(
          self$data,
          self$options$patientID,
          self$options$inputType,
          self$options$responseVar,
          self$options$timeVar
        )

        # Check for validation messages
        validation_messages <- attr(validated_data, "validation_messages")
        if (length(validation_messages) > 0) {
          # Display validation messages in an informative format
          message_text <- paste(
            "Data Validation Results:",
            "\n======================",
            paste(validation_messages, collapse = "\n"),
            "\n\nPlease address these items to ensure accurate analysis.",
            sep = ""
          )

          self$results$todo2$setContent(validation_messages)

          # # Display using grid
          # grid::grid.newpage()
          # vp <- grid::viewport(width = 0.9, height = 0.9)
          # grid::pushViewport(vp)
          # grid::grid.text(
          #   message_text,
          #   x = 0.05,
          #   y = 0.95,
          #   just = c("left", "top"),
          #   gp = grid::gpar(
          #     fontsize = 11,
          #     lineheight = 1.3
          #   )
          # )
          # grid::popViewport()
          return()
        }

        # Continue with analysis if data is valid
        if (attr(validated_data, "data_valid")) {
          # Process data and create visualizations
          processed_data <- private$.processData(
            validated_data,
            self$options$patientID,
            self$options$inputType,
            self$options$responseVar,
            self$options$timeVar
          )

        }









        ## Process data ----
        ### .validateData ----
        # df <- private$.validateData(
        #   self$data,
        #   self$options$patientID,
        #   self$options$inputType,
        #   self$options$responseVar,
        #   self$options$timeVar
        # )

        ### .processData ----
        # processed_data <- private$.processData(
        #   df,
        #   self$options$patientID,
        #   self$options$inputType,
        #   self$options$responseVar,
        #   self$options$timeVar
        # )




      #             # Process data ----
      #             # df <- self$data
      #             # responseVar <- self$options$responseVar
      #             # df$response <- jmvcore::toNumeric(df[[responseVar]])
      #
      #             # Calculate response categories including NA ----
      #             # df$category <- factor(
      #             #     cut(df$response,
      #             #         breaks = c(-Inf, -100, -30, 20, Inf),
      #             #         labels = c("CR", "PR", "SD", "PD"),
      #             #         right = TRUE),
      #             #     levels = c("CR", "PR", "SD", "PD", "NA")
      #             # )
      #
      #             # Create summary table with proper categories ----
      #             # cats <- c("CR", "PR", "SD", "PD")
      #             # summary_table <- data.frame(
      #             #     category = cats,
      #             #     n = sapply(cats, function(x) sum(df$category == x, na.rm = TRUE)),
      #             #     stringsAsFactors = FALSE
      #             # )
      #             # summary_table$percent <- round(summary_table$n / sum(!is.na(df$response)) * 100, 2)
      #
      #                 df <- self$data
      #                 responseVar <- self$options$responseVar
      #                 patientVar <- self$options$patientID
      #
      #                 timeVar <- NULL
      #                 if (!is.null(self$options$timeVar)) {
      #                   timeVar <- self$options$timeVar
      #                 }
      #
      #                 inputType <- self$options$inputType
      #
      #
      #                 # Convert measurements to numeric
      #                 df$measurement <- jmvcore::toNumeric(df[[responseVar]])
      #
      #
      #
      #
      #                 # Check data patterns
      #                 looks_like_percentage <- all(df$measurement[df[[timeVar]] == 0] == 0, na.rm=TRUE) &&
      #                   all(abs(df$measurement) <= 100, na.rm=TRUE)
      #
      #                 # If raw is selected but data looks like percentage
      #                 if (inputType == "raw" && looks_like_percentage) {
      #                   warning("Data appears to be in percentage format but 'Raw Measurements' is selected")
      #                   self$results$todo$setContent(paste0(
      #                     todo,
      #                     "<br><hr><br>",
      #                     "<b>⚠️ NOTE:</b> Your data appears to be already in percentage format. Consider changing 'Input Type' to 'Percentage Changes' in the options."
      #                   ))
      #                   return()
      # "
      # Your data appears to be already in percentage format (baselines are 0 and values are between -100 and 100).
      # Please either:
      # 1. Change 'Input Type' to 'Percentage Changes' in the options, or
      # 2. Provide raw measurements if available
      #
      # Expected format for raw measurements:
      # PatientID  Time  Measurement
      # PT1        0     50          (baseline measurement)
      # PT1        2     25          (actual measurements)
      # PT1        4     10
      #
      # Current format (appears to be percentages):
      # PatientID  Time  Response
      # PT1        0     0           (0% change at baseline)
      # PT1        2     -50         (-50% change)
      # PT1        4     -80         (-80% change)
      #         '"
      #                 }
      #
      #                 # If percentage is selected but data looks like raw
      #                 if (inputType == "percentage" && !looks_like_percentage) {
      #                   warning("Data appears to be raw measurements but 'Percentage Changes' is selected")
      #                   self$results$todo$setContent(paste0(
      #                     todo,
      #                     "<br><hr><br>",
      #                     "<b>⚠️ NOTE:</b> Your data appears to be raw measurements. Consider changing 'Input Type' to 'Raw Measurements' in the options."
      #                   ))
      #                   return()
      #
      # "Your data appears to be raw measurements (non-zero baselines or values outside -100 to 100 range).
      # Please either:
      # 1. Change 'Input Type' to 'Raw Measurements' in the options, or
      # 2. Pre-calculate percentage changes if preferred
      #
      # Expected format for percentages:
      # PatientID  Time  Response
      # PT1        0     0           (0% change at baseline)
      # PT1        2     -50         (-50% change)
      # PT1        4     -80         (-80% change)
      #
      # Current format (appears to be raw):
      # PatientID  Time  Measurement
      # PT1        0     50          (baseline measurement)
      # PT1        2     25          (actual measurements)
      # PT1        4     10
      # "
      #                 }
      #
      #                 # Process data based on validated input type
      #                 if (inputType == "raw") {
      #                   df <- df %>%
      #                     dplyr::group_by(.data[[patientVar]]) %>%
      #                     dplyr::arrange(.data[[patientVar]], .data[[timeVar]]) %>%
      #                     dplyr::mutate(
      #                       baseline = dplyr::first(measurement),
      #                       response = dplyr::if_else(
      #                         baseline == 0,
      #                         NA_real_,
      #                         ((measurement - baseline) / baseline) * 100
      #                       )
      #                     ) %>%
      #                     dplyr::ungroup()
      #                 } else {
      #                   df$response <- df$measurement
      #                 }
      #
      #
      #
      #
      #
      #                 # Auto-detect input type if not specified
      #                 # if (inputType == "auto") {
      #                 #   # Check characteristics of the data
      #                 #   has_zero_baseline <- df %>%
      #                 #     dplyr::group_by(.data[[patientVar]]) %>%
      #                 #     dplyr::summarise(
      #                 #       first_value = first(measurement),
      #                 #       .groups = "drop"
      #                 #     ) %>%
      #                 #     dplyr::pull(first_value) %>%
      #                 #     {all(. == 0)}
      #                 #
      #                 #   has_large_changes <- any(abs(df$measurement) > 100, na.rm = TRUE)
      #                 #
      #                 #   # If all baselines are 0 and no values >100, likely percentage
      #                 #   inputType <- if(has_zero_baseline && !has_large_changes) {
      #                 #     "percentage"
      #                 #   } else {
      #                 #     "raw"
      #                 #   }
      #                 # }
      #
      #                 # Calculate percentage change from baseline if raw measurements
      #                 # df <- df %>%
      #                 #   dplyr::group_by(.data[[patientVar]]) %>%
      #                 #   dplyr::arrange(.data[[patientVar]], .data[[timeVar]]) %>%
      #                 #   dplyr::mutate(
      #                 #     baseline = first(measurement),
      #                 #     response = ((measurement - baseline) / baseline) * 100
      #                 #   ) %>%
      #                 #   dplyr::ungroup()
      #
      #
      #
      #
      #                 # Calculate response based on input type
      #                 # if (inputType == "raw") {
      #                 #   df <- df %>%
      #                 #     dplyr::group_by(.data[[patientVar]]) %>%
      #                 #     dplyr::arrange(.data[[patientVar]], .data[[timeVar]]) %>%
      #                 #     dplyr::mutate(
      #                 #       baseline = first(measurement),
      #                 #       response = case_when(
      #                 #         baseline == 0 ~ NA_real_,  # Handle zero baseline
      #                 #         TRUE ~ ((measurement - baseline) / baseline) * 100
      #                 #       )
      #                 #     ) %>%
      #                 #     dplyr::ungroup()
      #                 # } else {
      #                 #   # Data is already in percentage change
      #                 #   df$response <- df$measurement
      #                 # }
      #
      #                 # Add warning for potential issues
      #                 if (any(is.na(df$response))) {
      #                   warning("Some responses could not be calculated (possibly due to zero baselines)")
      #                 }
      #
      #                 if (inputType == "raw" && any(df$baseline == 0, na.rm = TRUE)) {
      #                   warning("Zero baselines detected - percentage change cannot be calculated for these cases")
      #                 }
      #
      #
      #
      #
      #
      #
      #                 # Create two datasets:
      #                 # 1. For waterfall plot - get best response per patient
      #                 # df_waterfall <- df %>%
      #                 #   dplyr::group_by(.data[[patientVar]]) %>%
      #                 #   dplyr::filter(abs(.data[[responseVar]]) == max(abs(.data[[responseVar]]))) %>%
      #                 #   dplyr::ungroup()
      #
      #                 df_waterfall <- df %>%
      #                   dplyr::group_by(.data[[patientVar]]) %>%
      #                   dplyr::filter(abs(response) == max(abs(response))) %>%
      #                   dplyr::ungroup()
      #
      #
      #                 # 2. For spider plot - keep all timepoints
      #                 df_spider <- df
      #
      #                 # Continue with waterfall plot data processing
      #                 df_waterfall$response <- jmvcore::toNumeric(df_waterfall[[responseVar]])
      #
      #                 # Calculate response categories as before but using df_waterfall
      #                 df_waterfall$category <- factor(
      #                   cut(df_waterfall$response,
      #                       breaks = c(-Inf, -100, -30, 20, Inf),
      #                       labels = c("CR", "PR", "SD", "PD"),
      #                       right = TRUE),
      #                   levels = c("CR", "PR", "SD", "PD", "NA")
      #                 )
      #
      #                 # Create summary table using df_waterfall
      #                 cats <- c("CR", "PR", "SD", "PD")
      #                 summary_table <- data.frame(
      #                   category = cats,
      #                   n = sapply(cats, function(x)
      #                     sum(df_waterfall$category == x, na.rm = TRUE)),
      #                   stringsAsFactors = FALSE
      #                 )
      #                 summary_table$percent <- round(summary_table$n /
      #                                                  sum(!is.na(df_waterfall$response)) * 100, 2)
      #
      #
      #
      #
      #             # Add results to summary table ----
      #             for(i in seq_len(nrow(summary_table))) {
      #                 self$results$summary$addRow(rowKey=i, values=list(
      #                     category = summary_table$category[i],
      #                     n = summary_table$n[i],
      #                     percent = summary_table$percent[i]
      #                 ))
      #             }
      #
      #             # Calculate clinical metrics ----
      #             ORR <- round(
      #                 (summary_table$n[summary_table$category %in% c("CR", "PR")] |> sum()) /
      #                     (summary_table$n |> sum()) * 100,
      #                 1
      #             )
      #
      #             DCR <- round(
      #                 (summary_table$n[summary_table$category %in% c("CR", "PR", "SD")] |> sum()) /
      #                     (summary_table$n |> sum()) * 100,
      #                 1
      #             )
      #
      #             # Add results to clinical metrics table ----
      #             self$results$clinicalMetrics$addRow(rowKey=1, values=list(
      #                 metric = "Objective Response Rate (CR+PR)",
      #                 value = paste0(ORR, "%")
      #             ))
      #
      #             self$results$clinicalMetrics$addRow(rowKey=2, values=list(
      #                 metric = "Disease Control Rate (CR+PR+SD)",
      #                 value = paste0(DCR, "%")
      #             ))
      #
      #
      #
      #
      #
      #             # Calculate key statistics ----
      #             # stats <- list(
      #             #     mean = mean(df$response, na.rm=TRUE),
      #             #     sd = sd(df$response, na.rm=TRUE),
      #             #     median = median(df$response, na.rm=TRUE),
      #             #     q1 = quantile(df$response, 0.25, na.rm=TRUE),
      #             #     q3 = quantile(df$response, 0.75, na.rm=TRUE)
      #             # )
      #
      #             # Add stats table ----
      #             # self$results$stats$addRow(rowKey=1, values=list(
      #             #     statistic = "Mean (SD)",
      #             #     value = sprintf("%.1f (%.1f)", stats$mean, stats$sd)
      #             # ))
      #             # self$results$stats$addRow(rowKey=2, values=list(
      #             #     statistic = "Median [IQR]",
      #             #     value = sprintf("%.1f [%.1f, %.1f]", stats$median, stats$q1, stats$q3)
      #             # ))
      #
      #
      #
      #             # Add to summary statistics ----
      #             # best_response <- data.frame(
      #             #     metric = c(
      #             #         "Best Overall Response Rate",
      #             #         "Duration of Response (median)",
      #             #         "Time to Response (median)"
      #             #     ),
      #             #     value = c(
      #             #         sprintf("%.1f%%", ORR),
      #             #         sprintf("%.1f months", median_duration),
      #             #         sprintf("%.1f months", median_time_to_response)
      #             #     )
      #             # )
      #
      #             # Modify category calculation to include clinical significance ----
      #             # df$clinicalSignificance <- case_when(
      #             #     df$response <= -100 ~ "Complete Response",
      #             #     df$response <= -30 ~ "Partial Response",
      #             #     df$response >= 20 ~ "Progressive Disease",
      #             #     df$response >= 0 ~ "Stable Disease (Growth)",
      #             #     df$response < 0 ~ "Stable Disease (Shrinkage)",
      #             #     TRUE ~ "Not Evaluable"
      #             # )
      #
      #
      #
      #
      #
      #
      #             # Add response category to data ----
      #             # if (self$options$addResponseCategory) {
      #             #     self$results$responseCategory$setRowNums(rownames(df))
      #             #     self$results$responseCategory$setValues(as.character(df$category))
      #             # }
      #
      #
      #             # checkDataQuality ----
      #             # checkDataQuality <- function(df) {
      #             #     issues <- list()
      #             #
      #             #     # Check for outliers
      #             #     q1 <- quantile(df$response, 0.25, na.rm=TRUE)
      #             #     q3 <- quantile(df$response, 0.75, na.rm=TRUE)
      #             #     iqr <- q3 - q1
      #             #     outliers <- df$response < (q1 - 1.5*iqr) | df$response > (q3 + 1.5*iqr)
      #             #
      #             #     if (any(outliers, na.rm=TRUE)) {
      #             #         issues$outliers <- which(outliers)
      #             #     }
      #             #
      #             #     # Check for missing values
      #             #     if (any(is.na(df$response))) {
      #             #         issues$missing <- which(is.na(df$response))
      #             #     }
      #             #
      #             #     return(issues)
      #             # }
      #




        ## Calculate metrics ----
        metrics <- private$.calculateMetrics(processed_data$waterfall)

        ## Update results tables ----
        for(i in seq_len(nrow(metrics$summary))) {
          self$results$summary$addRow(rowKey=i, values=list(
            category = metrics$summary$category[i],
            n = metrics$summary$n[i],
            percent = metrics$summary$percent[i]/100
          ))
        }

        self$results$clinicalMetrics$addRow(rowKey=1, values=list(
          metric = "Objective Response Rate (CR+PR)",
          value = paste0(metrics$ORR, "%")
        ))

        self$results$clinicalMetrics$addRow(rowKey=2, values=list(
          metric = "Disease Control Rate (CR+PR+SD)",
          value = paste0(metrics$DCR, "%")
        ))




                    # mydataview ----

                    self$results$mydataview$setContent(
                        list(
                            "data" = head(df),
                            "patientID" = self$options$patientID,
                            "response" = self$options$responseVar,
                            "sortBy" = self$options$sortBy,
                            "showThresholds" = self$options$showThresholds,
                            "labelOutliers" = self$options$labelOutliers,
                            "colorScheme" = self$options$colorScheme,
                            # "summary" = summary_table,
                            # "ORR" = ORR,
                            # "DCR" = DCR,
                            "barWidth" = self$options$barWidth,
                            "barAlpha" = self$options$barAlpha,
                            "showMedian" = self$options$showMedian,
                            "showCI" = self$options$showCI,
                            "minResponseForLabel" = self$options$minResponseForLabel,


                            "data" = processed_data,
                            options = list(
                              "patientID" = self$options$patientID,
                              "response" = self$options$responseVar,
                              "timeVar" = self$options$timeVar,
                              "sortBy" = self$options$sortBy,
                              "showThresholds" = self$options$showThresholds,
                              "labelOutliers" = self$options$labelOutliers,
                              "colorScheme" = self$options$colorScheme,
                              "barWidth" = self$options$barWidth,
                              "barAlpha" = self$options$barAlpha,
                              "showMedian" = self$options$showMedian,
                              "showCI" = self$options$showCI,
                              "minResponseForLabel" = self$options$minResponseForLabel
                            ),
                            "metrics" = metrics
                        )
                    )


                    # Save data for plots
                    # plotData <- list(
                    #   "data_waterfall" = df_waterfall,
                    #   "data_spider" = df_spider,
                    #   "patientID" = self$options$patientID,
                    #   "response" = self$options$responseVar,
                    #   "timeVar" = self$options$timeVar,
                    #   "sortBy" = self$options$sortBy,
                    #   "showThresholds" = self$options$showThresholds,
                    #   "labelOutliers" = self$options$labelOutliers,
                    #   "colorScheme" = self$options$colorScheme,
                    #       "barWidth" = self$options$barWidth,
                    #       "barAlpha" = self$options$barAlpha,
                    #       "showMedian" = self$options$showMedian,
                    #       "showCI" = self$options$showCI,
                    #       "minResponseForLabel" = self$options$minResponseForLabel
                    # )














        ## Prepare plot data ----
        plotData <- list(
          "data" = processed_data,
          options = list(
            "patientID" = self$options$patientID,
            "response" = self$options$responseVar,
            "timeVar" = self$options$timeVar,
            "sortBy" = self$options$sortBy,
            "showThresholds" = self$options$showThresholds,
            "labelOutliers" = self$options$labelOutliers,
            "colorScheme" = self$options$colorScheme,
            "barWidth" = self$options$barWidth,
            "barAlpha" = self$options$barAlpha,
            "showMedian" = self$options$showMedian,
            "showCI" = self$options$showCI,
            "minResponseForLabel" = self$options$minResponseForLabel
          ),
          "metrics" = metrics
        )

        ### Update plots ----

        #### Waterfall plot ----
        if (self$options$showWaterfallPlot) {
          imageWaterfall <- self$results$waterfallplot
          imageWaterfall$setState(plotData)
        }


        #### Spider plot ----
        if (self$options$showSpiderPlot && !is.null(self$options$timeVar)) {
          plotData$timeVar <- self$options$timeVar
          imagespider <- self$results$spiderplot
          imagespider$setState(plotData)
        }
      }






      #         # waterfall plot
      #         .waterfallplot = function(imageWaterfallPlot, ggtheme, theme, ...) {
      #
      #           if (!self$options$showWaterfallPlot) return()
      #
      #
      #             # get data ----
      #             plotData <- image$state
      #
      #             # df <- plotData$data
      #
      #             df <- plotData$data_waterfall  # Use waterfall format data
      #
      #
      #
      #             # Sort data ----
      #             if (plotData$sortBy == "response") {
      #                 df <- df[order(df$response, na.last = TRUE),]
      #             } else {
      #                 df <- df[order(df[[plotData$patientID]], na.last = TRUE),]
      #             }
      #
      #
      #             # Get color scheme from state ----
      #             colorScheme <- plotData$colorScheme
      #
      #
      #             # Ensure category is a factor with correct levels
      #             df$category <- factor(df$category,
      #                                   levels = c("CR", "PR", "SD", "PD", "NA"))
      #
      #             # Define color schemes
      #             recistColors <- c(
      #                 "CR" = "#0000FF",  # Blue
      #                 "PR" = "#4169E1",  # Royal Blue
      #                 "SD" = "#FFA500",  # Orange
      #                 "PD" = "#FF0000",  # Red
      #                 "NA" = "#808080"   # Gray
      #
      #                 # "CR" = "#0066CC",  # Strong blue
      #                 # "PR" = "#3399FF",  # Lighter blue
      #                 # "SD" = "#FFA500",  # Orange
      #                 # "PD" = "#CC0000",  # Bright red
      #                 # "NA" = "#CCCCCC"   # Light gray
      #
      #             )
      #
      #             simpleColors <- c(
      #                 "CR" = "#00AA00",  # Green
      #                 "PR" = "#00AA00",  # Green
      #                 "SD" = "#808080",  # Gray
      #                 "PD" = "#FF0000",  # Red
      #                 "NA" = "#808080"   # Gray
      #
      #                 # "CR" = "#00CC00",  # Bright green
      #                 # "PR" = "#00CC00",  # Same green for PR
      #                 # "SD" = "#888888",  # Medium gray
      #                 # "PD" = "#CC0000",  # Bright red
      #                 # "NA" = "#CCCCCC"   # Light gray
      #
      #             )
      #
      #             # Select color scheme based on option ----
      #             colors <- if (plotData$colorScheme == "simple") simpleColors else recistColors
      #
      #             # Create base plot ----
      #             p <- ggplot2::ggplot(df,
      #                                  ggplot2::aes(x = factor(seq_len(nrow(df))),
      #                                               y = response)) +
      #                 ggplot2::geom_bar(
      #                     stat = "identity",
      #                     ggplot2::aes(fill = category),  # Now category is a proper factor
      #                     # width = 0.7,
      #                     na.rm = FALSE,
      #                     width = plotData$barWidth,
      #                     alpha = plotData$barAlpha
      #                 ) +
      #                 ggplot2::scale_fill_manual(
      #                     name = "RECIST Response",
      #                     values = colors,
      #                     na.value = "#808080",
      #                     drop = FALSE
      #                 ) +
      #                 ggplot2::labs(
      #                     x = "Patients",
      #                     y = "Change in Tumor Size (%)"
      #                 )
      #
      #
      #             # Add RECIST thresholds if requested ----
      #
      #             if (plotData$showThresholds) {
      #                 p <- p +
      #                     ggplot2::geom_hline(
      #                         yintercept = 20,
      #                         linetype = "dashed",
      #                         color = "#FF0000",
      #                         alpha = 0.5
      #                     ) +
      #                     ggplot2::geom_hline(
      #                         yintercept = -30,
      #                         linetype = "dashed",
      #                         color = "#4169E1",
      #                         alpha = 0.5
      #                     ) +
      #
      #                     ggplot2::scale_y_continuous(
      #                         # Show only key values: min/max rounded to nearest 50, plus threshold lines
      #                         breaks = function(x) {
      #                             c(
      #                                 floor(min(x[1], na.rm = TRUE) / 50) * 50,  # Min rounded to 50
      #                                 -30,  # PR threshold
      #                                 0,    # Zero line
      #                                 20,   # PD threshold
      #                                 ceiling(max(x[2], na.rm = TRUE) / 50) * 50  # Max rounded to 50
      #                             )
      #                         }
      #                     )
      #
      #
      #                     # ggplot2::scale_y_continuous(
      #                     #     breaks = function(x) c(seq(floor(x[1]/10)*10,
      #                     #                                ceiling(x[2]/10)*10,
      #                     #                                by=10), -30, 20)
      #                     # )
      #             }
      #
      #
      #
      #
      #
      #
      #
      #             # Add labels for large changes if requested ----
      #
      #             if (plotData$labelOutliers) {
      #                 # Create labels vector safely
      #                 labels <- ifelse(!is.na(df$response) & abs(df$response) > 50,
      #                                  sprintf("%.1f%%", df$response),
      #                                  "")
      #
      #                 # Only add text if we have labels
      #                 if (any(labels != "")) {
      #                     p <- p +
      #                         ggplot2::geom_text(
      #                             data = df[labels != "",],  # Only plot points with labels
      #                             mapping = ggplot2::aes(
      #                                 x = factor(which(labels != "")),
      #                                 y = response
      #                             ),
      #                             label = labels[labels != ""],
      #                             vjust = ifelse(df$response[labels != ""] >= 0, -0.5, 1.5),
      #                             size = 3
      #                         )
      #                 }
      #             }
      #
      #
      #
      #             # Add watermark for median response if requested ----
      #
      #             if (plotData$showMedian) {
      #
      #
      #             p <- p +
      #                 ggplot2::geom_hline(
      #                     yintercept = median(df$response, na.rm=TRUE),
      #                     linetype = "dotted",
      #                     color = "darkgray"
      #                 ) +
      #                 ggplot2::annotate(
      #                     "text",
      #                     x = nrow(df),
      #                     y = median(df$response, na.rm=TRUE),
      #                     label = sprintf("Median: %.1f%%", median(df$response, na.rm=TRUE)),
      #                     hjust = 1,
      #                     vjust = -0.5,
      #                     size = 3
      #                 )
      #
      #
      #             }
      #
      #
      #
      #
      #             # Add confidence intervals if requested ----
      #             if (plotData$showCI) {
      #
      #             # Add confidence intervals if sample size sufficient
      #             if (nrow(df) >= 10) {
      #                 ci <- t.test(df$response)$conf.int
      #                 p <- p +
      #                     ggplot2::annotate(
      #                         "text",
      #                         x = 1,
      #                         y = max(df$response, na.rm=TRUE),
      #                         label = sprintf("95%% CI: [%.1f%%, %.1f%%]", ci[1], ci[2]),
      #                         hjust = 0,
      #                         vjust = -0.5,
      #                         size = 3
      #                     )
      #             }
      #
      #             }
      #
      #
      #
      #             # Add minResponseForLabel if requested ----
      #             # if (plotData$minResponseForLabel) {
      #             #
      #             # p <- p +
      #             #     ggplot2::geom_text(
      #             #         data = df,
      #             #         ggplot2::aes(
      #             #             text = sprintf(
      #             #                 "ID: %s\nResponse: %.1f%%\nCategory: %s",
      #             #                 df[[plotData$patientID]],
      #             #                 response,
      #             #                 category
      #             #             )
      #             #         ),
      #             #         na.rm = TRUE,
      #             #         size = 0
      #             #     )
      #             #
      #             #
      #             # }
      #
      #
      #
      #             # Add reference lines if requested ----
      #             # if (self$options$showReferenceLines) {
      #             #     p <- p +
      #             #         # Add reference line for mean
      #             #         ggplot2::geom_hline(
      #             #             yintercept = mean(df$response, na.rm=TRUE),
      #             #             linetype = "dotted",
      #             #             color = "darkgray",
      #             #             alpha = 0.5
      #             #         ) +
      #             #         # Add confidence interval band
      #             #         ggplot2::geom_ribbon(
      #             #             aes(ymin = mean - sd,
      #             #                 ymax = mean + sd),
      #             #             alpha = 0.1,
      #             #             fill = "gray"
      #             #         )
      #             # }
      #
      #
      #
      #
      #
      #             # Add jamovi theme if selected ----
      #
      #             if (colorScheme == "jamovi") {
      #                 p <- p +
      #                     ggtheme
      #             }
      #
      #
      #             # Add theme and formatting ----
      #
      #             p <- p +
      #                 # ggtheme +
      #                 ggplot2::theme(
      #                     axis.text.x = ggplot2::element_blank(),
      #                     axis.ticks.x = ggplot2::element_blank(),
      #                     panel.grid.major.x = ggplot2::element_blank(),
      #                     panel.grid.minor.x = ggplot2::element_blank(),
      #                     legend.position = "right"
      #                 )
      #
      #
      #
      #
      #             # Add plotly support for interactive features ----
      #             # if (self$options$interactive) {
      #             #     p <- plotly::ggplotly(p, tooltip = c("y", "fill")) %>%
      #             #         plotly::layout(
      #             #             hoverlabel = list(
      #             #                 bgcolor = "white",
      #             #                 font = list(family = "Arial", size = 12)
      #             #             )
      #             #         )
      #             # }
      #
      #
      #             # Return plot ----
      #
      #             print(p)
      #             TRUE
      #         }
      #

      # ,
      #
      #
      #
      #



        ,
      # Waterfall plot function ----
      .waterfallplot = function(imageWaterfall, ggtheme, theme, ...) {
        if (!self$options$showWaterfallPlot) return()

        plotData <- imageWaterfall$state
        options <- plotData$options

        if (is.null(plotData) || is.null(plotData$data) || is.null(plotData$data$waterfall)) {
          warning("Plot data not properly initialized")
          return()
        }


        df <- plotData$data$waterfall

        # Sort data
        if (plotData$options$sortBy == "response") {
          df <- df[order(df$response, na.last = TRUE),]
        } else {
          df <- df[order(df[[plotData$options$patientID]], na.last = TRUE),]
        }

        # Define color schemes
        recistColors <- c(
          "CR" = "#0000FF",
          "PR" = "#4169E1",
          "SD" = "#FFA500",
          "PD" = "#FF0000",
          "NA" = "#808080"
        )

        simpleColors <- c(
          "CR" = "#00AA00",
          "PR" = "#00AA00",
          "SD" = "#808080",
          "PD" = "#FF0000",
          "NA" = "#808080"
        )

        colors <- if (plotData$options$colorScheme == "simple")
          simpleColors else recistColors

        # Create base plot
        p <- ggplot2::ggplot(df, ggplot2::aes(
          x = factor(seq_len(nrow(df))),
          y = response
        )) +
          ggplot2::geom_bar(
            stat = "identity",
            ggplot2::aes(fill = category),
            width = plotData$options$barWidth,
            alpha = plotData$options$barAlpha
          ) +
          ggplot2::scale_fill_manual(
            name = "RECIST Response",
            values = colors,
            na.value = "#808080",
            drop = FALSE
          ) +
          ggplot2::labs(
            x = "Patients",
            y = "Change in Tumor Size (%)"
          )

        # Add RECIST thresholds
        if (plotData$options$showThresholds) {
          p <- p +
            ggplot2::geom_hline(
              yintercept = c(-30, 20),
              linetype = "dashed",
              color = c("#4169E1", "#FF0000"),
              alpha = 0.5
            )
        }

        # Add labels for large changes
        if (plotData$options$labelOutliers) {
          threshold <- plotData$options$minResponseForLabel
          labels <- ifelse(
            !is.na(df$response) & abs(df$response) > threshold,
            sprintf("%.1f%%", df$response),
            ""
          )

          if (any(labels != "")) {
            p <- p +
              ggplot2::geom_text(
                data = df[labels != "",],
                mapping = ggplot2::aes(
                  x = factor(which(labels != "")),
                  y = response
                ),
                label = labels[labels != ""],
                vjust = ifelse(
                  df$response[labels != ""] >= 0,
                  -0.5,
                  1.5
                ),
                size = 3
              )
          }
        }

        # Add median line
        if (plotData$options$showMedian) {
          med <- median(df$response, na.rm=TRUE)
          p <- p +
            ggplot2::geom_hline(
              yintercept = med,
              linetype = "dotted",
              color = "darkgray"
            ) +
            ggplot2::annotate(
              "text",
              x = nrow(df),
              y = med,
              label = sprintf("Median: %.1f%%", med),
              hjust = 1,
              vjust = -0.5,
              size = 3
            )
        }

        # Add confidence interval
        if (plotData$options$showCI && nrow(df) >= 10) {
          ci <- t.test(df$response)$conf.int
          p <- p +
            ggplot2::annotate(
              "text",
              x = 1,
              y = max(df$response, na.rm=TRUE),
              label = sprintf(
                "95%% CI: [%.1f%%, %.1f%%]",
                ci[1],
                ci[2]
              ),
              hjust = 0,
              vjust = -0.5,
              size = 3
            )
        }

        # Add theme
        if (plotData$options$colorScheme == "jamovi") {
          p <- p + ggtheme
        }

        p <- p +
          ggplot2::theme(
            axis.text.x = ggplot2::element_blank(),
            axis.ticks.x = ggplot2::element_blank(),
            panel.grid.major.x = ggplot2::element_blank(),
            panel.grid.minor.x = ggplot2::element_blank(),
            legend.position = "right"
          )

        print(p)
        TRUE
      },




      #         # spider plot
      #         # .spiderplot = function(imagespiderplot, ggtheme, theme, ...) {
      #
      #           if (is.null(self$options$timeVar) || !self$options$showSpiderPlot)
      #             return()
      #
      #           plotData <- image$state
      #           df <- plotData$data_spider  # Use spider format data
      #
      #
      #           # Prepare data
      #           df <- self$data
      #           responseVar <- self$options$responseVar
      #           timeVar <- self$options$timeVar
      #           patientVar <- self$options$patientID
      #
      #           # Convert to numeric
      #           df$response <- jmvcore::toNumeric(df[[responseVar]])
      #           df$time <- jmvcore::toNumeric(df[[timeVar]])
      #
      #           # Create spider plot
      #           p <- ggplot2::ggplot(df, ggplot2::aes(
      #             x = time,
      #             y = response,
      #             group = .data[[patientVar]],
      #             color = response <= -30
      #           )) +
      #             ggplot2::geom_line(size = 1) +
      #             ggplot2::geom_point(size = 2) +
      #             ggplot2::scale_color_manual(
      #               name = "Response",
      #               values = c("FALSE" = "#CC0000", "TRUE" = "#0066CC"),
      #               labels = c("Non-responder", "Responder")
      #             ) +
      #             ggplot2::geom_hline(
      #               yintercept = c(-30, 20),
      #               linetype = "dashed",
      #               color = "gray50",
      #               alpha = 0.5
      #             ) +
      #             ggplot2::labs(
      #               x = "Time",
      #               y = "Change in Tumor Size (%)",
      #               title = "Spider Plot of Tumor Response"
      #             ) +
      #             ggtheme +
      #             ggplot2::theme(
      #               legend.position = "right"
      #             )
      #
      #           print(p)
      #           TRUE
      #         # }



      # Spider plot function
      # .spiderplot = function(imagespider, ggtheme, theme, ...) {
      #   if (is.null(self$options$timeVar) || !self$options$showSpiderPlot)
      #     return()
      #
      #   plotData <- imagespider$state
      #   df <- plotData$data$spider
      #
      #   p <- ggplot2::ggplot(df, ggplot2::aes(
      #     x = .data[[plotData$options$timeVar]],
      #     y = response,
      #     group = .data[[plotData$options$patientID]],
      #     color = response <= -30
      #   )) +
      #     ggplot2::geom_line(size = 1) +
      #     ggplot2::geom_point(size = 2) +
      #     ggplot2::scale_color_manual(
      #       name = "Response",
      #       values = c("FALSE" = "#CC0000", "TRUE" = "#0066CC"),
      #       labels = c("Non-responder", "Responder")
      #     ) +
      #     ggplot2::geom_hline(
      #       yintercept = c(-30, 20),
      #       linetype = "dashed",
      #       color = "gray50",
      #       alpha = 0.5
      #     ) +
      #     ggplot2::labs(
      #       x = "Time",
      #       y = "Change in Tumor Size (%)",
      #       title = "Spider Plot of Tumor Response"
      #     ) +
      #     ggtheme +
      #     ggplot2::theme(
      #       legend.position = "right"
      #     )
      #
      #   print(p)
      #   TRUE
      # }

      # spider plot ----

      .spiderplot = function(imagespider, ggtheme, theme, ...) {


        # Check conditions for showing the information message
        if (is.null(self$options$timeVar) || !self$options$showSpiderPlot) {
          # Create an informative message with improved formatting for readability
          text_warning <- paste(
            "Spider Plot Requirements and Guidelines",
            "\n\n",
            "This visualization requires two key elements:",
            "\n",
            "1. A time variable to show response trajectories",
            "\n",
            "2. The 'Show Spider Plot' option to be enabled",
            "\n\n",
            "Understanding Spider Plots:",
            "\n",
            "A spider plot helps visualize how each patient's response changes over time. ",
            "Each line represents one patient's treatment journey, making it easy to see ",
            "patterns in response and identify different types of outcomes.",
            "\n\n",
            "To Generate the Plot:",
            "\n",
            "• Add a time variable (such as months from baseline)",
            "\n",
            "• Enable 'Show Spider Plot' in the options panel",
            "\n\n",
            "The resulting visualization will help you track response patterns ",
            "and compare outcomes across different patients over time.",
            sep = ""
          )

          text_warning <- paste(text_warning,
            "Time Variable Requirement:",
            "\n\nA time variable is required to create visualizations when using raw measurements.",
            "\n\nWhy is this important?",
            "\n• Baseline identification: Marks the starting point (time = 0)",
            "\n• Response calculation: Computes changes from baseline",
            "\n• Progression tracking: Shows how response changes over time",
            "\n\nHow to proceed:",
            "\n1. Add a time variable to your data",
            "\n2. Time should start at 0 (baseline)",
            "\n3. Use consistent time units (e.g., months or weeks)",
            "\n\nExample time variable format:",
            "\nPatientID  Time  Measurement",
            "\nPT1        0     50          (baseline)",
            "\nPT1        2     25          (2 months)",
            "\nPT1        4     10          (4 months)",
            sep = ""
          )



          # Create a new page
          grid::grid.newpage()

          # Create a viewport with margins for better readability
          vp <- grid::viewport(
            width = 0.9,    # Wider viewport for left-aligned text
            height = 0.9,   # Keep reasonable margins
            x = 0.5,        # Center the viewport
            y = 0.5         # Center the viewport
          )
          grid::pushViewport(vp)

          # Add the text with left alignment
          grid::grid.text(
            text_warning,
            x = 0.05,           # Move text to the left (5% margin)
            y = 0.95,           # Start from top (5% margin)
            just = c("left", "top"),  # Left align and top justify
            gp = grid::gpar(
              fontsize = 11,        # Maintain readable size
              fontface = "plain",   # Regular font
              lineheight = 1.3      # Slightly increased line spacing for readability
            )
          )

          # Reset viewport
          grid::popViewport()

          return(TRUE)
        }

        # Get plot data from state

        plotData <- imagespider$state

        # if (is.null(plotData) || is.null(plotData$data$spider)) {
        #   warning("Spider plot data not properly initialized")
        #   return()
        # }

        # Extract data and options
        df <- plotData$data$spider
        options <- plotData$options

        # Validate required variables exist
        required_vars <- c(options$timeVar, options$patientID)
        missing_vars <- required_vars[!required_vars %in% names(df)]
        if (length(missing_vars) > 0) {
          warning(sprintf("Missing required variables: %s",
                          paste(missing_vars, collapse = ", ")))
          return()
        }

        # Convert variables to numeric explicitly
        df$time <- jmvcore::toNumeric(df[[options$timeVar]])
        df$response <- jmvcore::toNumeric(df$response)  # response should already be calculated

        # Remove any rows with NA values
        df <- df[complete.cases(df[c("time", "response")]), ]

        # Sort data by patient and time
        df <- df[order(df[[options$patientID]], df$time), ]

        # Create the spider plot
        p <- ggplot2::ggplot(df) +
          # Add lines connecting points for each patient
          ggplot2::geom_line(
            mapping = ggplot2::aes(
              x = time,                              # Use processed time variable
              y = response,                          # Use processed response
              group = .data[[options$patientID]],   # Group by patient ID
              color = response <= -30                # Color by response threshold
            ),
            size = 1
          ) +
          # Add points at each measurement
          ggplot2::geom_point(
            mapping = ggplot2::aes(
              x = time,
              y = response,
              color = response <= -30
            ),
            size = 2
          ) +
          # Define colors for response categories
          ggplot2::scale_color_manual(
            name = "Response",
            values = c("FALSE" = "#CC0000", "TRUE" = "#0066CC"),
            labels = c("Non-responder", "Responder")
          ) +
          # Add RECIST threshold lines
          ggplot2::geom_hline(
            yintercept = c(-30, 20),
            linetype = "dashed",
            color = "gray50",
            alpha = 0.5
          ) +
          # Add labels
          ggplot2::labs(
            x = paste("Time", "(", options$timeVar, ")"),  # Include time variable name
            y = "Change in Tumor Size (%)",
            title = "Spider Plot of Tumor Response"
          )

        # Add theme
        p <- p + ggtheme +
          ggplot2::theme(
            legend.position = "right",
            panel.grid.minor = ggplot2::element_blank(),
            axis.text = ggplot2::element_text(size = 10),
            axis.title = ggplot2::element_text(size = 12),
            plot.title = ggplot2::element_text(size = 14, face = "bold")
          )

        # Optional annotations
        if (options$showThresholds) {
          # Add threshold annotations
          p <- p +
            ggplot2::annotate(
              "text",
              x = min(df$time),
              y = c(-30, 20),
              label = c("PR threshold (-30%)", "PD threshold (+20%)"),
              hjust = 0,
              vjust = c(1.5, -0.5),
              size = 3,
              color = "gray50"
            )
        }

        # Add summary statistics if requested
        if (options$showMedian) {
          # Calculate median response at each timepoint
          median_response <- stats::aggregate(
            response ~ time,
            data = df,
            FUN = median
          )

          # Add median line
          p <- p +
            ggplot2::geom_line(
              data = median_response,
              mapping = ggplot2::aes(
                x = time,
                y = response
              ),
              color = "black",
              linetype = "dotted",
              size = 1
            )
        }

        # Try to print the plot with error handling
        tryCatch({
          print(p)
          TRUE
        }, error = function(e) {
          warning(sprintf("Error creating spider plot: %s", e$message))
          FALSE
        })
      }










    )
)


File: R\waterfall.h.R
--------------------------------------------------
Content of R\waterfall.h.R:

# This file is automatically generated, you probably don't want to edit this

waterfallOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "waterfallOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            patientID = NULL,
            responseVar = NULL,
            timeVar = NULL,
            inputType = "percentage",
            sortBy = "response",
            showThresholds = FALSE,
            labelOutliers = FALSE,
            showMedian = FALSE,
            showCI = FALSE,
            minResponseForLabel = 50,
            colorScheme = "jamovi",
            barAlpha = 1,
            barWidth = 0.7,
            showWaterfallPlot = FALSE,
            showSpiderPlot = FALSE,
            addResponseCategory = FALSE, ...) {

            super$initialize(
                package="ClinicoPathDescriptives",
                name="waterfall",
                requiresData=TRUE,
                ...)

            private$..patientID <- jmvcore::OptionVariable$new(
                "patientID",
                patientID,
                suggested=list(
                    "nominal"),
                permitted=list(
                    "numeric",
                    "factor",
                    "id"))
            private$..responseVar <- jmvcore::OptionVariable$new(
                "responseVar",
                responseVar,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..timeVar <- jmvcore::OptionVariable$new(
                "timeVar",
                timeVar,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..inputType <- jmvcore::OptionList$new(
                "inputType",
                inputType,
                options=list(
                    "raw",
                    "percentage"),
                default="percentage")
            private$..sortBy <- jmvcore::OptionList$new(
                "sortBy",
                sortBy,
                options=list(
                    "response",
                    "id"),
                default="response")
            private$..showThresholds <- jmvcore::OptionBool$new(
                "showThresholds",
                showThresholds,
                default=FALSE)
            private$..labelOutliers <- jmvcore::OptionBool$new(
                "labelOutliers",
                labelOutliers,
                default=FALSE)
            private$..showMedian <- jmvcore::OptionBool$new(
                "showMedian",
                showMedian,
                default=FALSE)
            private$..showCI <- jmvcore::OptionBool$new(
                "showCI",
                showCI,
                default=FALSE)
            private$..minResponseForLabel <- jmvcore::OptionNumber$new(
                "minResponseForLabel",
                minResponseForLabel,
                default=50,
                min=0,
                max=100)
            private$..colorScheme <- jmvcore::OptionList$new(
                "colorScheme",
                colorScheme,
                options=list(
                    "jamovi",
                    "recist",
                    "simple"),
                default="jamovi")
            private$..barAlpha <- jmvcore::OptionNumber$new(
                "barAlpha",
                barAlpha,
                default=1,
                min=0,
                max=1)
            private$..barWidth <- jmvcore::OptionNumber$new(
                "barWidth",
                barWidth,
                default=0.7,
                min=0.1,
                max=1)
            private$..showWaterfallPlot <- jmvcore::OptionBool$new(
                "showWaterfallPlot",
                showWaterfallPlot,
                default=FALSE)
            private$..showSpiderPlot <- jmvcore::OptionBool$new(
                "showSpiderPlot",
                showSpiderPlot,
                default=FALSE)
            private$..addResponseCategory <- jmvcore::OptionBool$new(
                "addResponseCategory",
                addResponseCategory,
                default=FALSE)

            self$.addOption(private$..patientID)
            self$.addOption(private$..responseVar)
            self$.addOption(private$..timeVar)
            self$.addOption(private$..inputType)
            self$.addOption(private$..sortBy)
            self$.addOption(private$..showThresholds)
            self$.addOption(private$..labelOutliers)
            self$.addOption(private$..showMedian)
            self$.addOption(private$..showCI)
            self$.addOption(private$..minResponseForLabel)
            self$.addOption(private$..colorScheme)
            self$.addOption(private$..barAlpha)
            self$.addOption(private$..barWidth)
            self$.addOption(private$..showWaterfallPlot)
            self$.addOption(private$..showSpiderPlot)
            self$.addOption(private$..addResponseCategory)
        }),
    active = list(
        patientID = function() private$..patientID$value,
        responseVar = function() private$..responseVar$value,
        timeVar = function() private$..timeVar$value,
        inputType = function() private$..inputType$value,
        sortBy = function() private$..sortBy$value,
        showThresholds = function() private$..showThresholds$value,
        labelOutliers = function() private$..labelOutliers$value,
        showMedian = function() private$..showMedian$value,
        showCI = function() private$..showCI$value,
        minResponseForLabel = function() private$..minResponseForLabel$value,
        colorScheme = function() private$..colorScheme$value,
        barAlpha = function() private$..barAlpha$value,
        barWidth = function() private$..barWidth$value,
        showWaterfallPlot = function() private$..showWaterfallPlot$value,
        showSpiderPlot = function() private$..showSpiderPlot$value,
        addResponseCategory = function() private$..addResponseCategory$value),
    private = list(
        ..patientID = NA,
        ..responseVar = NA,
        ..timeVar = NA,
        ..inputType = NA,
        ..sortBy = NA,
        ..showThresholds = NA,
        ..labelOutliers = NA,
        ..showMedian = NA,
        ..showCI = NA,
        ..minResponseForLabel = NA,
        ..colorScheme = NA,
        ..barAlpha = NA,
        ..barWidth = NA,
        ..showWaterfallPlot = NA,
        ..showSpiderPlot = NA,
        ..addResponseCategory = NA)
)

waterfallResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "waterfallResults",
    inherit = jmvcore::Group,
    active = list(
        todo2 = function() private$.items[["todo2"]],
        todo = function() private$.items[["todo"]],
        summary = function() private$.items[["summary"]],
        clinicalMetrics = function() private$.items[["clinicalMetrics"]],
        waterfallplot = function() private$.items[["waterfallplot"]],
        spiderplot = function() private$.items[["spiderplot"]],
        responseCategory = function() private$.items[["responseCategory"]],
        mydataview = function() private$.items[["mydataview"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Treatment Response Waterfall Plot",
                refs=list(
                    "recist",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo2",
                title="To Do 2"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do"))
            self$add(jmvcore::Table$new(
                options=options,
                name="summary",
                title="Response Summary",
                rows=0,
                columns=list(
                    list(
                        `name`="category", 
                        `title`="Response Category", 
                        `type`="text"),
                    list(
                        `name`="n", 
                        `title`="n", 
                        `type`="integer"),
                    list(
                        `name`="percent", 
                        `title`="%", 
                        `type`="number", 
                        `format`="percent"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="clinicalMetrics",
                title="Clinical Response Metrics",
                rows=0,
                columns=list(
                    list(
                        `name`="metric", 
                        `title`="Metric", 
                        `type`="text"),
                    list(
                        `name`="value", 
                        `title`="Value", 
                        `type`="text"))))
            self$add(jmvcore::Image$new(
                options=options,
                name="waterfallplot",
                title="Waterfall Plot",
                width=800,
                height=500,
                renderFun=".waterfallplot",
                requiresData=TRUE,
                visible="(showWaterfallPlot)",
                clearWith=list(
                    "patientID",
                    "response",
                    "sortBy",
                    "showThresholds",
                    "labelOutliers",
                    "colorScheme",
                    "showMedian",
                    "showCI")))
            self$add(jmvcore::Image$new(
                options=options,
                name="spiderplot",
                title="Response Over Time",
                width=800,
                height=500,
                renderFun=".spiderplot",
                requiresData=TRUE,
                visible="(showSpiderPlot)",
                clearWith=list(
                    "patientID",
                    "response",
                    "timeVar",
                    "inputType",
                    "sortBy")))
            self$add(jmvcore::Output$new(
                options=options,
                name="responseCategory",
                title="Response Category",
                varTitle="`Calculated Response Category`",
                varDescription="Calculated response category based on RECIST criteria.",
                clearWith=list(
                    "patientID",
                    "response")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="mydataview",
                title="mydataview"))}))

waterfallBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "waterfallBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPathDescriptives",
                name = "waterfall",
                version = c(1,0,0),
                options = options,
                results = waterfallResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Treatment Response Waterfall Plot
#'
#' Creates a waterfall plot to visualize tumor response data following RECIST 
#' criteria.
#'
#' @examples
#' \donttest{
#' data <- data.frame(
#'     PatientID = paste0("PT", 1:10),
#'     Response = c(-100, -45, -30, -20, -10, 0, 10, 20, 30, 40)
#' )
#' waterfall(
#'     data = data,
#'     patientID = "PatientID",
#'     response = "Response"
#' )
#'}
#' @param data The data as a data frame.
#' @param patientID Variable containing patient identifiers.
#' @param responseVar Percentage change in tumor size.
#' @param timeVar Time point of measurement for spider plot (e.g., months from
#'   baseline)
#' @param inputType Specify data format: 'raw' for actual measurements (will
#'   calculate percent change)  or 'percentage' for pre-calculated percentage
#'   changes
#' @param sortBy Sort the waterfall plot by best response or patient ID.
#' @param showThresholds Show +20 percent and -30 percent RECIST thresholds.
#' @param labelOutliers Label responses exceeding ±50 percent.
#' @param showMedian Show median response as a horizontal line.
#' @param showCI Show confidence interval around median response.
#' @param minResponseForLabel Minimum response value for labels to be
#'   displayed.
#' @param colorScheme Color scheme for waterfall plot.
#' @param barAlpha Transparency of bars in waterfall plot.
#' @param barWidth Width of bars in waterfall plot.
#' @param showWaterfallPlot .
#' @param showSpiderPlot Create an additional spider plot showing response
#'   over time if longitudinal data available
#' @param addResponseCategory Add a new variable to the data frame indicating
#'   response category.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo2} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$summary} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$clinicalMetrics} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$waterfallplot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$spiderplot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$responseCategory} \tab \tab \tab \tab \tab an output \cr
#'   \code{results$mydataview} \tab \tab \tab \tab \tab a preformatted \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$summary$asDF}
#'
#' \code{as.data.frame(results$summary)}
#'
#' @export
waterfall <- function(
    data,
    patientID,
    responseVar,
    timeVar,
    inputType = "percentage",
    sortBy = "response",
    showThresholds = FALSE,
    labelOutliers = FALSE,
    showMedian = FALSE,
    showCI = FALSE,
    minResponseForLabel = 50,
    colorScheme = "jamovi",
    barAlpha = 1,
    barWidth = 0.7,
    showWaterfallPlot = FALSE,
    showSpiderPlot = FALSE,
    addResponseCategory = FALSE) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("waterfall requires jmvcore to be installed (restart may be required)")

    if ( ! missing(patientID)) patientID <- jmvcore::resolveQuo(jmvcore::enquo(patientID))
    if ( ! missing(responseVar)) responseVar <- jmvcore::resolveQuo(jmvcore::enquo(responseVar))
    if ( ! missing(timeVar)) timeVar <- jmvcore::resolveQuo(jmvcore::enquo(timeVar))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(patientID), patientID, NULL),
            `if`( ! missing(responseVar), responseVar, NULL),
            `if`( ! missing(timeVar), timeVar, NULL))


    options <- waterfallOptions$new(
        patientID = patientID,
        responseVar = responseVar,
        timeVar = timeVar,
        inputType = inputType,
        sortBy = sortBy,
        showThresholds = showThresholds,
        labelOutliers = labelOutliers,
        showMedian = showMedian,
        showCI = showCI,
        minResponseForLabel = minResponseForLabel,
        colorScheme = colorScheme,
        barAlpha = barAlpha,
        barWidth = barWidth,
        showWaterfallPlot = showWaterfallPlot,
        showSpiderPlot = showSpiderPlot,
        addResponseCategory = addResponseCategory)

    analysis <- waterfallClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



