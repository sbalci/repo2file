Directory Structure:
-------------------
/ 
├── data/
│   ├── histopathology.rda
│   └── histopathologyMedicalDecision.omv
├── jamovi/
│   ├── js/
│   │   ├── kappasizeci.js
│   │   ├── kappasizefixedn.js
│   │   └── kappasizepower.js
│   ├── 0000.yaml
│   ├── 00refs.yaml
│   ├── agreement.a.yaml
│   ├── agreement.r.yaml
│   ├── agreement.u.yaml
│   ├── decision.a.yaml
│   ├── decision.r.yaml
│   ├── decision.u.yaml
│   ├── decisioncalculator.a.yaml
│   ├── decisioncalculator.r.yaml
│   ├── decisioncalculator.u.yaml
│   ├── kappasizeci.a.yaml
│   ├── kappasizeci.r.yaml
│   ├── kappasizeci.u.yaml
│   ├── kappasizefixedn.a.yaml
│   ├── kappasizefixedn.r.yaml
│   ├── kappasizefixedn.u.yaml
│   ├── kappasizepower.a.yaml
│   ├── kappasizepower.r.yaml
│   └── kappasizepower.u.yaml
├── man/
│   ├── agreement.Rd
│   ├── agreementClass.Rd
│   ├── auc_ci.Rd
│   ├── bootstrap_ci.Rd
│   ├── bootstrap_roc_test.Rd
│   ├── calculate_auc.Rd
│   ├── calculate_bootstrap_results.Rd
│   ├── calculate_ci_roc.Rd
│   ├── calculate_delong_cov.Rd
│   ├── calculate_placement_values.Rd
│   ├── calculate_se.Rd
│   ├── compare_auc.Rd
│   ├── compare_tests.Rd
│   ├── decision.Rd
│   ├── decisioncalculator.Rd
│   ├── decisioncalculatorClass.Rd
│   ├── decisionClass.Rd
│   ├── delong_test.Rd
│   ├── histopathology.Rd
│   ├── kappaSizeCI.Rd
│   ├── kappaSizeCIClass.Rd
│   ├── kappaSizeFixedN.Rd
│   ├── kappaSizeFixedNClass.Rd
│   ├── kappaSizePower.Rd
│   ├── kappaSizePowerClass.Rd
│   ├── meddecide-package.Rd
│   ├── prepare_bootstrap_data.Rd
│   └── roc_utils.Rd
├── R/
│   ├── 00jmv.R
│   ├── agreement.b.R
│   ├── agreement.h.R
│   ├── decision.b.R
│   ├── decision.h.R
│   ├── decisioncalculator.b.R
│   ├── decisioncalculator.h.R
│   ├── kappasizeci.b.R
│   ├── kappasizeci.h.R
│   ├── kappasizefixedn.b.R
│   ├── kappasizefixedn.h.R
│   ├── kappasizepower.b.R
│   ├── kappasizepower.h.R
│   ├── meddecide-data.R
│   ├── meddecide-package.R
│   ├── meddecide-stats_utils.R
│   ├── meddecide-utils.R
│   ├── nomogrammer.r
│   └── stats_utils.R
├── tests/
│   └── testthat/
│       └── test-decision.R
├── .gitattributes
├── .Rbuildignore
├── DESCRIPTION
├── LICENSE.md
├── meddecide.code-workspace
├── meddecide.Rproj
├── meddecide_0.0.2.39.jmo
├── meddecide_0.0.2.45.jmo
├── NAMESPACE
└── README.md

File Contents:
--------------
File: jamovi\0000.yaml
--------------------------------------------------
Content of jamovi\0000.yaml:
---
title: Functions for Medical Decision in ClinicoPath jamovi Module
name: meddecide
version: 0.0.2.46
jms: '1.0'
authors:
  - Serdar Balci
maintainer: Serdar Balci <drserdarbalci@gmail.com>
date: '2025-01-12'
type: R
description: |-
  This module contains functions for interobserver and intraobserver reliability
  and decision tests (sensitivity, specificity, PPV, NPV).
  Power analyses are available.
analyses:
  - title: Interrater Reliability
    name: agreement
    ns: meddecide
    menuGroup: meddecide
    menuSubgroup: Agreement
    menuTitle: Interrater Reliability
    description: Function for Interrater Reliability.
  - title: Medical Decision
    name: decision
    ns: meddecide
    menuGroup: meddecide
    menuSubgroup: Decision
    menuTitle: Medical Decision
    description: >
      Function for Medical Decision Analysis. Sensitivity, specificity, positive
      predictive value, negative predictive value.
    menuSubtitle: Sensitivity, Specificity, PPV, NPV, ...
  - title: Medical Decision Calculator
    name: decisioncalculator
    ns: meddecide
    menuGroup: meddecide
    menuSubgroup: Decision
    menuTitle: Medical Decision Calculator
    description: Function for Medical Decision Calculator.
    menuSubtitle: Sensitivity, Specificity, PPV, NPV, ...
  - title: Power Approach for the Number of Subjects Required
    name: kappaSizePower
    ns: meddecide
    menuGroup: meddecide
    menuSubgroup: Power Analysis
    menuSubtitle: Find sample size based on power
    menuTitle: Power Approach for the Number of Subjects Required
    description: |
      Power Analysis for Interobserver Agreement Analysis.
  - title: Confidence Interval Approach for the Number of Subjects Required
    name: kappaSizeCI
    ns: meddecide
    menuGroup: meddecide
    menuTitle: Confidence Interval Approach for the Number of Subjects Required
    menuSubgroup: Power Analysis
    menuSubtitle: Find sample size based on Kappa confidence
    description: |
      Power Analysis for Interobserver Agreement Analysis.
  - title: Lowest Expected Value for a fixed sample size
    name: kappaSizeFixedN
    ns: meddecide
    menuGroup: meddecide
    menuTitle: Lowest Expected Value for a fixed sample size
    menuSubgroup: Power Analysis
    menuSubtitle: Find lower Kappa based on sample size
    description: |
      Lowest Expected Value for a fixed sample size.
datasets:
  - name: histopathology including analysis
    path: histopathologyMedicalDecision.omv
    description: Example analysis for Medical Decision Tests.
    tags:
      - Kappa
      - Sensitivity
usesNative: true
minApp: 1.8.1

...


File: jamovi\00refs.yaml
--------------------------------------------------
Content of jamovi\00refs.yaml:
---
refs:
    emmeans:
        type: 'software'
        author: Lenth, R.
        year: 2018
        title: 'emmeans: Estimated Marginal Means, aka Least-Squares Means'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=emmeans'
        url: https://CRAN.R-project.org/package=emmeans

    afex:
        type: 'software'
        author: Singmann, H.
        year: 2018
        title: 'afex: Analysis of Factorial Experiments'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=afex'
        url: https://CRAN.R-project.org/package=afex

    R:
        type: 'software'
        author: R Core Team
        year: 2018
        title: 'A Language and Envionment for Statistical Computing'
        publisher: '[Computer software]. Retrieved from https://CRAN.R-project.org/'
        url: https://CRAN.R-project.org/

    BF:
        type: 'software'
        author: Morey, R. D., & Rouder, J. N.
        year: 2018
        title: 'BayesFactor: Computation of Bayes Factors for Common Designs'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=BayesFactor'
        url: https://CRAN.R-project.org/package=BayesFactor

    btt:
        type: 'article'
        author: Rouder, J. N., Speckman, P. L., Sun, D., Morey, R. D., & Iverson, G.
        year: 2009
        title: Bayesian t tests for accepting and rejecting the null hypothesis
        publisher: Psychonomic Bulletin & Review
        volume: 16
        pages: 225-237

    car:
        type: 'software'
        author: Fox, J., & Weisberg, S.
        year: 2018
        title: 'car: Companion to Applied Regression'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=car'
        url: https://CRAN.R-project.org/package=car

    ggplot2:
        type: 'software'
        author: Wickham, H., Chang, W., Henry, L., Pedersen, T. L., Takahashi, K., Wilke, C., Woo, K., & RStudio
        year: 2018
        title: 'ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ggplot2'
        url: https://CRAN.R-project.org/package=ggplot2

    ggridges:
        type: 'software'
        author: Wilke, C., & RStudio
        year: 2018
        title: 'ggridges: Ridgeline Plots in ggplot2'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ggridges'
        url: https://CRAN.R-project.org/package=ggridges

    mvnormtest:
        type: 'software'
        author: Jarek, S.
        year: 2012
        title: 'mvnormtest: Normality test for multivariate variables'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=mvnormtest'
        url: https://CRAN.R-project.org/package=mvnormtest

    PMCMR:
        type: 'software'
        author: Pohlert, T.
        year: 2018
        title: 'PMCMR: Calculate Pairwise Multiple Comparisons of Mean Rank Sums'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=PMCMR'
        url: https://CRAN.R-project.org/package=PMCMR

    ROCR:
        type: 'software'
        author: Sing, T., Sander, O., Beerenwinkel, N., & Lengauer, T.
        year: 2015
        title: 'ROCR: Visualizing the Performance of Scoring Classifiers'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ROCR'
        url: https://CRAN.R-project.org/package=ROCR

    nnet:
        type: 'software'
        author: Ripley, B., Venables W.
        year: 2016
        title: 'nnet: Feed-Forward Neural Networks and Multinomial Log-Linear Models'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=nnet'
        url: https://CRAN.R-project.org/package=nnet

    MASS:
        type: 'software'
        author: Ripley, B., Venables W., Bates, D. M., Hornik, K., Gebhardt, A., & Firth, D.
        year: 2018
        title: "MASS: Support Functions and Datasets for Venables and Ripley's MASS"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=MASS'
        url: https://CRAN.R-project.org/package=MASS

    vcd:
        type: 'software'
        author: Meyer, D., Zeileis, A., Hornik, K., Gerber, F., & Friendly, M.
        year: 2017
        title: "vcd: Visualizing Categorical Data"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=vcd'
        url: https://CRAN.R-project.org/package=vcd

    vcdExtra:
        type: 'software'
        author: Friendly M., Turner, H., Zeileis, A., Murdoch, D., & Firth, D.
        year: 2017
        title: "vcdExtra: 'vcd' Extensions and Additions"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=vcdExtra'
        url: https://CRAN.R-project.org/package=vcdExtra

    exact2x2:
        type: 'software'
        author: Fay, M. P., Hunsberger, S. A., Nason, M., & Gabriel, E.
        year: 2018
        title: "exact2x2: Exact Tests and Confidence Intervals for 2x2 Tables"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=exact2x2'
        url: https://CRAN.R-project.org/package=exact2x2

    psych:
        type: 'software'
        author: Revelle, W.
        year: 2019
        title: "psych: Procedures for Psychological, Psychometric, and Personality Research"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=psych'
        url: https://CRAN.R-project.org/package=psych

    lavaan:
        type: 'software'
        author: Rosseel, Y., et al.
        year: 2018
        title: "lavaan: Latent Variable Analysis"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=lavaan'
        url: https://CRAN.R-project.org/package=lavaan

    semPlot:
        type: 'software'
        author: Epskamp, S.
        year: 2017
        title: "semPlot: Path Diagrams and Visual Analysis of Various SEM Packages' Output"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=semPlot'
        url: https://CRAN.R-project.org/package=semPlot

    ggstatsplot:
        type: 'software'
        author: Patil, I.
        year: 2018
        title: "ggstatsplot: 'ggplot2' Based Plots with Statistical Details"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ggstatsplot'
        url: https://CRAN.R-project.org/package=ggstatsplot
        doi: '10.5281/zenodo.2074621'

    report:
        type: 'software'
        author: Makowski, Dominique, Lüdecke, Daniel
        year: 2019
        title: "The report package for R: Ensuring the use of best practices for results reporting"
        publisher: '[R package]. Retrieved from https://github.com/easystats/report'
        url: https://github.com/easystats/report

    arsenal:
        type: 'software'
        author: Heinzen, E Sinnwell, J Atkinson, E Gunderson, T Dougherty, G
        year: 2018
        title: "arsenal: An Arsenal of 'R' Functions for Large-Scale Statistical Summaries"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=arsenal'
        url: https://CRAN.R-project.org/package=arsenal

    tangram:
        type: 'software'
        author: Garbett, S.
        year: 2018
        title: "tangram: The Grammar of Tables"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=tangram'
        url: https://CRAN.R-project.org/package=tangram

    irr:
        type: 'software'
        author: Matthias Gamer, Jim Lemon, Ian Fellows, Puspendra Singh
        year: 2019
        title: "Various Coefficients of Interrater Reliability and Agreement."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=irr'
        url: https://CRAN.R-project.org/package=irr

    tableone:
        type: 'software'
        author: Kazuki, Y.
        year: 2019
        title: "tableone: Create 'Table 1' to Describe Baseline Characteristics"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=tableone'
        url: https://CRAN.R-project.org/package=tableone

    janitor:
        type: 'software'
        author: Firke, S.
        year: 2019
        title: "janitor: Simple Tools for Examining and Cleaning Dirty Data."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=janitor'
        url: https://CRAN.R-project.org/package=janitor


    finalfit:
        type: 'software'
        author: Ewen Harrison and Tom Drake and Riinu Ots
        year: 2019
        title: "finalfit: Quickly Create Elegant Regression Results Tables and Plots when Modelling"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=finalfit'
        url: https://CRAN.R-project.org/package=finalfit


    caret:
        type: 'software'
        author: Max Kuhn
        year: 2020
        title: "caret: Classification and Regression Training"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=caret'
        url: https://CRAN.R-project.org/package=caret

    psycho:
        type: 'software'
        author: Makowski, D.
        year: 2018
        title: "The Psycho Package: An Efficient and Publishing-Oriented Workflow for Psychological Science. Journal of Open Source Software, 3(22), 470."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=psycho.R'
        url: https://CRAN.R-project.org/package=psycho.R

    survival:
        type: 'software'
        author: Terry M Therneau, Thomas Lumley
        year: 2019
        title: "survival: Survival Analysis"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=survival'
        url: https://CRAN.R-project.org/package=survival

    survminer:
        type: 'software'
        author: Alboukadel Kassambara and Marcin Kosinski and Przemyslaw Biecek
        year: 2019
        title: "survminer: Drawing Survival Curves using 'ggplot2'"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=survminer'
        url: https://CRAN.R-project.org/package=survminer


    ggalluvial:
        type: 'software'
        author: Jason Cory Brunson
        year: 2019
        title: "ggalluvial: Alluvial Plots in 'ggplot2'."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ggalluvial'
        url: https://CRAN.R-project.org/package=ggalluvial

    explore:
        type: 'software'
        author: Roland Krasser
        year: 2020
        title: "explore: Simplifies Exploratory Data Analysis."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=explore'
        url: https://CRAN.R-project.org/package=explore

    FFTrees:
        type: 'software'
        author: Nathaniel Phillips, Hansjoerg Neth, Jan Woike and Wolfgang Gaissmaer
        year: 2019
        title: "FFTrees: Generate, Visualise, and Evaluate Fast-and-Frugal Decision Trees"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=FFTrees'
        url: https://CRAN.R-project.org/package=FFTrees


    rpart:
        type: 'software'
        author: Terry Therneau and Beth Atkinson
        year: 2019
        title: "rpart: Recursive Partitioning and Regression Trees."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=rpart'
        url: https://CRAN.R-project.org/package=rpart

    rpart.plot:
        type: 'software'
        author: Stephen Milborrow
        year: 2019
        title: "rpart.plot: Plot 'rpart' Models: An Enhanced Version of 'plot.rpart'"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=rpart.plot'
        url: https://CRAN.R-project.org/package=rpart.plot

    gtsummary:
        type: 'software'
        author: Daniel D. Sjoberg, Margie Hannum, Karissa Whiting and Emily C. Zabor
        year: 2020
        title: "gtsummary: Presentation-Ready Data Summary and Analytic Result Tables"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=gtsummary'
        url: https://CRAN.R-project.org/package=gtsummary

    rmngb:
        type: 'software'
        author: Antoine Filipovic Pierucci
        year: 2014
        title: "rmngb: Miscellaneous Collection of Functions for Medical Data Analysis"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=rmngb'
        url: https://CRAN.R-project.org/package=rmngb

    RVAideMemoire:
        type: 'software'
        author: Maxime Hervé
        year: 2020
        title: "RVAideMemoire: Testing and Plotting Procedures for Biostatistics"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=RVAideMemoire'
        url: https://CRAN.R-project.org/package=RVAideMemoire


    chisq.posthoc.test:
        type: 'software'
        author: Daniel Ebbert
        year: 2019
        title: "chisq.posthoc.test: A Post Hoc Analysis for Pearson's Chi-Squared Test for Count Data"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=chisq.posthoc.test'
        url: https://CRAN.R-project.org/package=chisq.posthoc.test



    easyalluvial:
        type: 'software'
        author: Bjoern Koneswarakantha
        year: 2019
        title: "easyalluvial: Generate Alluvial Plots with a Single Line of Code."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=easyalluvial'
        url: https://CRAN.R-project.org/package=easyalluvial


    parcats:
        type: 'software'
        author: Bjoern Koneswarakantha
        year: 2019
        title: "parcats: Interactive Parallel Categories Diagrams for 'easyalluvial'"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=parcats'
        url: https://CRAN.R-project.org/package=parcats


    plotROC:
        type: 'software'
        author: Michael C. Sachs
        year: 2017
        title: "plotROC: A Tool for Plotting ROC Curves.Journal of Statistical Software, Code Snippets, 79(2), 1-19. doi:10.18637/jss.v079.c02"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=plotROC'
        url: https://CRAN.R-project.org/package=plotROC


    RGraphGallery:
        type: 'website'
        author: Holtz Yan
        year: 2020
        title: "The R Graph Gallery"
        publisher: 'A website that displays hundreds of R charts https://www.r-graph-gallery.com'
        url: https://github.com/holtzy/R-graph-gallery


    hrbrthemes:
        type: 'software'
        author: Bob Rudis
        year: 2020
        title: "hrbrthemes: Additional Themes, Theme Components and Utilities for 'ggplot2'."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=hrbrthemes'
        url: https://CRAN.R-project.org/package=hrbrthemes


    retractcheck:
        type: 'software'
        author: Chris Hartgerink and Frederik Aust
        year: 2019
        title: "retractcheck: Retraction Scanner"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=retractcheck'
        url: https://CRAN.R-project.org/package=retractcheck


    RefManageR:
        type: 'software'
        author: McLean MW
        year: 2017
        title: 'RefManageR: Import and Manage BibTeX and BibLaTeX References in R. The Journal of Open Source Software.'
        doi: 10.21105/joss.00338
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=RefManageR'
        url: https://CRAN.R-project.org/package=RefManageR


    rcrossref:
        type: 'software'
        author: Scott Chamberlain and Hao Zhu and Najko Jahn and Carl Boettiger and Karthik Ram
        year: 2020
        title: "rcrossref: Client for Various 'CrossRef' 'APIs'"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=rcrossref'
        url: https://CRAN.R-project.org/package=rcrossref


    epiR:
        type: 'software'
        author: >-
            Mark Stevenson with contributions from Telmo Nunes,
            Cord Heuer, Jonathon Marshall, Javier Sanchez, Ron
            Thornton, Jeno Reiczigel, Jim Robison-Cox, Paola
            Sebastiani, Peter Solymos, Kazuki Yoshida, Geoff Jones,
            Sarah Pirikahu, Simon Firestone, Ryan Kyle, Johann
            Popp, Mathew Jay and Charles Reynard.
        year: 2020
        title: "epiR: Tools for the Analysis of Epidemiological Data."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=epiR'
        url: https://CRAN.R-project.org/package=epiR


    KMunicate:
        type: 'software'
        author: Alessandro Gasparini
        year: 2020
        title: "KMunicate: KMunicate-Style Kaplan–Meier Plots"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=KMunicate'
        url: https://CRAN.R-project.org/package=KMunicate


    KMunicate2:
        type: 'article'
        author: Morris TP, Jarvis CI, Cragg W, et al
        title: "Proposals on Kaplan–Meier plots in medical research and a survey of stakeholder views: KMunicate"
        year: 2019
        publisher: 'BMJ Open 2019;9:e030215.'
        doi: 10.1136/bmjopen-2019-030215
        url: https://bmjopen.bmj.com/content/9/9/e030215


    Fagan:
        type: 'software'
        author: Adam Chekroud
        title: "nomogrammer: Fagan's nomograms with ggplot2"
        publisher: 'GitHub'
        year: 2020
        url: https://github.com/achekroud/nomogrammer


    Fagan2:
        type: 'article'
        author:
        title: 'StATS: What is a Fagan nomogram?'
        publisher: 'website'
        year: 2020
        url: http://www.pmean.com/definitions/fagan.htm


    benford.analysis:
        type: 'software'
        author: Carlos Cinelli
        year: 2020
        title: "benford.analysis: Benford Analysis for Data Validation and Forensic Analytics"
        publisher: '[R package]. Retrieved from http://github.com/carloscinelli/benford.analysis'
        url: http://github.com/carloscinelli/benford.analysis


    vtree:
        type: 'software'
        author: Nick Barrowman
        year: 2020
        title: "vtree: Display Information About Nested Subsets of a Data Frame"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=vtree'
        url: https://CRAN.R-project.org/package=vtree


    PathologyKappa:
        type: 'article'
        title: Pathologists should probably forget about kappa. Percent agreement, diagnostic specificity and related metrics provide more clinically applicable measures of interobserver variability
        year: 2020
        author:
        publisher: Annals of Diagnostic Pathology
        volume: 47
        url: https://www.sciencedirect.com/science/article/abs/pii/S1092913420301040


    DiagnosticTests:
        type: 'article'
        title: The Interpretation of SARS-CoV-2 Diagnostic Tests
        year: 2020
        author: Stites EC, Wilen CB.
        publisher:  Med (N Y).
        doi: 10.1016/j.medj.2020.08.001
        url: https://www.cell.com/med/fulltext/S2666-6340(20)30016-7

    dichotomizing:
        type: 'article'
        title: 'Dichotomizing continuous predictors in multiple regression: a bad idea.'
        year: 2006
        author: Royston, P., Altman, D.G. and Sauerbrei, W.
        publisher:  Statist. Med.
        volume: 25
        pages: 127-141
        doi: 10.1002/sim.2331
        url: https://onlinelibrary.wiley.com/doi/abs/10.1002/sim.2331

    bbccookbook:
        type: 'article'
        title: 'BBC Visual and Data Journalism cookbook for R graphics'
        year: 2019
        author: BBC data team
        url: https://bbc.github.io/rcookbook/

    bbplot:
        type: 'software'
        author: Nassos Stylianou and Will william.dahlgreen@bbc.co.uk Dahlgreen and Robert robert.cuffe@bbc.co.uk Cuffe and Tom Calver and Ransome Mpini
        year: 2020
        title: "bbplot: MAKING GGPLOT GRAPHICS IN BBC NEWS STYLE"
        publisher: '[R package]. Retrieved from https://github.com/bbc/bbplot'
        url: https://github.com/bbc/bbplot

    ClinicoPathJamoviModule:
        type: 'software'
        author: Serdar Balci
        year: 2022
        title: "ClinicoPath jamovi Module doi:10.5281/zenodo.3997188"
        publisher: '[R package]. Retrieved from https://github.com/sbalci/ClinicoPathJamoviModule'
        doi: 10.17605/OSF.IO/9SZUD
        url: https://www.serdarbalci.com/ClinicoPathJamoviModule/


    sensspecwiki:
        type: 'webpage'
        author: "Wikipedia contributors"
        title: "Sensitivity and specificity --- Wikipedia, The Free Encyclopedia"
        year: "2022"
        url: https://en.wikipedia.org/w/index.php?title=Sensitivity_and_specificity&oldid=1077556477
        note: "[Online; accessed 3-April-2022]"


    kappaSize:
        type: 'software'
        author: Michael A Rotondi
        year: 2022
        title: "kappaSize: Sample Size Estimation Functions for Studies of Interobserver Agreement"
        publisher: '[R package]. Retrieved from https://cran.r-project.org/web/packages/kappaSize/'
        url: https://cran.r-project.org/web/packages/kappaSize/


...


File: jamovi\agreement.a.yaml
--------------------------------------------------
Content of jamovi\agreement.a.yaml:
---
name:  agreement
title: Interrater Reliability
menuGroup: meddecide
menuSubgroup: Agreement
version: '1.0.0'
jas: '1.2'

description:
    main: Function for Interrater Reliability.
    R:
        dontrun: true
        usage: |
            # example will be added


options:
    - name: data
      type: Data
      description:
          R: >
            The data as a data frame. The data should be in long format, where each row is a unique observation.

    - name: vars
      title: Raters
      type: Variables
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]
      description:
          R: >
            A string naming the variable from `data` that contains the
            diagnosis given by the observer, variable can be categorical or ordinal.


    - name: sft
      title: Frequency Tables
      type: Bool
      default: false
      description:
          R: >
            Boolean selection whether to show frequency table. Default is 'false'. If 'true', the function will show
            frequency table for each observer.


    - name: wght
      title: Weighted Kappa (Ordinal Variables only)
      type: List
      options:
        - title: Unweighted
          name: unweighted
        - title: Squared
          name: squared
        - title: Equal/Linear
          name: equal
      default: unweighted
      description:
          R: >
            A list for the argument weight (wght), for weighted kappa analysis. Default is 'unweighted'.
            'squared' or 'equal' should be selected only with ordinal variables. The function gives error if the variable type
            is not ordinal. The default is 'unweighted'.

    - name: exct
      title: Exact Kappa (>=3 Variables)
      type: Bool
      default: false
      description:
          R: >
            Boolean selection whether to use exact kappa. Effects only more than 3 observers. Default is 'false'.


...


File: jamovi\agreement.r.yaml
--------------------------------------------------
Content of jamovi\agreement.r.yaml:
---
name:  agreement
title: Interrater Reliability
jrs:   '1.1'

items:

    # - name:  todo
    #   title: To Do
    #   type:  Html
    #   clearWith:
    #       - vars

    # - name: result_cohen
    #   title: 'result_cohen'
    #   type: Preformatted
    #   clearWith:
    #       - vars
    #       - wght
    #       - exct


    # - name:  ka
    #   title: Cohen's Kappa for 2 Raters
    #   type: Table
    #   rows:  1
    #   columns:
    #     - name: weights
    #       type: text
    #     - name: kappa
    #       type: number
    #     - name: upper_CI
    #       type: number
    #     - name: lower_CI
    #       type: number
    #     - name: p
    #       type: number
    #       format: zto,pvalue


    # - name:  text1
    #   title: Agreement
    #   type:  Preformatted
    #   clearWith:
    #       - vars
    #       - wght
    #       - exct

    # - name:  text2
    #   title: Interrater Reliability
    #   type:  Preformatted
    #   clearWith:
    #       - vars
    #       - wght
    #       - exct

    - name:  irrtable
      title: 'Interrater Reliability'
      type: Table
      swapRowsColumns: true
      rows:  1
      columns:
        - name: method
          title: 'Method'
          type: text
        - name: subjects
          title: 'Subjects'
          type: integer
        - name: raters
          title: 'Raters'
          type: integer
        - name: peragree
          title: 'Agreement %'
          type: integer
        - name: kappa
          title: 'Kappa'
          type: number
        - name: z
          title: 'z'
          type: number
        - name: p
          title: 'p-value'
          type: number
          format: zto,pvalue
      clearWith:
          - vars
          - wght
          - exct


    - name:  text2
      title: 'Table'
      type:  Html
      visible: (sft)
      clearWith:
          - vars
          - wght
          - exct


    - name:  text
      title: 'Table'
      type:  Preformatted
      visible: (sft)
      clearWith:
          - vars
          - wght
          - exct





    # - name:  freqtable
    #   title: 'Frequency Table'
    #   type: Table
    #   columns:
    #     - name: values
    #       title: 'Values'
    #       type: text
    #   clearWith:
    #       - vars
    #       - wght
    #       - exct







refs:
    - irr
    - PathologyKappa
    - ClinicoPathJamoviModule


...


File: jamovi\agreement.u.yaml
--------------------------------------------------
Content of jamovi\agreement.u.yaml:
title: Interrater Reliability
name: agreement
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Raters
        children:
          - type: VariablesListBox
            name: vars
            isTarget: true
            # maxItemCount: 5

  - type: Label
    label: Table
    children:
      - type: LayoutBox
        margin: large
        children:
          - type: CheckBox
            name: sft
  - type: Label
    label: Tests
    children:
      - type: LayoutBox
        margin: large
        children:
          - type: CheckBox
            name: exct
          - type: ComboBox
            name: wght


File: jamovi\decision.a.yaml
--------------------------------------------------
Content of jamovi\decision.a.yaml:
---
name:  decision
title: Medical Decision
menuGroup: meddecide
menuSubgroup: Decision
menuSubtitle: Sensitivity, Specificity, PPV, NPV, ...
version: '1.0.0'
jas: '1.2'

description:
    main: >
        Function for Medical Decision Analysis. Sensitivity, specificity, positive predictive value,
        negative predictive value.
    R:
        dontrun: true
        usage: |
            # example will be added


options:
    - name: data
      type: Data
      description:
          R: The data as a data frame. The data frame should contain the variables specified in the 'variables' option.


    - name: gold
      title: Golden Standard
      type: Variable
      suggested: [ nominal ]
      permitted: [ factor ]
      description:
          ui: >
            The golden standard variable.
          R: >
            The golden standard variable.


    - name: goldPositive
      title: Positive Level
      type: Level
      variable: (gold)
      description:
          ui: >
            The positive level of the golden standard variable.
          R: >
            The positive level of the golden standard variable.

    - name: newtest
      title: New Test
      type: Variable
      suggested: [ nominal ]
      permitted: [ factor ]
      description:
          ui: >
            The new test variable.
          R: >
            The new test variable.

    - name: testPositive
      title: Positive Level
      type: Level
      variable: (newtest)
      description:
          ui: >
            The positive level of the new test variable.
          R: >
            The positive level of the new test variable.







    - name: pp
      title: Prior Probability (prevalence)
      type: Bool
      default: false
      description:
          R: >
            Boolean selection whether to show prior probability. Default is 'false'.

    - name: pprob
      title: Prior Probability (prevalence)
      type: Number
      default: 0.300
      min: 0.001
      max: 0.999
      description:
          ui: >
            Prior probability (disease prevalence in the community).
            Requires a value between 0.001 and 0.999, default 0.300.
          R: >
            Prior probability (disease prevalence in the community).
            Requires a value between 0.001 and 0.999, default 0.300.


    - name: od
      title: Original Data
      type: Bool
      default: false
      description:
          R: >
            Boolean selection whether to show frequency table. Default is 'false'.

    - name: fnote
      title: Footnotes
      type: Bool
      default: false
      description:
          R: >
            Boolean selection whether to show footnotes. Default is 'false'.

    - name: ci
      title: '95% CI'
      type: Bool
      default: false
      description:
          R: >
            Boolean selection whether to show 95% confidence intervals. Default is 'false'.


    - name: fagan
      title: 'Fagan Nomogram'
      type: Bool
      default: false
      description:
          R: >
            Boolean selection whether to show Fagan Nomogram. Default is 'false'.

    # - name: roc
    #   title: 'ROC Curve'
    #   type: Bool
    #   default: false
    #   description:
    #       R: >
    #         Boolean selection whether to show ROC curve. Default is 'false'.

    # - name: compare_tests
    #   title: 'Compare Multiple Tests'
    #   type: Bool
    #   default: false
    #   description:
    #       R: >
    #         Boolean selection whether to compare multiple tests. Default is 'false'.

    # - name: additional_test
    #   title: 'Additional Test'
    #   type: Variable
    #   suggested: [ nominal ]
    #   permitted: [ factor ]
    #   description:
    #       ui: >
    #         Additional tests to compare.
    #       R: >
    #         Additional tests to compare.


    # - name: additionaltestPositive
    #   title: Positive Level
    #   type: Level
    #   variable: (additional_test)
    #   description:
    #       ui: >
    #         The positive level of the new test variable.
    #       R: >
    #         The positive level of the new test variable.



...


File: jamovi\decision.r.yaml
--------------------------------------------------
Content of jamovi\decision.r.yaml:
---
name:  decision
title: Medical Decision
jrs:   '1.1'

items:

    # - name:  todo
    #   title: To Do
    #   type:  Html

    - name:  text1
      title: Original Data
      type:  Preformatted
      visible: (od)


    - name:  text2
      title: Original Data
      type:  Html
      visible: (od)


    # - name:  text2
    #   title: Original Data
    #   type:  Preformatted

    # - name:  text3
    #   title: Preformatted
    #   type:  Preformatted


    # - name:  text2
    #   title: Decision Tests
    #   type:  Preformatted
    #   refs: caret



    # - name:  origTable
    #   title: 'Original Table'
    #   type: Table
    #   rows: (newtest)
    #   columns:
    #     - name: goldPositive
    #       title: ''
    #       type: text
    #       content: ($key)





    - name:  cTable
      title: 'Recoded Data for Decision Test Statistics'
      type: Table
      rows: 0
      columns:
        - name: newtest
          title: ''
          type: text
        - name: GP
          title: 'Gold Positive'
          type: number
        - name: GN
          title: 'Gold Negative'
          type: number
        - name: Total
          title: 'Total'
          type: number


    # - name:  cTable2
    #   title: 'Recoded Data for Decision Test Statistics 2'
    #   type: Table
    #   rows: 0
    #   columns:
    #     - name: newtest
    #       title: ''
    #       type: text
    #     - name: GP
    #       title: 'Gold Positive'
    #       type: number
    #     - name: GN
    #       title: 'Gold Negative'
    #       type: number
    #     - name: Total
    #       title: 'Total'
    #       type: number





    # - name:  nTable2
    #   title: nTable2
    #   type: Preformatted




    - name:  nTable
      title: 'n'
      type: Table
      swapRowsColumns: true
      rows:  1
      columns:
        - name: tablename
          title: ''
          type: text
        - name: TotalPop
          title: 'Total'
          type: number
        - name: DiseaseP
          title: 'Diseased'
          type: number
        - name: DiseaseN
          title: 'Healthy'
          type: number
        - name: TestP
          title: 'Positive Tests'
          type: number
        - name: TestN
          title: 'Negative Tests'
          type: number
        - name: TestT
          title: 'True Test'
          type: number
        - name: TestW
          title: 'Wrong Test'
          type: number
      clearWith:
          - pp
          - pprob


    - name:  ratioTable
      title: ''
      type: Table
      swapRowsColumns: true
      rows:  1
      columns:
        - name: tablename
          title: ''
          type: text
        - name: Sens
          title: 'Sensitivity'
          type: number
          format: pc
        - name: Spec
          title: 'Specificity'
          type: number
          format: pc
        - name: AccurT
          title: 'Accuracy'
          type: number
          format: pc
        - name: PrevalenceD
          title: 'Prevalence'
          type: number
          format: pc
        - name: PPV
          title: 'Positive Predictive Value'
          type: number
          format: pc
        - name: NPV
          title: 'Negative Predictive Value'
          type: number
          format: pc
        - name: PostTestProbDisease
          title: 'Post-test Disease Probability'
          type: number
          format: pc
        - name: PostTestProbHealthy
          title: 'Post-test Health Probability'
          type: number
          format: pc
        - name: LRP
          title: Positive Likelihood Ratio
          type: number
          # format: pc
        - name: LRN
          title: Negative Likelihood Ratio
          type: number
          # format: pc
      clearWith:
          - pp
          - pprob


    # - name:  ratioTable2
    #   title: ''
    #   type: Table
    #   swapRowsColumns: true
    #   rows:  1
    #   columns:
    #     - name: tablename
    #       title: ''
    #       type: text
    #     - name: Sens
    #       title: 'Sensitivity'
    #       type: number
    #       format: pc
    #     - name: Spec
    #       title: 'Specificity'
    #       type: number
    #       format: pc
    #     - name: AccurT
    #       title: 'Accuracy'
    #       type: number
    #       format: pc
    #     - name: PrevalenceD
    #       title: 'Prevalence'
    #       type: number
    #       format: pc
    #     - name: PPV
    #       title: 'Positive Predictive Value'
    #       type: number
    #       format: pc
    #     - name: NPV
    #       title: 'Negative Predictive Value'
    #       type: number
    #       format: pc
    #     - name: PostTestProbDisease
    #       title: 'Post-test Disease Probability'
    #       type: number
    #       format: pc
    #     - name: PostTestProbHealthy
    #       title: 'Post-test Health Probability'
    #       type: number
    #       format: pc
    #     - name: LRP
    #       title: Positive Likelihood Ratio
    #       type: number
    #       # format: pc
    #     - name: LRN
    #       title: Negative Likelihood Ratio
    #       type: number
    #       # format: pc
    #   clearWith:
    #       - pp
    #       - pprob



    - name: epirTable_ratio
      title: 'EpiR Table Ratios'
      type: Table
      visible: (ci)
      rows: 0
      columns:
        - name: statsnames
          title: "Decision Statistics"
          type: text
        - name: est
          title: "Estimate"
          type: number
          format: pc
        - name: lower
          title: 'Lower'
          superTitle: '95% Confidence Interval'
          type: number
          format: pc
        - name: upper
          title: 'Upper'
          superTitle: '95% Confidence Interval'
          type: number
          format: pc
      clearWith:
          - pp
          - pprob
      refs: epiR


    - name: epirTable_number
      title: ''
      # title: 'EpiR Table Numbers'
      type: Table
      visible: (ci)
      rows: 0
      columns:
        - name: statsnames
          title: "Decision Statistics"
          type: text
        - name: est
          title: "Estimate"
          type: number
        - name: lower
          title: 'Lower'
          superTitle: '95% Confidence Interval'
          type: number
        - name: upper
          title: 'Upper'
          superTitle: '95% Confidence Interval'
          type: number
      clearWith:
          - pp
          - pprob
      refs: epiR

    # - name:  plotcontent
    #   title: plotcontent
    #   type:  Preformatted

    # - name:  text3
    #   title: Matrix Details
    #   type:  Preformatted


    # - name:  text4
    #   title: Medical Decision Deneme
    #   type:  Preformatted


    # - name:  text5
    #   title: Medical Decision epiR
    #   type:  Preformatted

    - name: plot1
      title: 'Fagan nomogram'
      type: Image
      width:  600
      height: 450
      renderFun: .plot1
      requiresData: true
      visible: (fagan)
      clearWith:
          - pp
          - pprob
          - fagan
      refs:
          - Fagan
          - Fagan2


    # - name: plot_roc
    #   title: 'ROC Curve'
    #   type: Image
    #   width: 600
    #   height: 450
    #   renderFun: .plot_roc
    #   requiresData: true
    #   visible: (roc)
    #   clearWith:
    #       - vars




refs:
    - DiagnosticTests
    - ClinicoPathJamoviModule


...



File: jamovi\decision.u.yaml
--------------------------------------------------
Content of jamovi\decision.u.yaml:
title: Medical Decision
name: decision
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Golden Standard
        children:
          - type: VariablesListBox
            name: gold
            maxItemCount: 1
            isTarget: true
          - type: LevelSelector
            name: goldPositive
            enable: (gold)
      - type: TargetLayoutBox
        label: New Test
        children:
          - type: VariablesListBox
            name: newtest
            maxItemCount: 1
            isTarget: true
          - type: LevelSelector
            name: testPositive
            enable: (newtest)
  - type: Label
    label: Table
    children:
      - type: LayoutBox
        margin: large
        children:
          - type: CheckBox
            name: od
          - type: CheckBox
            name: fnote
          - type: CheckBox
            name: ci
            enable: (!pp)
  - type: Label
    label: Prior Probability
    children:
      - type: CheckBox
        name: pp
        enable: (!ci)
      - type: TextBox
        name: pprob
        label: ''
        format: number
        enable: (!ci && pp)
  - type: Label
    label: Plots
    children:
      - type: CheckBox
        name: fagan
      # - type: CheckBox
      #   name: roc
  # - type: Label
  #   label: Test Comparison
  #   children:
  #     - type: CheckBox
  #       name: compare_tests
  #       label: Compare Multiple Tests
  # - type: VariableSupplier
  #   persistentItems: false
  #   stretchFactor: 1
  #   children:
  #     - type: TargetLayoutBox
  #       label: Additional Test
  #       children:
  #         - type: VariablesListBox
  #           name: additional_test
  #           maxItemCount: 1
  #           isTarget: true
  #         - type: LevelSelector
  #           name: additionaltestPositive
  #           enable: (additional_test)


File: jamovi\decisioncalculator.a.yaml
--------------------------------------------------
Content of jamovi\decisioncalculator.a.yaml:
---
name:  decisioncalculator
title: Medical Decision Calculator
menuGroup: meddecide
menuSubgroup: Decision
menuSubtitle: Sensitivity, Specificity, PPV, NPV, ...
version: '1.0.0'
jas: '1.2'

description:
    main: Function for Medical Decision Calculator.
    R:
        dontrun: true
        usage: |
            # example will be added


options:
    - name: TP
      title: 'True Positive ='
      type: Number
      default: 90

    - name: TN
      title: 'True Negative ='
      type: Number
      default: 80

    - name: FP
      title: 'False Positive ='
      type: Number
      default: 30

    - name: FN
      title: 'False Negative ='
      type: Number
      default: 20

    - name: pp
      title: Prior Probability (prevalence)
      type: Bool
      default: false



    - name: pprob
      title: Prior Probability (prevalence)
      type: Number
      default: 0.300
      min: 0.001
      max: 0.999
      description:
          ui: >
            Prior probability (disease prevalence in the community).
            Requires a value between 0.001 and 0.999, default 0.300.
          R: >
            Prior probability (disease prevalence in the community).
            Requires a value between 0.001 and 0.999, default 0.300.



    - name: fnote
      title: Show Footnote
      type: Bool
      default: false

    - name: ci
      title: 'Show 95% CI'
      type: Bool
      default: false


    - name: fagan
      title: 'Fagan Nomogram'
      type: Bool
      default: false


...


File: jamovi\decisioncalculator.r.yaml
--------------------------------------------------
Content of jamovi\decisioncalculator.r.yaml:
---
name:  decisioncalculator
title: Medical Decision Calculator
jrs:   '1.1'

items:

    # - name:  todo
    #   title: To Do
    #   type:  Html

    # - name:  text1
    #   title: Decision Calculator
    #   type:  Preformatted

    # - name:  text2
    #   title: Decision Calculator
    #   type:  Preformatted
    #   clearWith:
    #       - pp
    #       - pprob
    #       - fnote
    #   refs: caret


    - name:  cTable
      title: ''
      # title: 'Decision Test Statistics'
      type: Table
      rows: 0
      columns:
        - name: newtest
          title: ''
          type: text
        - name: GP
          title: 'Gold Positive'
          type: number
        - name: GN
          title: 'Gold Negative'
          type: number
        - name: Total
          title: 'Total'
          type: number


    - name:  nTable
      title: ''
      # title: 'Decision Test Statistics'
      type: Table
      swapRowsColumns: true
      rows:  1
      columns:
        - name: tablename
          title: ''
          type: text
        - name: TotalPop
          title: 'Total'
          type: number
        - name: DiseaseP
          title: 'Diseased'
          type: number
        - name: DiseaseN
          title: 'Healthy'
          type: number
        - name: TestP
          title: 'Positive Tests'
          type: number
        - name: TestN
          title: 'Negative Tests'
          type: number
        - name: TestT
          title: 'True Test'
          type: number
        - name: TestW
          title: 'Wrong Test'
          type: number
      clearWith:
          - pp
          - pprob


    - name:  ratioTable
      title: ''
      # title: 'Decision Test Statistics'
      type: Table
      swapRowsColumns: true
      rows:  1
      columns:
        - name: tablename
          title: ''
          type: text
        - name: Sens
          title: 'Sensitivity'
          type: number
          format: pc
        - name: Spec
          title: 'Specificity'
          type: number
          format: pc
        - name: AccurT
          title: 'Accuracy'
          type: number
          format: pc
        - name: PrevalenceD
          title: 'Prevalence'
          type: number
          format: pc
        - name: PPV
          title: 'Positive Predictive Value'
          type: number
          format: pc
        - name: NPV
          title: 'Negative Predictive Value'
          type: number
          format: pc
        - name: PostTestProbDisease
          title: 'Post-test Disease Probability'
          type: number
          format: pc
        - name: PostTestProbHealthy
          title: 'Post-test Health Probability'
          type: number
          format: pc
        - name: LRP
          title: Positive Likelihood Ratio
          type: number
          # format: pc
        - name: LRN
          title: Negative Likelihood Ratio
          type: number
          # format: pc
      clearWith:
          - pp
          - pprob



    # - name:  text3
    #   title: epiR
    #   type:  Preformatted
    #   clearWith:
    #       - pp
    #       - pprob
    #       - fnote
    #   refs: epiR


    # - name:  text4
    #   title: epiR Table Preformatted
    #   type:  Preformatted
    #   clearWith:
    #       - pp
    #       - pprob
    #       - fnote
    #   refs: epiR


    - name: epirTable_ratio
      title: ''
      type: Table
      visible: (ci)
      rows: 0
      columns:
        - name: statsnames
          title: "Decision Statistics"
          type: text
        - name: est
          title: "Estimate"
          type: number
          format: pc
        - name: lower
          title: 'Lower'
          superTitle: '95% Confidence Interval'
          type: number
          format: pc
        - name: upper
          title: 'Upper'
          superTitle: '95% Confidence Interval'
          type: number
          format: pc
      clearWith:
          - pp
          - pprob
      refs:
          - epiR
          - sensspecwiki


    - name: epirTable_number
      title: ''
      visible: (ci)
      type: Table
      rows: 0
      columns:
        - name: statsnames
          title: "Decision Statistics"
          type: text
        - name: est
          title: "Estimate"
          type: number
        - name: lower
          title: 'Lower'
          superTitle: '95% Confidence Interval'
          type: number
        - name: upper
          title: 'Upper'
          superTitle: '95% Confidence Interval'
          type: number
      clearWith:
          - pp
          - pprob
      refs:
          - epiR
          - sensspecwiki


    # - name:  table1
    #   title: 'Table 1'
    #   type:  Html

    - name: plot1
      title: 'Fagan nomogram'
      type: Image
      width:  600
      height: 450
      renderFun: .plot1
      requiresData: true
      visible: (fagan)
      clearWith:
          - pp
          - pprob
          - fagan
      refs:
          - Fagan
          - Fagan2
          - sensspecwiki


    # - name: plot2
    #   title: 'Fagan nomogram'
    #   type: Image
    #   width:  600
    #   height: 450
    #   renderFun: .plot2
    #   requiresData: true
    #   visible: (fagan)
    #   clearWith:
    #       - pp
    #       - pprob
    #       - fagan
    #   refs:
    #       - Fagan
    #       - Fagan2

refs:
    - DiagnosticTests
    - sensspecwiki
    - ClinicoPathJamoviModule


...


File: jamovi\decisioncalculator.u.yaml
--------------------------------------------------
Content of jamovi\decisioncalculator.u.yaml:
title: Medical Decision Calculator
name: decisioncalculator
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: Label
    label: Number of Cases
    children:
      - type: LayoutBox
        style: inline
        children:
          - type: LayoutBox
            margin: large
            cell:
              row: 1
              column: 1
            children:
              - type: TextBox
                name: TP
                format: number
              - type: TextBox
                name: FN
                format: number
          - type: LayoutBox
            margin: large
            cell:
              row: 1
              column: 2
            children:
              - type: TextBox
                name: FP
                format: number
              - type: TextBox
                name: TN
                format: number
  - type: Label
    label: Table
    children:
      - type: LayoutBox
        margin: large
        children:
          - type: CheckBox
            name: fnote
          - type: CheckBox
            name: ci
            enable: (!pp)
  - type: Label
    label: Prior Probability
    children:
      - type: CheckBox
        name: pp
        enable: (!ci)
      - type: TextBox
        name: pprob
        label: ''
        format: number
        enable: (!ci && pp)
  - type: Label
    label: Plots
    children:
      - type: CheckBox
        name: fagan



File: jamovi\kappasizeci.a.yaml
--------------------------------------------------
Content of jamovi\kappasizeci.a.yaml:
---
name:  kappaSizeCI
title: Confidence Interval Approach for the Number of Subjects Required
menuGroup: meddecide
menuSubgroup: Power Analysis
menuSubtitle: Find sample size based on Kappa confidence
version: '1.0.0'
jas: '1.2'


description:
    main: >
        Power Analysis for Interobserver Agreement Analysis.
    R:
        dontrun: true
        usage: |
            # example will be added

options:
    - name: outcome
      title: Number of outcome level
      type: List
      options:
        - "2"
        - "3"
        - "4"
        - "5"
      default: "2"
      description:
          ui: >
            Number of outcome level.
          R: >
            Number of outcome level.


    # - name: outcome
    #   title: Number of outcome level
    #   type: List
    #   options:
    #   - name: "2"
    #     title: "2"
    #   - name: "3"
    #     title: "3"
    #   - name: "4"
    #     title: "4"
    #   - name: "5"
    #     title: "5"
    #   default: "2"
    #
    #   u.yaml
    #
    # children:
    #   - type: Label
    #     label: Number of outcome level
    #     children:
    #       - type: RadioButton
    #         name: outcome_2
    #         optionName: outcome
    #         optionPart: "2"
    #         label: "2"
    #       - type: RadioButton
    #         name: outcome_3
    #         optionName: outcome
    #         optionPart: "3"
    #         label: "3"
    #       - type: RadioButton
    #         name: outcome_4
    #         optionName: outcome
    #         optionPart: "4"
    #         label: "4"
    #       - type: RadioButton
    #         name: outcome_5
    #         optionName: outcome
    #         optionPart: "5"
    #         label: "5"


    - name: kappa0
      title: kappa0
      type: Number
      default: 0.60
      min: 0.01
      max: 0.99
      description:
          ui: >
            The null hypothesis value of kappa.
          R: >
            The null hypothesis value of kappa.

    - name: kappaL
      title: kappaL
      type: Number
      default: 0.40
      min: 0.01
      max: 0.99
      description:
          ui: >
            The lower limit of the kappa.
          R: >
            The lower limit of the kappa.

    - name: kappaU
      title: kappaU
      type: Number
      default: 0.80
      min: 0.01
      max: 0.99
      description:
          ui: >
            The upper limit of the kappa.
          R: >
            The upper limit of the kappa.

    - name: props
      title: Proportions of outcome level
      type: String
      default: '0.20 , 0.80'
      description:
          ui: >
            Proportions of outcome level.
          R: >
            Proportions of outcome level.

    - name: raters
      title: raters
      type: List
      options:
        - "2"
        - "3"
        - "4"
        - "5"
      default: "2"
      description:
          ui: >
            Number of raters.
          R: >
            Number of raters.


    - name: alpha
      title: alpha
      type: Number
      default: 0.05
      min: 0.01
      max: 0.99
      description:
          ui: >
            The significance level.
          R: >
            The significance level.

...


File: jamovi\kappasizeci.r.yaml
--------------------------------------------------
Content of jamovi\kappasizeci.r.yaml:
---
name:  kappaSizeCI
title: Confidence Interval Approach for the Number of Subjects Required
jrs:   '1.1'

items:
    - name:  text1
      title: Analysis result
      type:  Preformatted

    - name:  text2
      title: Study Explanation
      type:  Preformatted

refs:
    - ClinicoPathJamoviModule
    - kappaSize



...


File: jamovi\kappasizeci.u.yaml
--------------------------------------------------
Content of jamovi\kappasizeci.u.yaml:
title: Confidence Interval Approach for the Number of Subjects Required
name: kappaSizeCI
jus: '3.0'
stage: 0
compilerMode: tame
children:

  - type: LayoutBox
    margin: large
    children:
      - type: LayoutBox
        margin: large
        cell:
          row: 1
          column: 1
        children:
          - type: Label
            label: Number of Outcome Level
            children:
              - type: LayoutBox
                margin: large
                children:
                  - type: ComboBox
                    name: outcome
                    label: Outcome Level
      - type: LayoutBox
        margin: large
        cell:
          row: 1
          column: 2
        children:
          - type: Label
            label: Number of Raters
            children:
              - type: LayoutBox
                margin: large
                children:
                  - type: ComboBox
                    name: raters
                    label: Raters


  - type: Label
    label: Kappa Levels
    children:
        - type: LayoutBox
          margin: large
          cell:
            row: 1
            column: 1
          children:
            - type: TextBox
              name: kappa0
              label: 'Preliminary value'
              format: number
        - type: LayoutBox
          margin: large
          cell:
            row: 1
            column: 2
          children:
            - type: TextBox
              name: kappaL
              label: 'Lower confidence limit'
              format: number
        - type: LayoutBox
          margin: large
          cell:
            row: 2
            column: 2
          children:
            - type: TextBox
              name: kappaU
              label: 'Upper confidence limit'
              format: number



  - type: Label
    label: "Proportions of Each Outcome Level"
    children:
      - type: LayoutBox
        margin: large
        stretchFactor: 2
        fitToGrid: true
        children:
          - type: TextBox
            name: props
            label: ''
            format: string
            stretchFactor: 2
            fitToGrid: true


  - type: Label
    label: "Alpha"
    children:
        - type: LayoutBox
          margin: large
          children:
            - type: LayoutBox
              margin: large
              children:
                - type: TextBox
                  name: alpha
                  label: 'Alpha'
                  format: number


File: jamovi\kappasizefixedn.a.yaml
--------------------------------------------------
Content of jamovi\kappasizefixedn.a.yaml:
---
name:  kappaSizeFixedN
title: Lowest Expected Value for a fixed sample size
menuGroup: meddecide
menuSubgroup: Power Analysis
menuSubtitle: Find lower Kappa based on sample size
version: '1.0.0'
jas: '1.2'

description:
    main: >
        Lowest Expected Value for a fixed sample size.
    R:
        dontrun: true
        usage: |
            # example will be added

options:
    - name: outcome
      title: Number of outcome level
      type: List
      options:
        - "2"
        - "3"
        - "4"
        - "5"
      default: "2"
      description:
          ui: >
              Number of outcome level.
          R: >
              Number of outcome level.


    - name: kappa0
      title: kappa0
      type: Number
      default: 0.40
      min: 0.01
      max: 0.99
      description:
          ui: >
              Expected value of kappa.
          R: >
              Expected value of kappa.

    - name: props
      title: Proportions of outcome level
      type: String
      default: '0.20 , 0.80'
      description:
          ui: >
              Proportions of outcome level.
          R: >
              Proportions of outcome level.


    - name: raters
      title: raters
      type: List
      options:
        - "2"
        - "3"
        - "4"
        - "5"
      default: "2"
      description:
          ui: >
              Number of raters.
          R: >
              Number of raters.


    - name: alpha
      title: alpha
      type: Number
      default: 0.05
      min: 0.01
      max: 0.99
      description:
          ui: >
              Significance level.
          R: >
              Significance level.

    - name: n
      title: N
      type: Number
      default: 100
      description:
          ui: >
              Sample size.
          R: >
              Sample size.

...


File: jamovi\kappasizefixedn.r.yaml
--------------------------------------------------
Content of jamovi\kappasizefixedn.r.yaml:
---
name:  kappaSizeFixedN
title: Lowest Expected Value for a fixed sample size
jrs:   '1.1'

items:
    - name:  text1
      title: Analysis result
      type:  Preformatted

    - name:  text2
      title: Study Explanation
      type:  Preformatted

refs:
    - ClinicoPathJamoviModule
    - kappaSize


...


File: jamovi\kappasizefixedn.u.yaml
--------------------------------------------------
Content of jamovi\kappasizefixedn.u.yaml:
title: Lowest Expected Value for a fixed sample size
name: kappaSizeFixedN
jus: '3.0'
stage: 0
compilerMode: tame
children:

  - type: LayoutBox
    margin: large
    children:
      - type: LayoutBox
        margin: large
        cell:
          row: 1
          column: 1
        children:
          - type: Label
            label: Number of Outcome Level
            children:
              - type: LayoutBox
                margin: large
                children:
                  - type: ComboBox
                    name: outcome
                    label: Outcome Level
      - type: LayoutBox
        margin: large
        cell:
          row: 1
          column: 2
        children:
          - type: Label
            label: Number of Raters
            children:
              - type: LayoutBox
                margin: large
                children:
                  - type: ComboBox
                    name: raters
                    label: Raters

      - type: LayoutBox
        margin: large
        cell:
          row: 1
          column: 3
        children:
          - type: Label
            label: Number of Subjects
            children:
              - type: LayoutBox
                margin: large
                children:
                  - type: TextBox
                    name: 'n'
                    format: number




  - type: Label
    label: "Kappa Level"
    children:
      - type: LayoutBox
        margin: large
        children:
          - type: TextBox
            name: kappa0
            label: 'Preliminary value'
            format: number



  - type: Label
    label: "Proportions of Each Outcome Level"
    children:
      - type: LayoutBox
        margin: large
        stretchFactor: 2
        fitToGrid: true
        children:
          - type: TextBox
            name: props
            label: ''
            format: string
            stretchFactor: 2
            fitToGrid: true



  - type: Label
    label: "Alpha"
    children:
        - type: LayoutBox
          margin: large
          children:
            - type: LayoutBox
              margin: large
              children:
                - type: TextBox
                  name: alpha
                  label: 'Alpha'
                  format: number





File: jamovi\kappasizepower.a.yaml
--------------------------------------------------
Content of jamovi\kappasizepower.a.yaml:
---
name:  kappaSizePower
title: Power Approach for the Number of Subjects Required
menuGroup: meddecide
menuSubgroup: Power Analysis
menuSubtitle: Find sample size based on power
version: '1.0.0'
jas: '1.2'

description:
    main: >
        Power Analysis for Interobserver Agreement Analysis.
    R:
        dontrun: true
        usage: |
            # example will be added

options:
    - name: outcome
      title: Number of outcome level
      type: List
      options:
        - "2"
        - "3"
        - "4"
        - "5"
      default: "2"
      description:
          ui: >
            Number of outcome level.
          R: >
            Number of outcome level.


    - name: kappa0
      title: kappa0
      type: Number
      default: 0.40
      min: 0.01
      max: 0.99
      description:
          ui: >
            Expected value of kappa.
          R: >
            Expected value of kappa.

    - name: kappa1
      title: kappa1
      type: Number
      default: 0.60
      min: 0.01
      max: 0.99
      description:
          ui: >
            Expected value of kappa.
          R: >
            Expected value of kappa.

    - name: props
      title: Proportions of outcome level
      type: String
      default: '0.20 , 0.80'
      description:
          ui: >
            Proportions of outcome level.
          R: >
            Proportions of outcome level.

    - name: raters
      title: raters
      type: List
      options:
        - "2"
        - "3"
        - "4"
        - "5"
      default: "2"
      description:
          ui: >
            Number of raters.
          R: >
            Number of raters.

    - name: alpha
      title: alpha
      type: Number
      default: 0.05
      min: 0.01
      max: 0.99
      description:
          ui: >
            Significance level.
          R: >
            Significance level.

    - name: power
      title: power
      type: Number
      default: 0.80
      min: 0.01
      max: 0.99
      description:
          ui: >
            Power.
          R: >
            Power.

...


File: jamovi\kappasizepower.r.yaml
--------------------------------------------------
Content of jamovi\kappasizepower.r.yaml:
---
name:  kappaSizePower
title: Power Approach for the Number of Subjects Required
jrs:   '1.1'

items:
    - name:  text1
      title: Analysis result
      type:  Preformatted

    - name:  text2
      title: Study Explanation
      type:  Preformatted

refs:
    - ClinicoPathJamoviModule
    - kappaSize

...


File: jamovi\kappasizepower.u.yaml
--------------------------------------------------
Content of jamovi\kappasizepower.u.yaml:
title: Power Approach for the Number of Subjects Required
name: kappaSizePower
jus: '3.0'
stage: 0
compilerMode: tame
children:

  - type: LayoutBox
    margin: large
    children:
      - type: LayoutBox
        margin: large
        cell:
          row: 1
          column: 1
        children:
          - type: Label
            label: Number of Outcome Level
            children:
              - type: LayoutBox
                margin: large
                children:
                  - type: ComboBox
                    name: outcome
                    label: Outcome Level
      - type: LayoutBox
        margin: large
        cell:
          row: 1
          column: 2
        children:
          - type: Label
            label: Number of Raters
            children:
              - type: LayoutBox
                margin: large
                children:
                  - type: ComboBox
                    name: raters
                    label: Raters




  - type: Label
    label: Kappa Levels
    children:
        - type: LayoutBox
          margin: large
          cell:
            row: 1
            column: 1
          children:
            - type: TextBox
              name: kappa0
              label: 'Null Hypothesis'
              format: number
        - type: LayoutBox
          margin: large
          cell:
            row: 1
            column: 2
          children:
            - type: TextBox
              name: kappa1
              label: 'Alternative Hypothesis'
              format: number

  - type: Label
    label: "Proportions of Each Outcome Level"
    children:
      - type: LayoutBox
        margin: large
        stretchFactor: 2
        fitToGrid: true
        children:
          - type: TextBox
            name: props
            label: ''
            format: string
            stretchFactor: 2
            fitToGrid: true



  - type: Label
    label: "Alpha and Power"
    children:
        - type: LayoutBox
          margin: large
          cell:
            row: 1
            column: 1
          children:
            - type: LayoutBox
              margin: large
              children:
                - type: TextBox
                  name: alpha
                  label: 'Alpha'
                  format: number
        - type: LayoutBox
          margin: large
          cell:
            row: 1
            column: 2
          children:
            - type: LayoutBox
              margin: large
              children:
                - type: TextBox
                  name: power
                  label: 'Power'
                  format: number


File: R\00jmv.R
--------------------------------------------------
Content of R\00jmv.R:

# This file is automatically generated, you probably don't want to edit this

.jmvrefs <- list(
    `emmeans`=list(
        `type`="software", 
        `author`="Lenth, R.", 
        `year`=2018, 
        `title`="emmeans: Estimated Marginal Means, aka Least-Squares Means", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=emmeans", 
        `url`="https://CRAN.R-project.org/package=emmeans"), 
    `afex`=list(
        `type`="software", 
        `author`="Singmann, H.", 
        `year`=2018, 
        `title`="afex: Analysis of Factorial Experiments", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=afex", 
        `url`="https://CRAN.R-project.org/package=afex"), 
    `R`=list(
        `type`="software", 
        `author`="R Core Team", 
        `year`=2018, 
        `title`="A Language and Envionment for Statistical Computing", 
        `publisher`="[Computer software]. Retrieved from https://CRAN.R-project.org/", 
        `url`="https://CRAN.R-project.org/"), 
    `BF`=list(
        `type`="software", 
        `author`="Morey, R. D., & Rouder, J. N.", 
        `year`=2018, 
        `title`="BayesFactor: Computation of Bayes Factors for Common Designs", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=BayesFactor", 
        `url`="https://CRAN.R-project.org/package=BayesFactor"), 
    `btt`=list(
        `type`="article", 
        `author`="Rouder, J. N., Speckman, P. L., Sun, D., Morey, R. D., & Iverson, G.", 
        `year`=2009, 
        `title`="Bayesian t tests for accepting and rejecting the null hypothesis", 
        `publisher`="Psychonomic Bulletin & Review", 
        `volume`=16, 
        `pages`="225-237"), 
    `car`=list(
        `type`="software", 
        `author`="Fox, J., & Weisberg, S.", 
        `year`=2018, 
        `title`="car: Companion to Applied Regression", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=car", 
        `url`="https://CRAN.R-project.org/package=car"), 
    `ggplot2`=list(
        `type`="software", 
        `author`="Wickham, H., Chang, W., Henry, L., Pedersen, T. L., Takahashi, K., Wilke, C., Woo, K., & RStudio", 
        `year`=2018, 
        `title`="ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ggplot2", 
        `url`="https://CRAN.R-project.org/package=ggplot2"), 
    `ggridges`=list(
        `type`="software", 
        `author`="Wilke, C., & RStudio", 
        `year`=2018, 
        `title`="ggridges: Ridgeline Plots in ggplot2", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ggridges", 
        `url`="https://CRAN.R-project.org/package=ggridges"), 
    `mvnormtest`=list(
        `type`="software", 
        `author`="Jarek, S.", 
        `year`=2012, 
        `title`="mvnormtest: Normality test for multivariate variables", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=mvnormtest", 
        `url`="https://CRAN.R-project.org/package=mvnormtest"), 
    `PMCMR`=list(
        `type`="software", 
        `author`="Pohlert, T.", 
        `year`=2018, 
        `title`="PMCMR: Calculate Pairwise Multiple Comparisons of Mean Rank Sums", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=PMCMR", 
        `url`="https://CRAN.R-project.org/package=PMCMR"), 
    `ROCR`=list(
        `type`="software", 
        `author`="Sing, T., Sander, O., Beerenwinkel, N., & Lengauer, T.", 
        `year`=2015, 
        `title`="ROCR: Visualizing the Performance of Scoring Classifiers", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ROCR", 
        `url`="https://CRAN.R-project.org/package=ROCR"), 
    `nnet`=list(
        `type`="software", 
        `author`="Ripley, B., Venables W.", 
        `year`=2016, 
        `title`="nnet: Feed-Forward Neural Networks and Multinomial Log-Linear Models", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=nnet", 
        `url`="https://CRAN.R-project.org/package=nnet"), 
    `MASS`=list(
        `type`="software", 
        `author`="Ripley, B., Venables W., Bates, D. M., Hornik, K., Gebhardt, A., & Firth, D.", 
        `year`=2018, 
        `title`="MASS: Support Functions and Datasets for Venables and Ripley's MASS", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=MASS", 
        `url`="https://CRAN.R-project.org/package=MASS"), 
    `vcd`=list(
        `type`="software", 
        `author`="Meyer, D., Zeileis, A., Hornik, K., Gerber, F., & Friendly, M.", 
        `year`=2017, 
        `title`="vcd: Visualizing Categorical Data", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=vcd", 
        `url`="https://CRAN.R-project.org/package=vcd"), 
    `vcdExtra`=list(
        `type`="software", 
        `author`="Friendly M., Turner, H., Zeileis, A., Murdoch, D., & Firth, D.", 
        `year`=2017, 
        `title`="vcdExtra: 'vcd' Extensions and Additions", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=vcdExtra", 
        `url`="https://CRAN.R-project.org/package=vcdExtra"), 
    `exact2x2`=list(
        `type`="software", 
        `author`="Fay, M. P., Hunsberger, S. A., Nason, M., & Gabriel, E.", 
        `year`=2018, 
        `title`="exact2x2: Exact Tests and Confidence Intervals for 2x2 Tables", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=exact2x2", 
        `url`="https://CRAN.R-project.org/package=exact2x2"), 
    `psych`=list(
        `type`="software", 
        `author`="Revelle, W.", 
        `year`=2019, 
        `title`="psych: Procedures for Psychological, Psychometric, and Personality Research", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=psych", 
        `url`="https://CRAN.R-project.org/package=psych"), 
    `lavaan`=list(
        `type`="software", 
        `author`="Rosseel, Y., et al.", 
        `year`=2018, 
        `title`="lavaan: Latent Variable Analysis", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=lavaan", 
        `url`="https://CRAN.R-project.org/package=lavaan"), 
    `semPlot`=list(
        `type`="software", 
        `author`="Epskamp, S.", 
        `year`=2017, 
        `title`="semPlot: Path Diagrams and Visual Analysis of Various SEM Packages' Output", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=semPlot", 
        `url`="https://CRAN.R-project.org/package=semPlot"), 
    `ggstatsplot`=list(
        `type`="software", 
        `author`="Patil, I.", 
        `year`=2018, 
        `title`="ggstatsplot: 'ggplot2' Based Plots with Statistical Details", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ggstatsplot", 
        `url`="https://CRAN.R-project.org/package=ggstatsplot", 
        `doi`="10.5281/zenodo.2074621"), 
    `report`=list(
        `type`="software", 
        `author`="Makowski, Dominique, L\u00FCdecke, Daniel", 
        `year`=2019, 
        `title`="The report package for R: Ensuring the use of best practices for results reporting", 
        `publisher`="[R package]. Retrieved from https://github.com/easystats/report", 
        `url`="https://github.com/easystats/report"), 
    `arsenal`=list(
        `type`="software", 
        `author`="Heinzen, E Sinnwell, J Atkinson, E Gunderson, T Dougherty, G", 
        `year`=2018, 
        `title`="arsenal: An Arsenal of 'R' Functions for Large-Scale Statistical Summaries", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=arsenal", 
        `url`="https://CRAN.R-project.org/package=arsenal"), 
    `tangram`=list(
        `type`="software", 
        `author`="Garbett, S.", 
        `year`=2018, 
        `title`="tangram: The Grammar of Tables", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=tangram", 
        `url`="https://CRAN.R-project.org/package=tangram"), 
    `irr`=list(
        `type`="software", 
        `author`="Matthias Gamer, Jim Lemon, Ian Fellows, Puspendra Singh", 
        `year`=2019, 
        `title`="Various Coefficients of Interrater Reliability and Agreement.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=irr", 
        `url`="https://CRAN.R-project.org/package=irr"), 
    `tableone`=list(
        `type`="software", 
        `author`="Kazuki, Y.", 
        `year`=2019, 
        `title`="tableone: Create 'Table 1' to Describe Baseline Characteristics", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=tableone", 
        `url`="https://CRAN.R-project.org/package=tableone"), 
    `janitor`=list(
        `type`="software", 
        `author`="Firke, S.", 
        `year`=2019, 
        `title`="janitor: Simple Tools for Examining and Cleaning Dirty Data.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=janitor", 
        `url`="https://CRAN.R-project.org/package=janitor"), 
    `finalfit`=list(
        `type`="software", 
        `author`="Ewen Harrison and Tom Drake and Riinu Ots", 
        `year`=2019, 
        `title`="finalfit: Quickly Create Elegant Regression Results Tables and Plots when Modelling", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=finalfit", 
        `url`="https://CRAN.R-project.org/package=finalfit"), 
    `caret`=list(
        `type`="software", 
        `author`="Max Kuhn", 
        `year`=2020, 
        `title`="caret: Classification and Regression Training", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=caret", 
        `url`="https://CRAN.R-project.org/package=caret"), 
    `psycho`=list(
        `type`="software", 
        `author`="Makowski, D.", 
        `year`=2018, 
        `title`="The Psycho Package: An Efficient and Publishing-Oriented Workflow for Psychological Science. Journal of Open Source Software, 3(22), 470.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=psycho.R", 
        `url`="https://CRAN.R-project.org/package=psycho.R"), 
    `survival`=list(
        `type`="software", 
        `author`="Terry M Therneau, Thomas Lumley", 
        `year`=2019, 
        `title`="survival: Survival Analysis", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=survival", 
        `url`="https://CRAN.R-project.org/package=survival"), 
    `survminer`=list(
        `type`="software", 
        `author`="Alboukadel Kassambara and Marcin Kosinski and Przemyslaw Biecek", 
        `year`=2019, 
        `title`="survminer: Drawing Survival Curves using 'ggplot2'", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=survminer", 
        `url`="https://CRAN.R-project.org/package=survminer"), 
    `ggalluvial`=list(
        `type`="software", 
        `author`="Jason Cory Brunson", 
        `year`=2019, 
        `title`="ggalluvial: Alluvial Plots in 'ggplot2'.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ggalluvial", 
        `url`="https://CRAN.R-project.org/package=ggalluvial"), 
    `explore`=list(
        `type`="software", 
        `author`="Roland Krasser", 
        `year`=2020, 
        `title`="explore: Simplifies Exploratory Data Analysis.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=explore", 
        `url`="https://CRAN.R-project.org/package=explore"), 
    `FFTrees`=list(
        `type`="software", 
        `author`="Nathaniel Phillips, Hansjoerg Neth, Jan Woike and Wolfgang Gaissmaer", 
        `year`=2019, 
        `title`="FFTrees: Generate, Visualise, and Evaluate Fast-and-Frugal Decision Trees", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=FFTrees", 
        `url`="https://CRAN.R-project.org/package=FFTrees"), 
    `rpart`=list(
        `type`="software", 
        `author`="Terry Therneau and Beth Atkinson", 
        `year`=2019, 
        `title`="rpart: Recursive Partitioning and Regression Trees.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=rpart", 
        `url`="https://CRAN.R-project.org/package=rpart"), 
    `rpart.plot`=list(
        `type`="software", 
        `author`="Stephen Milborrow", 
        `year`=2019, 
        `title`="rpart.plot: Plot 'rpart' Models: An Enhanced Version of 'plot.rpart'", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=rpart.plot", 
        `url`="https://CRAN.R-project.org/package=rpart.plot"), 
    `gtsummary`=list(
        `type`="software", 
        `author`="Daniel D. Sjoberg, Margie Hannum, Karissa Whiting and Emily C. Zabor", 
        `year`=2020, 
        `title`="gtsummary: Presentation-Ready Data Summary and Analytic Result Tables", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=gtsummary", 
        `url`="https://CRAN.R-project.org/package=gtsummary"), 
    `rmngb`=list(
        `type`="software", 
        `author`="Antoine Filipovic Pierucci", 
        `year`=2014, 
        `title`="rmngb: Miscellaneous Collection of Functions for Medical Data Analysis", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=rmngb", 
        `url`="https://CRAN.R-project.org/package=rmngb"), 
    `RVAideMemoire`=list(
        `type`="software", 
        `author`="Maxime Herv\u00E9", 
        `year`=2020, 
        `title`="RVAideMemoire: Testing and Plotting Procedures for Biostatistics", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=RVAideMemoire", 
        `url`="https://CRAN.R-project.org/package=RVAideMemoire"), 
    `chisq.posthoc.test`=list(
        `type`="software", 
        `author`="Daniel Ebbert", 
        `year`=2019, 
        `title`="chisq.posthoc.test: A Post Hoc Analysis for Pearson's Chi-Squared Test for Count Data", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=chisq.posthoc.test", 
        `url`="https://CRAN.R-project.org/package=chisq.posthoc.test"), 
    `easyalluvial`=list(
        `type`="software", 
        `author`="Bjoern Koneswarakantha", 
        `year`=2019, 
        `title`="easyalluvial: Generate Alluvial Plots with a Single Line of Code.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=easyalluvial", 
        `url`="https://CRAN.R-project.org/package=easyalluvial"), 
    `parcats`=list(
        `type`="software", 
        `author`="Bjoern Koneswarakantha", 
        `year`=2019, 
        `title`="parcats: Interactive Parallel Categories Diagrams for 'easyalluvial'", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=parcats", 
        `url`="https://CRAN.R-project.org/package=parcats"), 
    `plotROC`=list(
        `type`="software", 
        `author`="Michael C. Sachs", 
        `year`=2017, 
        `title`="plotROC: A Tool for Plotting ROC Curves.Journal of Statistical Software, Code Snippets, 79(2), 1-19. doi:10.18637/jss.v079.c02", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=plotROC", 
        `url`="https://CRAN.R-project.org/package=plotROC"), 
    `RGraphGallery`=list(
        `type`="website", 
        `author`="Holtz Yan", 
        `year`=2020, 
        `title`="The R Graph Gallery", 
        `publisher`="A website that displays hundreds of R charts https://www.r-graph-gallery.com", 
        `url`="https://github.com/holtzy/R-graph-gallery"), 
    `hrbrthemes`=list(
        `type`="software", 
        `author`="Bob Rudis", 
        `year`=2020, 
        `title`="hrbrthemes: Additional Themes, Theme Components and Utilities for 'ggplot2'.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=hrbrthemes", 
        `url`="https://CRAN.R-project.org/package=hrbrthemes"), 
    `retractcheck`=list(
        `type`="software", 
        `author`="Chris Hartgerink and Frederik Aust", 
        `year`=2019, 
        `title`="retractcheck: Retraction Scanner", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=retractcheck", 
        `url`="https://CRAN.R-project.org/package=retractcheck"), 
    `RefManageR`=list(
        `type`="software", 
        `author`="McLean MW", 
        `year`=2017, 
        `title`="RefManageR: Import and Manage BibTeX and BibLaTeX References in R. The Journal of Open Source Software.", 
        `doi`="10.21105/joss.00338", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=RefManageR", 
        `url`="https://CRAN.R-project.org/package=RefManageR"), 
    `rcrossref`=list(
        `type`="software", 
        `author`="Scott Chamberlain and Hao Zhu and Najko Jahn and Carl Boettiger and Karthik Ram", 
        `year`=2020, 
        `title`="rcrossref: Client for Various 'CrossRef' 'APIs'", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=rcrossref", 
        `url`="https://CRAN.R-project.org/package=rcrossref"), 
    `epiR`=list(
        `type`="software", 
        `author`="Mark Stevenson with contributions from Telmo Nunes, Cord Heuer, Jonathon Marshall, Javier Sanchez, Ron Thornton, Jeno Reiczigel, Jim Robison-Cox, Paola Sebastiani, Peter Solymos, Kazuki Yoshida, Geoff Jones, Sarah Pirikahu, Simon Firestone, Ryan Kyle, Johann Popp, Mathew Jay and Charles Reynard.", 
        `year`=2020, 
        `title`="epiR: Tools for the Analysis of Epidemiological Data.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=epiR", 
        `url`="https://CRAN.R-project.org/package=epiR"), 
    `KMunicate`=list(
        `type`="software", 
        `author`="Alessandro Gasparini", 
        `year`=2020, 
        `title`="KMunicate: KMunicate-Style Kaplan\u2013Meier Plots", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=KMunicate", 
        `url`="https://CRAN.R-project.org/package=KMunicate"), 
    `KMunicate2`=list(
        `type`="article", 
        `author`="Morris TP, Jarvis CI, Cragg W, et al", 
        `title`="Proposals on Kaplan\u2013Meier plots in medical research and a survey of stakeholder views: KMunicate", 
        `year`=2019, 
        `publisher`="BMJ Open 2019;9:e030215.", 
        `doi`="10.1136/bmjopen-2019-030215", 
        `url`="https://bmjopen.bmj.com/content/9/9/e030215"), 
    `Fagan`=list(
        `type`="software", 
        `author`="Adam Chekroud", 
        `title`="nomogrammer: Fagan's nomograms with ggplot2", 
        `publisher`="GitHub", 
        `year`=2020, 
        `url`="https://github.com/achekroud/nomogrammer"), 
    `Fagan2`=list(
        `type`="article", 
        `author`=NULL, 
        `title`="StATS: What is a Fagan nomogram?", 
        `publisher`="website", 
        `year`=2020, 
        `url`="http://www.pmean.com/definitions/fagan.htm"), 
    `benford.analysis`=list(
        `type`="software", 
        `author`="Carlos Cinelli", 
        `year`=2020, 
        `title`="benford.analysis: Benford Analysis for Data Validation and Forensic Analytics", 
        `publisher`="[R package]. Retrieved from http://github.com/carloscinelli/benford.analysis", 
        `url`="http://github.com/carloscinelli/benford.analysis"), 
    `vtree`=list(
        `type`="software", 
        `author`="Nick Barrowman", 
        `year`=2020, 
        `title`="vtree: Display Information About Nested Subsets of a Data Frame", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=vtree", 
        `url`="https://CRAN.R-project.org/package=vtree"), 
    `PathologyKappa`=list(
        `type`="article", 
        `title`="Pathologists should probably forget about kappa. Percent agreement, diagnostic specificity and related metrics provide more clinically applicable measures of interobserver variability", 
        `year`=2020, 
        `author`=NULL, 
        `publisher`="Annals of Diagnostic Pathology", 
        `volume`=47, 
        `url`="https://www.sciencedirect.com/science/article/abs/pii/S1092913420301040"), 
    `DiagnosticTests`=list(
        `type`="article", 
        `title`="The Interpretation of SARS-CoV-2 Diagnostic Tests", 
        `year`=2020, 
        `author`="Stites EC, Wilen CB.", 
        `publisher`="Med (N Y).", 
        `doi`="10.1016/j.medj.2020.08.001", 
        `url`="https://www.cell.com/med/fulltext/S2666-6340(20)30016-7"), 
    `dichotomizing`=list(
        `type`="article", 
        `title`="Dichotomizing continuous predictors in multiple regression: a bad idea.", 
        `year`=2006, 
        `author`="Royston, P., Altman, D.G. and Sauerbrei, W.", 
        `publisher`="Statist. Med.", 
        `volume`=25, 
        `pages`="127-141", 
        `doi`="10.1002/sim.2331", 
        `url`="https://onlinelibrary.wiley.com/doi/abs/10.1002/sim.2331"), 
    `bbccookbook`=list(
        `type`="article", 
        `title`="BBC Visual and Data Journalism cookbook for R graphics", 
        `year`=2019, 
        `author`="BBC data team", 
        `url`="https://bbc.github.io/rcookbook/"), 
    `bbplot`=list(
        `type`="software", 
        `author`="Nassos Stylianou and Will william.dahlgreen@bbc.co.uk Dahlgreen and Robert robert.cuffe@bbc.co.uk Cuffe and Tom Calver and Ransome Mpini", 
        `year`=2020, 
        `title`="bbplot: MAKING GGPLOT GRAPHICS IN BBC NEWS STYLE", 
        `publisher`="[R package]. Retrieved from https://github.com/bbc/bbplot", 
        `url`="https://github.com/bbc/bbplot"), 
    `ClinicoPathJamoviModule`=list(
        `type`="software", 
        `author`="Serdar Balci", 
        `year`=2022, 
        `title`="ClinicoPath jamovi Module doi:10.5281/zenodo.3997188", 
        `publisher`="[R package]. Retrieved from https://github.com/sbalci/ClinicoPathJamoviModule", 
        `doi`="10.17605/OSF.IO/9SZUD", 
        `url`="https://www.serdarbalci.com/ClinicoPathJamoviModule/"), 
    `sensspecwiki`=list(
        `type`="webpage", 
        `author`="Wikipedia contributors", 
        `title`="Sensitivity and specificity --- Wikipedia, The Free Encyclopedia", 
        `year`="2022", 
        `url`="https://en.wikipedia.org/w/index.php?title=Sensitivity_and_specificity&oldid=1077556477", 
        `note`="[Online; accessed 3-April-2022]"), 
    `kappaSize`=list(
        `type`="software", 
        `author`="Michael A Rotondi", 
        `year`=2022, 
        `title`="kappaSize: Sample Size Estimation Functions for Studies of Interobserver Agreement", 
        `publisher`="[R package]. Retrieved from https://cran.r-project.org/web/packages/kappaSize/", 
        `url`="https://cran.r-project.org/web/packages/kappaSize/"))


File: R\agreement.b.R
--------------------------------------------------
Content of R\agreement.b.R:
#' @title Interrater Reliability Analysis
#' @return Table
#' @importFrom R6 R6Class
#' @import jmvcore
#' @import magrittr


# See
# \url{http://www.cookbook-r.com/Statistical_analysis/Inter-rater_reliability/#ordinal-data-weighted-kappa}


agreementClass <- if (requireNamespace("jmvcore")) R6::R6Class("agreementClass",
    inherit = agreementBase, private = list(.run = function() {



        # # Error Message ----
        #
        # if (nrow(self$data) == 0) stop("Data contains no (complete) rows")
        #
        # if ( (is.null(self$options$vars) || is.null(self$options$facs)) && is.null(self$options$target) ) {
        #     # ToDo Message ----
        #     todo <- "
        #         <br>Welcome to ClinicoPath
        #                   <br><br>
        #                   This tool will help you form an Alluvial Plots.
        #                   "
        #     html <- self$results$todo
        #     html$setContent(todo)
        #
        # } else {
        #     todo <- ""
        #     html <- self$results$todo
        #     html$setContent(todo)
        #
        #
        #
        # }









        # Data definition ----


        exct <- self$options$exct
        wght <- self$options$wght

        mydata <- self$data

        formula <- jmvcore::constructFormula(terms = self$options$vars)

        myvars <- jmvcore::decomposeFormula(formula = formula)

        myvars <- unlist(myvars)

        ratings <- mydata %>% dplyr::select(myvars)


        # psych::cohen.kappa ----

        # from https://github.com/kwongwh/Kappa
        # ratings2 <- mydata[c(self$options$vars)]
        #
        # result_cohen <- psych::cohen.kappa(x = ratings2)
        #
        # self$results$result_cohen$setContent(result_cohen)


        # irr.kappa <- kappa2(vars, weight = self$options$weights)
        # if(self$options$weights == "unweighted"){
        #     n = 1
        # } else {
        #     n = 2
        # }
        #
        # table <- self$results$ka
        #
        # table$setRow(rowNo=1, values=list(
        #     weights = self$options$weights,
        #     kappa=irr.kappa$value,
        #     upper_CI=results$confid[1,3],
        #     lower_CI=results$confid[1,1],
        #     p = irr.kappa$p.value
        # ))




        if (is.null(self$options$vars) || length(self$options$vars) < 2) {
            # No variables ----

            # todo <- glue::glue( 'This function ' )

            # self$results$todo$setContent(todo)

        } else {
            if (nrow(self$data) == 0) stop("Data contains no (complete) rows")


            # 2 & categorical ----

            if (length(self$options$vars) == 2) {
                # todo <- 'Cohen'

                # self$results$todo$setContent(todo)


                xorder <- unlist(lapply(ratings, is.ordered))

                if (wght %in% c("equal", "squared") && !all(xorder == TRUE)) stop("Use ordinal variables when using weight argument")

                if (exct == TRUE) stop("Use exact argument only >=3 variables")


                # irr::kappa2 ----

                result2 <- irr::kappa2(ratings = ratings, weight = wght)

                # self$results$text2$setContent(result2)


                # >=2 & categorical ----


            } else if (length(self$options$vars) >= 2) {
                # todo <- 'kappam.fleiss'

                # self$results$todo$setContent(todo)

                # irr::kappam.fleiss ----

                result2 <- irr::kappam.fleiss(ratings = ratings, exact = exct,
                  detail = TRUE)

                # self$results$text2$setContent(result2)

            }


            # irr::agree ----

            result <- table(ratings)

            self$results$text$setContent(result)



            result3 <- ratings %>%
                dplyr::group_by_all() %>%
                dplyr::count() %>%
                as.data.frame() %>%
                htmlTable::htmlTable()

            self$results$text2$setContent(result3)



            # freqtable <- self$results$freqtable
            #
            # data_frame <- result3
            # for (i in seq_along(data_frame[, 1, drop = T])) {
            #     freqtable$addRow(rowKey = i, values = c(data_frame[i,]))
            # }






            result1 <- irr::agree(ratings)

            # self$results$text1$setContent(result1[["value"]])

            if (result1[["value"]] > 100) {

                result1[["value"]] <- "Please check the data. It seems that observers do not agree on any cases"
            }


            # Table ----

            table2 <- self$results$irrtable



            table2$setRow(rowNo = 1, values = list(method = result2[["method"]],
                subjects = result1[["subjects"]], raters = result1[["raters"]],
                peragree = result1[["value"]], kappa = result2[["value"]],
                z = result2[["statistic"]], p = result2[["p.value"]]))

        }


    }))


File: R\agreement.h.R
--------------------------------------------------
Content of R\agreement.h.R:

# This file is automatically generated, you probably don't want to edit this

agreementOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "agreementOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            vars = NULL,
            sft = FALSE,
            wght = "unweighted",
            exct = FALSE, ...) {

            super$initialize(
                package="meddecide",
                name="agreement",
                requiresData=TRUE,
                ...)

            private$..vars <- jmvcore::OptionVariables$new(
                "vars",
                vars,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..sft <- jmvcore::OptionBool$new(
                "sft",
                sft,
                default=FALSE)
            private$..wght <- jmvcore::OptionList$new(
                "wght",
                wght,
                options=list(
                    "unweighted",
                    "squared",
                    "equal"),
                default="unweighted")
            private$..exct <- jmvcore::OptionBool$new(
                "exct",
                exct,
                default=FALSE)

            self$.addOption(private$..vars)
            self$.addOption(private$..sft)
            self$.addOption(private$..wght)
            self$.addOption(private$..exct)
        }),
    active = list(
        vars = function() private$..vars$value,
        sft = function() private$..sft$value,
        wght = function() private$..wght$value,
        exct = function() private$..exct$value),
    private = list(
        ..vars = NA,
        ..sft = NA,
        ..wght = NA,
        ..exct = NA)
)

agreementResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "agreementResults",
    inherit = jmvcore::Group,
    active = list(
        irrtable = function() private$.items[["irrtable"]],
        text2 = function() private$.items[["text2"]],
        text = function() private$.items[["text"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Interrater Reliability",
                refs=list(
                    "irr",
                    "PathologyKappa",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Table$new(
                options=options,
                name="irrtable",
                title="Interrater Reliability",
                swapRowsColumns=TRUE,
                rows=1,
                columns=list(
                    list(
                        `name`="method", 
                        `title`="Method", 
                        `type`="text"),
                    list(
                        `name`="subjects", 
                        `title`="Subjects", 
                        `type`="integer"),
                    list(
                        `name`="raters", 
                        `title`="Raters", 
                        `type`="integer"),
                    list(
                        `name`="peragree", 
                        `title`="Agreement %", 
                        `type`="integer"),
                    list(
                        `name`="kappa", 
                        `title`="Kappa", 
                        `type`="number"),
                    list(
                        `name`="z", 
                        `title`="z", 
                        `type`="number"),
                    list(
                        `name`="p", 
                        `title`="p-value", 
                        `type`="number", 
                        `format`="zto,pvalue")),
                clearWith=list(
                    "vars",
                    "wght",
                    "exct")))
            self$add(jmvcore::Html$new(
                options=options,
                name="text2",
                title="Table",
                visible="(sft)",
                clearWith=list(
                    "vars",
                    "wght",
                    "exct")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text",
                title="Table",
                visible="(sft)",
                clearWith=list(
                    "vars",
                    "wght",
                    "exct")))}))

agreementBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "agreementBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "meddecide",
                name = "agreement",
                version = c(1,0,0),
                options = options,
                results = agreementResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Interrater Reliability
#'
#' Function for Interrater Reliability.
#'
#' @examples
#' \donttest{
#' # example will be added
#'}
#' @param data The data as a data frame. The data should be in long format,
#'   where each row is a unique observation.
#' @param vars A string naming the variable from \code{data} that contains the
#'   diagnosis given by the observer, variable can be categorical or ordinal.
#' @param sft Boolean selection whether to show frequency table. Default is
#'   'false'. If 'true', the function will show frequency table for each
#'   observer.
#' @param wght A list for the argument weight (wght), for weighted kappa
#'   analysis. Default is 'unweighted'. 'squared' or 'equal' should be selected
#'   only with ordinal variables. The function gives error if the variable type
#'   is not ordinal. The default is 'unweighted'.
#' @param exct Boolean selection whether to use exact kappa. Effects only more
#'   than 3 observers. Default is 'false'.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$irrtable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$text2} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$text} \tab \tab \tab \tab \tab a preformatted \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$irrtable$asDF}
#'
#' \code{as.data.frame(results$irrtable)}
#'
#' @export
agreement <- function(
    data,
    vars,
    sft = FALSE,
    wght = "unweighted",
    exct = FALSE) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("agreement requires jmvcore to be installed (restart may be required)")

    if ( ! missing(vars)) vars <- jmvcore::resolveQuo(jmvcore::enquo(vars))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(vars), vars, NULL))

    for (v in vars) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- agreementOptions$new(
        vars = vars,
        sft = sft,
        wght = wght,
        exct = exct)

    analysis <- agreementClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\decision.b.R
--------------------------------------------------
Content of R\decision.b.R:
#' @title Medical Decision Analysis
#' @description Implements comprehensive medical decision analysis including:
#' @details This module provides tools for analyzing diagnostic test performance
#'   with options for various visualization methods and statistical comparisons.
#'   - Sensitivity, specificity and predictive values
#' @section Usage:
#'   1. Provide test and reference standard data
#'   2. Select analysis options
#'   3. View results in tables and plots
#' @importFrom R6 R6Class
#' @import jmvcore
#' @import ggplot2
#' @import boot
#' @importFrom stats quantile qnorm
#' @importFrom dplyr %>% mutate case_when
#' @importFrom forcats as_factor fct_relevel
#' @importFrom epiR epi.tests


#  @references
#    - DeLong et al. (1988) for ROC comparison
#   - Hanley & McNeil (1982) for AUC confidence intervals
#    - ROC curve analysis with confidence intervals
#    - Multiple test comparison
#    - Bootstrapped confidence intervals



decisionClass <- if (requireNamespace("jmvcore"))
    R6::R6Class(
        "decisionClass",
        inherit = decisionBase,
        private = list(
            .state = NULL,

            # Add state field for storing data

            # .cache = new.env(),

            # .get_cached = function(key) {
            #     if (exists(key, envir=private$.cache)) {
            #         return(get(key, envir=private$.cache))
            #     }
            #     return(NULL)
            # },

            # .set_cached = function(key, value) {
            #     assign(key, value, envir=private$.cache)
            # },

            .init = function() {
                cTable <- self$results$cTable

                cTable$addRow(rowKey = "Test Positive",
                              values = list(newtest = "Test Positive"))

                cTable$addRow(rowKey = "Test Negative",
                              values = list(newtest = "Test Negative"))

                cTable$addRow(rowKey = "Total", values = list(newtest = "Total"))




                # cTable2 <- self$results$cTable2
                # cTable2$addRow(rowKey = "Test Positive",
                #               values = list(newtest = "Test Positive"))
                # cTable2$addRow(rowKey = "Test Negative",
                #               values = list(newtest = "Test Negative"))
                # cTable2$addRow(rowKey = "Total", values = list(newtest = "Total"))

            }



            # Helper functions
            # .calculate_basic_metrics = function(TP, FP, TN, FN) {
            #     metrics <- list(
            #         total_pop = TP + TN + FP + FN,
            #         disease_pos = TP + FN,
            #         disease_neg = TN + FP,
            #         test_pos = TP + FP,
            #         test_neg = TN + FN,
            #         test_true = TP + TN,
            #         test_wrong = FP + FN,
            #         sensitivity = TP / (TP + FN),
            #         specificity = TN / (TN + FP),
            #         accuracy = (TP + TN) / (TP + TN + FP + FN),
            #         ppv = TP / (TP + FP),
            #         npv = TN / (TN + FN),
            #         plr = (TP / (TP + FN)) / (1 - (TN / (TN + FP))),
            #         nlr = (1 - (TP / (TP + FN))) / (TN / (TN + FP))
            #     )
            #     return(metrics)
            # },

            # .bootstrap_ci = function(data, index, metrics_func) {
            #     # Resample data
            #     resampled <- data[index,]
            #     # Calculate confusion matrix
            #     conf_mat <- table(resampled$test, resampled$gold)
            #     # Extract values
            #     TP <- conf_mat[2,2]
            #     FP <- conf_mat[2,1]
            #     TN <- conf_mat[1,1]
            #     FN <- conf_mat[1,2]
            #     # Calculate and return metrics
            #     metrics <- metrics_func(TP, FP, TN, FN)
            #     return(unlist(metrics))
            # },

            # .calculate_confidence_intervals = function(data, metrics, conf_level = 0.95) {
            #     # Perform bootstrap
            #     boot_results <- boot::boot(
            #         data = data,
            #         statistic = private$.bootstrap_ci,
            #         R = 2000,
            #         metrics_func = private$.calculate_basic_metrics
            #     )
            #
            #     # Calculate CIs for each metric
            #     ci_results <- list()
            #     metric_names <- names(metrics)
            #     for(i in seq_along(metrics)) {
            #         ci <- boot::boot.ci(boot_results,
            #                             type = "perc",
            #                             index = i,
            #                             conf = conf_level)
            #         ci_results[[metric_names[i]]] <- list(
            #             lower = ci$percent[4],
            #             upper = ci$percent[5]
            #         )
            #     }
            #     return(ci_results)
            # },

            # .create_roc_plot = function(sens, spec, ci = NULL) {
            #     roc_data <- data.frame(
            #         FPR = 1 - spec,
            #         TPR = sens
            #     )
            #
            #     p <- ggplot(roc_data, aes(x = FPR, y = TPR)) +
            #         geom_point(size = 3, color = "blue") +
            #         geom_line(size = 1) +
            #         geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "gray50") +
            #         coord_equal() +
            #         theme_minimal() +
            #         labs(
            #             x = "False Positive Rate (1 - Specificity)",
            #             y = "True Positive Rate (Sensitivity)",
            #             title = "ROC Curve"
            #         )
            #
            #     if (!is.null(ci)) {
            #         # Add confidence bands if provided
            #         p <- p + geom_ribbon(
            #             data = ci,
            #             aes(ymin = lower, ymax = upper),
            #             alpha = 0.2
            #         )
            #     }
            #
            #     return(p)
            # },

            # .compare_tests = function(test1_metrics, test2_metrics, n) {
            #     # Calculate statistical differences between tests
            #     # Using McNemar's test for paired comparisons
            #     mcnemar_stat <- (abs(test1_metrics$sensitivity - test2_metrics$sensitivity))^2 * n
            #     p_value <- 1 - pchisq(mcnemar_stat, df = 1)
            #
            #     return(list(
            #         diff_sens = test1_metrics$sensitivity - test2_metrics$sensitivity,
            #         diff_spec = test1_metrics$specificity - test2_metrics$specificity,
            #         mcnemar_stat = mcnemar_stat,
            #         p_value = p_value
            #     ))
            # }

            # ,
            # .prepare_data = function(data, vars) {
            #     # Handle missing values
            #     data <- jmvcore::naOmit(data)
            #
            #     # Convert variables to factors
            #     data[[vars$test]] <- forcats::as_factor(data[[vars$test]])
            #     data[[vars$gold]] <- forcats::as_factor(data[[vars$gold]])
            #
            #     # Recode variables to binary (Positive/Negative)
            #     data <- data %>%
            #         dplyr::mutate(
            #             test = dplyr::case_when(
            #                 .data[[vars$test]] == vars$test_pos ~ "Positive",
            #                 TRUE ~ "Negative"
            #             ),
            #             gold = dplyr::case_when(
            #                 .data[[vars$gold]] == vars$gold_pos ~ "Positive",
            #                 TRUE ~ "Negative"
            #             )
            #         )
            #
            #     # Convert to factors with proper levels
            #     data$test <- forcats::fct_relevel(data$test, "Positive")
            #     data$gold <- forcats::fct_relevel(data$gold, "Positive")
            #
            #     return(data)
            # },

            # .populate_main_tables = function(conf_matrix, metrics) {
            #     # Populate confusion matrix table
            #     cTable2 <- self$results$cTable2
            #
            #     # conf_matrix <- metrics # table(self$data$test, self$data$gold)
            #
            #     cTable2$setRow(rowKey = "Test Positive", values = list(
            #         newtest = "Test Positive",
            #         GP = conf_matrix[2,2],  # TP
            #         GN = conf_matrix[2,1],  # FP
            #         Total = sum(conf_matrix[2,])
            #     ))
            #
            #     cTable2$setRow(rowKey = "Test Negative", values = list(
            #         newtest = "Test Negative",
            #         GP = conf_matrix[1,2],  # FN
            #         GN = conf_matrix[1,1],  # TN
            #         Total = sum(conf_matrix[1,])
            #     ))
            #
            #     cTable2$setRow(rowKey = "Total", values = list(
            #         newtest = "Total",
            #         GP = sum(conf_matrix[,2]),
            #         GN = sum(conf_matrix[,1]),
            #         Total = sum(conf_matrix)
            #     ))
            #
            #     # Populate metrics table
            #     ratioTable2 <- self$results$ratioTable2
            #
            #     ratioTable2$setRow(rowNo = 1, values = list(
            #         tablename = "Ratios",
            #         Sens = metrics$sensitivity,
            #         Spec = metrics$specificity,
            #         AccurT = metrics$accuracy,
            #         # PrevalenceD = self$options$pp ? self$options$pprob : metrics$disease_pos/metrics$total_pop,
            #         PPV = metrics$ppv,
            #         NPV = metrics$npv,
            #         # PostTestProbDisease = self$calculate_post_test_prob(metrics, positive = TRUE),
            #         # PostTestProbHealthy = self$calculate_post_test_prob(metrics, positive = FALSE),
            #         LRP = metrics$plr,
            #         LRN = metrics$nlr
            #     ))
            #
            #     # Add footnotes if requested
            #     # if (self$options$fnote) {
            #     #     self$add_table_footnotes()
            #     # }
            # },

            # .populate_ci_tables = function(ci_results) {
            #     if (!self$options$ci) return()
            #
            #     # Get epiR results
            #     conf_matrix <- table(self$data$test, self$data$gold)
            #     epir_results <- epiR::epi.tests(conf_matrix)
            #     epir_summary <- summary(epir_results)
            #
            #     # Populate ratio CI table
            #     ratio_table <- self$results$epirTable_ratio
            #     ratio_metrics <- c("se", "sp", "pv.pos", "pv.neg")
            #
            #     for (metric in ratio_metrics) {
            #         if (metric %in% rownames(epir_summary)) {
            #             ratio_table$addRow(rowKey = metric, values = list(
            #                 statsnames = epir_summary[metric, "statistic"],
            #                 est = epir_summary[metric, "est"],
            #                 lower = epir_summary[metric, "lower"],
            #                 upper = epir_summary[metric, "upper"]
            #             ))
            #         }
            #     }
            #
            #     # Populate number CI table
            #     number_table <- self$results$epirTable_number
            #     number_metrics <- c("diag.or", "nndx", "youden")
            #
            #     for (metric in number_metrics) {
            #         if (metric %in% rownames(epir_summary)) {
            #             number_table$addRow(rowKey = metric, values = list(
            #                 statsnames = epir_summary[metric, "statistic"],
            #                 est = epir_summary[metric, "est"],
            #                 lower = epir_summary[metric, "lower"],
            #                 upper = epir_summary[metric, "upper"]
            #             ))
            #         }
            #     }
            # },

            # .populate_comparison_tables = function(comparison_results) {
            #     if (!self$options$compare_tests) return()
            #
            #     comparison_table <- self$results$comparison_table
            #     comparison_table$setRow(rowNo = 1, values = list(
            #         diff_sens = comparison_results$diff_sens,
            #         diff_spec = comparison_results$diff_spec,
            #         mcnemar_stat = comparison_results$mcnemar_stat,
            #         p_value = comparison_results$p_value
            #     ))
            # },

            # calculate_post_test_prob = function(metrics, positive = TRUE) {
            #     prior_prob <- self$options$pp ? self$options$pprob : metrics$disease_pos/metrics$total_pop
            #
            #     if (positive) {
            #         # Calculate positive post-test probability
            #         return((prior_prob * metrics$sensitivity) /
            #                    (prior_prob * metrics$sensitivity + (1 - prior_prob) * (1 - metrics$specificity)))
            #     } else {
            #         # Calculate negative post-test probability
            #         return(((1 - prior_prob) * metrics$specificity) /
            #                    ((1 - prior_prob) * metrics$specificity + prior_prob * (1 - metrics$sensitivity)))
            #     }
            # },

            # add_table_footnotes = function() {
            #     # Add footnotes to ratio table
            #     ratioTable <- self$results$ratioTable
            #
            #     footnotes <- list(
            #         Sens = "Sensitivity (True Positives among Diseased)",
            #         Spec = "Specificity (True Negatives among Healthy)",
            #         AccurT = "Accuracy (True Test Result Ratio)",
            #         PrevalenceD = "Disease Prevalence in this population",
            #         PPV = "Positive Predictive Value (Probability of disease given positive test)",
            #         NPV = "Negative Predictive Value (Probability of no disease given negative test)",
            #         PostTestProbDisease = "Post-test Probability of Disease",
            #         PostTestProbHealthy = "Post-test Probability of Being Healthy",
            #         LRP = "Positive Likelihood Ratio",
            #         LRN = "Negative Likelihood Ratio"
            #     )
            #
            #     for (col in names(footnotes)) {
            #         ratioTable$addFootnote(rowNo = 1, col = col, footnotes[[col]])
            #     }
            # }

            ,
            .run = function() {

                # private$.state <- list()  # Initialize empty state

                # # Error Message ----
                #
                # if (nrow(self$data) == 0) stop("Data contains no (complete) rows")
                #
                # if ( (is.null(self$options$vars) || is.null(self$options$facs)) && is.null(self$options$target) ) {
                #     # ToDo Message ----
                #     todo <- "
                #         <br>Welcome to ClinicoPath
                #                   <br><br>
                #                   This tool will help you form an Alluvial Plots.
                #                   "
                #     html <- self$results$todo
                #     html$setContent(todo)
                #
                # } else {
                #     todo <- ""
                #     html <- self$results$todo
                #     html$setContent(todo)
                #
                #
                #
                # }

                # Input validation
                # if (is.null(self$data) || nrow(self$data) == 0) {
                #   jmvcore::reject("No data provided for analysis")
                #   return()
                # }
                # if (any(sapply(vars, is.null))) {
                #   jmvcore::reject("Missing required variables")
                #   return()
                # }

                # TODO

                # todo <- glue::glue( 'This Module is still under development - - ' )
                # self$results$todo$setContent(todo)


                if (length(self$options$testPositive) + length(self$options$newtest) +
                    length(self$options$goldPositive) + length(self$options$gold) <
                    4)
                    return()

                if (nrow(self$data) == 0)
                    stop("Data contains no (complete) rows")

                # Input validation
                if (is.null(self$data) || nrow(self$data) == 0) {
                    stop("No data provided for analysis")
                }

                # Validate test and gold standard variables
                if (length(self$options$testPositive) +
                    length(self$options$newtest) +
                    length(self$options$goldPositive) +
                    length(self$options$gold) < 4) {
                    stop("Missing required variables: test and gold standard must be specified")
                }

                # Validate prevalence if specified
                if (self$options$pp &&
                    (self$options$pprob <= 0 || self$options$pprob >= 1)) {
                    stop("Prior probability must be between 0 and 1")
                }

                # Add NA handling for data
                mydata <- self$data
                mydata <- jmvcore::naOmit(mydata)
                if (nrow(mydata) < nrow(self$data)) {
                    warning(sprintf("Removed %d rows with missing values",
                                    nrow(self$data) - nrow(mydata)))
                }


                # Data definition ----
                mydata <- self$data

                mydata <- jmvcore::naOmit(mydata)

                testPLevel <- jmvcore::constructFormula(terms = self$options$testPositive)

                testPLevel <- jmvcore::decomposeFormula(formula = testPLevel)

                testPLevel <- unlist(testPLevel)


                testVariable <- jmvcore::constructFormula(terms = self$options$newtest)

                testVariable <- jmvcore::decomposeFormula(formula = testVariable)

                testVariable <- unlist(testVariable)


                goldPLevel <- jmvcore::constructFormula(terms = self$options$goldPositive)

                goldPLevel <- jmvcore::decomposeFormula(formula = goldPLevel)

                goldPLevel <- unlist(goldPLevel)


                goldVariable <- jmvcore::constructFormula(terms = self$options$gold)

                goldVariable <- jmvcore::decomposeFormula(formula = goldVariable)

                goldVariable <- unlist(goldVariable)

                mydata[[testVariable]] <- forcats::as_factor(mydata[[testVariable]])

                mydata[[goldVariable]] <- forcats::as_factor(mydata[[goldVariable]])

                # Table 1 ----

                results1 <- mydata %>% dplyr::select(.data[[testVariable]], .data[[goldVariable]]) %>%
                    table()

                self$results$text1$setContent(results1)


                result2 <- mydata %>%
                    dplyr::group_by_all() %>%
                    dplyr::count() %>%
                    as.data.frame() %>%
                    htmlTable::htmlTable()

                self$results$text2$setContent(result2)


                # Extract and validate variables
                # vars <- list(
                #   test = self$options$newtest,
                #   gold = self$options$gold,
                #   test_pos = self$options$testPositive,
                #   gold_pos = self$options$goldPositive
                # )


                # Prepare data
                # prepared_data <- private$.prepare_data(self$data, vars)
                # self$results$text3$setContent(prepared_data)



                # Calculate basic metrics
                # conf_matrix <- table(prepared_data$test, prepared_data$gold)

                # self$results$text3$setContent(conf_matrix)

                # metrics <- private$.calculate_basic_metrics(
                #   conf_matrix[2,2], # TP
                #   conf_matrix[2,1], # FP
                #   conf_matrix[1,1], # TN
                #   conf_matrix[1,2]  # FN
                # )

                # self$results$text3$setContent(list(conf_matrix, metrics))

                # Populate main results tables
                # private$.populate_main_tables(conf_matrix, metrics)



                # Calculate confidence intervals if requested
                # if (self$options$ci) {
                #   ci <- private$.calculate_confidence_intervals(data, metrics)
                #
                #   self$results$text3$setContent(ci)
                #
                #   # private$.populate_ci_tables(ci)
                #
                #   }

                # Create ROC plot if requested
                # if (self$options$roc) {
                #   roc_plot <- private$.create_roc_plot(
                #     metrics$sensitivity,
                #     metrics$specificity,
                #     ci
                #   )
                #   self$results$plot_roc$setState(roc_plot)
                # }

                # Compare tests if requested
                # if (self$options$compare_tests && !is.null(self$options$additional_test)) {
                #   test_comparison <- private$.compare_tests(
                #     metrics,
                #     private$.calculate_metrics_for_additional_test(),
                #     nrow(data)
                #   )
                #   private$.populate_comparison_tables(test_comparison)
                # }





                # results2 <- as.data.frame(results1)
                #
                # namesfrom <- names(results2)[2]
                #
                # results2 <- results2 %>%
                #         tidyr::pivot_wider(data = .,
                #                        names_from = namesfrom,
                #                        values_from = Freq)
                #
                #
                # self$results$text2$setContent(results2)



                # Original Table -----

                # origTable <- self$results$origTable


                # xnames <- results2[,1]
                #
                #
                # data_frame <- results2
                # for (i in seq_along(data_frame[,1,drop = T])) {
                #     origTable$addRow(rowKey = i, values = c(data_frame[i,]))
                # }


                # Recode ----

                mydata2 <- mydata

                mydata2 <- mydata2 %>% dplyr::mutate(
                    testVariable2 = dplyr::case_when(
                        .data[[testVariable]] ==
                            self$options$testPositive ~ "Positive",
                        NA ~ NA_character_,
                        TRUE ~
                            "Negative"
                    )
                ) %>%
                    dplyr::mutate(
                        goldVariable2 = dplyr::case_when(
                            .data[[goldVariable]] ==
                                self$options$goldPositive ~ "Positive",
                            NA ~ NA_character_,
                            TRUE ~
                                "Negative"
                        )
                    )

                mydata2 <- mydata2 %>% dplyr::mutate(testVariable2 = forcats::fct_relevel(testVariable2, "Positive")) %>% dplyr::mutate(goldVariable2 = forcats::fct_relevel(goldVariable2, "Positive"))




                # conf_table ----

                conf_table <- table(mydata2[["testVariable2"]], mydata2[["goldVariable2"]])


                # Caret ----
                # results_caret <- caret::confusionMatrix(conf_table, positive = "Positive")


                # self$results$text2$setContent(
                #     list(
                #         conf_table,
                #         results_caret
                #         )
                # )

                TP <- conf_table[1, 1]

                FP <- conf_table[1, 2]

                FN <- conf_table[2, 1]

                TN <- conf_table[2, 2]




                # Cross Table in jamovi style ----

                cTable <- self$results$cTable

                cTable$setRow(
                    rowKey = "Test Positive",
                    values = list(
                        newtest = "Test Positive",
                        GP = TP,
                        GN = FP,
                        Total = TP + FP
                    )
                )


                cTable$setRow(
                    rowKey = "Test Negative",
                    values = list(
                        newtest = "Test Negative",
                        GP = FN,
                        GN = TN,
                        Total = FN + TN
                    )
                )

                cTable$setRow(
                    rowKey = "Total",
                    values = list(
                        newtest = "Total",
                        GP = TP + FN,
                        GN = FP + TN,
                        Total = TP + FP + FN + TN
                    )
                )





                # Self Calculations ----

                # Self Calculation https://cran.r-project.org/web/packages/caret/caret.pdf
                # https://online.stat.psu.edu/stat509/node/150/

                # https://en.wikipedia.org/wiki/Sensitivity_and_specificity

                TotalPop <- TP + TN + FP + FN

                DiseaseP <- TP + FN

                DiseaseN <- TN + FP

                TestP <- TP + FP

                TestN <- TN + FN

                TestT <- TP + TN

                TestW <- FP + FN

                Sens <- TP / DiseaseP

                Spec <- TN / DiseaseN

                AccurT <- TestT / TotalPop

                PrevalenceD <- DiseaseP / TotalPop

                PPV <- TP / TestP

                NPV <- TN / TestN


                pp <- self$options$pp
                pprob <- self$options$pprob

                if (pp) {
                    # Known prior probability from population
                    PriorProb <- pprob
                } else {
                    # From ConfusionMatrix
                    PriorProb <- PrevalenceD
                }


                PostTestProbDisease <- (PriorProb * Sens) / ((PriorProb * Sens) + ((1 -
                                                                                        PriorProb) * (1 - Spec)))



                PostTestProbHealthy <- ((1 - PriorProb) * Spec) / (((1 - PriorProb) *
                                                                        Spec) + (PriorProb * (1 - Sens)))




                LRP <- Sens / (1 - Spec)

                LRN <- (1 - Sens) / Spec



                # Cache computed values
                # private$.state <- list(
                #     sens = Sens,
                #     spec = Spec,
                #     ppv = PPV,
                #     npv = NPV,
                #     tp = TP,
                #     fp = FP,
                #     tn = TN,
                #     fn = FN,
                #     n_pos = DiseaseP,
                #     n_neg = DiseaseN,
                #     prevalence = PriorProb
                # )



                # self$results$nTable2$setContent(
                #     list(
                #         tablename = "",
                #         TotalPop = TotalPop,
                #         DiseaseP = DiseaseP,
                #         DiseaseN = DiseaseN,
                #         TestP = TestP,
                #         TestN = TestN,
                #         TestT = TestT,
                #         TestW = TestW
                #     )
                # )



                # nTable Populate Table ----

                nTable <- self$results$nTable
                nTable$setRow(
                    rowNo = 1,
                    values = list(
                        tablename = "",
                        TotalPop = TotalPop,
                        DiseaseP = DiseaseP,
                        DiseaseN = DiseaseN,
                        TestP = TestP,
                        TestN = TestN,
                        TestT = TestT,
                        TestW = TestW
                    )
                )







                # ratioTable Populate Table ----


                ratioTable <- self$results$ratioTable
                ratioTable$setRow(
                    rowNo = 1,
                    values = list(
                        tablename = "",
                        Sens = Sens,
                        Spec = Spec,
                        AccurT = AccurT,
                        PrevalenceD = PriorProb,
                        PPV = PPV,
                        NPV = NPV,
                        PostTestProbDisease = PostTestProbDisease,
                        PostTestProbHealthy = PostTestProbHealthy,
                        LRP = LRP,
                        LRN = LRN
                    )
                )

                # nTable footnotes ----

                if (self$options$fnote) {
                    # nTable$addFootnote(rowKey = "1", col = "TotalPop", "Total Population")

                    nTable$addFootnote(rowNo = 1,
                                       col = "TotalPop",
                                       "Total Number of Subjects")

                    nTable$addFootnote(rowNo = 1,
                                       col = "DiseaseP",
                                       "Total Number of Subjects with Disease")

                    nTable$addFootnote(rowNo = 1,
                                       col = "DiseaseN",
                                       "Total Number of Healthy Subjects")

                    nTable$addFootnote(rowNo = 1,
                                       col = "TestP",
                                       "Total Number of Positive Tests")

                    nTable$addFootnote(rowNo = 1,
                                       col = "TestN",
                                       "Total Number of Negative Tests")

                    nTable$addFootnote(rowNo = 1,
                                       col = "TestT",
                                       "Total Number of True Test Results")

                    nTable$addFootnote(rowNo = 1,
                                       col = "TestW",
                                       "Total Number of Wrong Test Results")


                }


                # ratioTable footnotes ----


                if (self$options$fnote) {
                    ratioTable$addFootnote(
                        rowNo = 1,
                        col = "Sens",
                        "Sensitivity (True Positives among Diseased)"
                    )

                    ratioTable$addFootnote(
                        rowNo = 1,
                        col = "Spec",
                        "Specificity (True Negatives among Healthy)"
                    )

                    ratioTable$addFootnote(rowNo = 1,
                                           col = "AccurT",
                                           "Accuracy (True Test Result Ratio)")

                    ratioTable$addFootnote(rowNo = 1,
                                           col = "PrevalenceD",
                                           "Disease Prevalence in this population")

                    ratioTable$addFootnote(
                        rowNo = 1,
                        col = "PPV",
                        "Positive Predictive Value (Probability of having disease after a positive test using this experimental population)"
                    )

                    ratioTable$addFootnote(
                        rowNo = 1,
                        col = "NPV",
                        "Negative Predictive Value (Probability of being healthy after a negative test using this experimental population)"
                    )

                    ratioTable$addFootnote(
                        rowNo = 1,
                        col = "PostTestProbDisease",
                        "Post-test Probability of Having Disease  (Probability of having disease after a positive test using known Population Prevalence)"
                    )

                    ratioTable$addFootnote(
                        rowNo = 1,
                        col = "PostTestProbHealthy",
                        "Post-test Probability of Being Healthy (Probability of being healthy after a negative test using known Population Prevalence)"
                    )

                    # ratioTable$addFootnote(rowNo = 1, col = "LRP", "")

                    # ratioTable$addFootnote(rowNo = 1, col = "LRN", "")


                }




                # Reorganize Table

                # caretresult[['positive']]
                # caretresult[['table']]
                # caretresult[['overall']]
                # caretresult[['overall']][['Accuracy']]
                # caretresult[['overall']][['Kappa']]
                # caretresult[['overall']][['AccuracyLower']]
                # caretresult[['overall']][['AccuracyUpper']]
                # caretresult[['overall']][['AccuracyNull']]
                # caretresult[['overall']][['AccuracyPValue']]
                # caretresult[['overall']][['McnemarPValue']]
                # caretresult[['byClass']]
                # caretresult[['byClass']][['Sensitivity']]
                # caretresult[['byClass']][['Specificity']]
                # caretresult[['byClass']][['Pos Pred Value']]
                # caretresult[['byClass']][['Neg Pred Value']]
                # caretresult[['byClass']][['Precision']]
                # caretresult[['byClass']][['Recall']] caretresult[['byClass']][['F1']]
                # caretresult[['byClass']][['Prevalence']]
                # caretresult[['byClass']][['Detection Rate']]
                # caretresult[['byClass']][['Detection Prevalence']]
                # caretresult[['byClass']][['Balanced Accuracy']] caretresult[['mode']]
                # caretresult[['dots']]

                # Write Summary

                # 95% CI ----

                ci <- self$options$ci

                if (ci) {
                    # epiR ----


                    epirresult <- epiR::epi.tests(dat = conf_table)


                    epirresult2 <- summary(epirresult)
                    epirresult2 <- as.data.frame(epirresult2) %>%
                        tibble::rownames_to_column(.data = ., var = 'statsabv')


                    epirresult2$statsnames <-
                        c(
                            "Apparent prevalence",
                            "True prevalence",
                            "Test sensitivity",
                            "Test specificity",
                            "Diagnostic accuracy",
                            "Diagnostic odds ratio",
                            "Number needed to diagnose",
                            "Youden's index",
                            "Positive predictive value",
                            "Negative predictive value",
                            "Likelihood ratio of a positive test",
                            "Likelihood ratio of a negative test",
                            "Proportion of subjects with the outcome ruled out",
                            "Proportion of subjects with the outcome ruled in",
                            "Proportion of false positives",
                            "Proportion of false negative",
                            "False Discovery Rate",
                            "False Omission Rate"

                        )

                    ratiorows <- c(
                        "ap",
                        "tp",
                        "se",
                        "sp",
                        "diag.ac",
                        "pv.pos",
                        "pv.neg",
                        "p.tpdn",
                        "p.tndp",
                        "p.dntp",
                        "p.dptn"
                    )


                    numberrows <- c("diag.or", "nndx", "youden", "lr.pos", "lr.neg")

                    epirresult_number <- epirresult2[epirresult2$statistic %in% numberrows, ]

                    epirresult_ratio <- epirresult2[epirresult2$statistic %in% ratiorows, ]





                    # epirTable_ratio -----

                    epirTable_ratio <- self$results$epirTable_ratio

                    data_frame <- epirresult_ratio
                    for (i in seq_along(data_frame[, 1, drop = T])) {
                        epirTable_ratio$addRow(rowKey = i,
                                               values = c(data_frame[i, ])) # This code produces a named vector/list, which is what the values argument expects
                    }



                    # epirTable_ratio footnotes ----

                    if (self$options$fnote) {

                        epirTable_ratio$addFootnote(
                            rowNo = 5,
                            col = "statsnames",
                            "Proportion of all tests that give a correct result."
                        )
                    }






                    # epirTable_number ----


                    epirTable_number <- self$results$epirTable_number

                    data_frame <- epirresult_number
                    for (i in seq_along(data_frame[, 1, drop = T])) {
                        epirTable_number$addRow(rowKey = i,
                                                values = c(data_frame[i, ]))
                    }



                    # epirTable_number footnotes ----

                    if (self$options$fnote) {


                        epirTable_number$addFootnote(
                            rowNo = 1,
                            col = "statsnames",
                            "How much more likely will the test make a correct diagnosis than an incorrect diagnosis in patients with the disease."
                        )

                        epirTable_number$addFootnote(
                            rowNo = 2,
                            col = "statsnames",
                            "Number of patients that need to be tested to give one correct positive test."
                        )


                        epirTable_number$addFootnote(
                            rowNo = 3,
                            col = "statsnames",
                            "Youden's index is the difference between the true positive rate and the false positive rate. Youden's index ranges from -1 to +1 with values closer to 1 if both sensitivity and specificity are high (i.e. close to 1)."

                        )

                    }


                }





                # Send Data to Plot ----


                plotData1 <- list(
                    "Prevalence" = PriorProb,
                    "Sens" = Sens,
                    "Spec" = Spec,
                    "Plr" = LRP,
                    "Nlr" = LRN
                )


                # self$results$plotcontent$setContent(plotData1)



                image1 <- self$results$plot1
                image1$setState(plotData1)




                # if (self$options$roc) {
                #     plotData2 <- list(
                #         sens = Sens,
                #         spec = Spec,
                #         tp = TP,
                #         fp = FP,
                #         tn = TN,
                #         fn = FN,
                #         n_pos = DiseaseP,
                #         n_neg = DiseaseN,
                #         thresholds = NULL  # Add thresholds if available
                #     )
                #
                #     image2 <- self$results$plot_roc
                #     image2$setState(plotData2)
                # }



            }


            ,
            .plot1 = function(image1, ggtheme, ...) {
                plotData1 <- image1$state

                plot1 <- nomogrammer(
                    Prevalence = plotData1$Prevalence,
                    Sens = plotData1$Sens,
                    Spec = plotData1$Spec,
                    Plr = plotData1$Plr,
                    Nlr = plotData1$Nlr,
                    Detail = TRUE,
                    NullLine = TRUE,
                    LabelSize = (14 / 5),
                    Verbose = TRUE
                )

                print(plot1)
                TRUE

            }



            # matrixdetails <- list(results_caret[["positive"]], results_caret[["table"]],
            #     results_caret[["overall"]], results_caret[["overall"]][["Accuracy"]],
            #     results_caret[["overall"]][["Kappa"]], results_caret[["overall"]][["AccuracyLower"]],
            #     results_caret[["overall"]][["AccuracyUpper"]], results_caret[["overall"]][["AccuracyNull"]],
            #     results_caret[["overall"]][["AccuracyPValue"]], results_caret[["overall"]][["McnemarPValue"]],
            #     results_caret[["byClass"]], results_caret[["byClass"]][["Sensitivity"]],
            #     results_caret[["byClass"]][["Specificity"]], results_caret[["byClass"]][["Pos Pred Value"]],
            #     results_caret[["byClass"]][["Neg Pred Value"]], results_caret[["byClass"]][["Precision"]],
            #     results_caret[["byClass"]][["Recall"]], results_caret[["byClass"]][["F1"]],
            #     results_caret[["byClass"]][["Prevalence"]], results_caret[["byClass"]][["Detection Rate"]],
            #     results_caret[["byClass"]][["Detection Prevalence"]], results_caret[["byClass"]][["Balanced Accuracy"]],
            #     results_caret[["mode"]], results_caret[["dots"]])

            # self$results$text3$setContent(matrixdetails)


            # Individual analysis

            # sens <- caret::sensitivity(conf_table, positive = 'Positive')

            # PPV <- caret::posPredValue(conf_table, positive = 'Positive')

            # summary_caret <- glue::glue('Sensitivity is {sens}.  PPV is {PPV}.')

            # self$results$text4$setContent(summary_caret)


            # bdpv ---- https://cran.r-project.org/web/packages/bdpv/bdpv.pdf



            # epiR ---- https://cran.r-project.org/web/packages/epiR/epiR.pdf


            # dat <- as.table( matrix(c(670,202,74,640), nrow = 2, byrow = TRUE) )

            # colnames(dat) <- c('Dis+','Dis-') rownames(dat) <- c('Test+','Test-')

            # rval <- epiR::epi.tests(dat, conf.level = 0.95)

            # rval <- list( dat, rval, print(rval), summary(rval) )

            # self$results$text5$setContent(rval)



            # Prior Probability

            # lvs <- c('normal', 'abnormal') truth <- factor(rep(lvs, times = c(86,
            # 258)), levels = rev(lvs)) pred <- factor( c( rep(lvs, times = c(54,
            # 32)), rep(lvs, times = c(27, 231))), levels = rev(lvs)) xtab <-
            # table(pred, truth) confusionMatrix(xtab) confusionMatrix(pred, truth)
            # confusionMatrix(xtab, prevalence = 0.25) ## 3 class example
            # confusionMatrix(iris$Species, sample(iris$Species)) newPrior <- c(.05,
            # .8, .15) names(newPrior) <- levels(iris$Species)
            # confusionMatrix(iris$Species, sample(iris$Species))






            # ,
            # .plot_roc = function(image2, ggtheme, ...) {
            #
            #     plotData2 <- image2$state
            #
            #     if (is.null(plotData2)) return(FALSE)
            #
            #     # Calculate confidence intervals
            #     auc <- 0.5 * (plotData2$sens * (1-plotData2$spec)) +
            #         0.5 * (1 * (1-(1-plotData2$spec))) +
            #         0.5 * ((1-plotData2$sens) * plotData2$spec)
            #
            #     ci <- auc_ci(auc, plotData2$n_pos, plotData2$n_neg)
            #
            #     # Create ROC curve points
            #     roc_points <- data.frame(
            #         fpr = c(0, 1-plotData2$spec, 1),
            #         tpr = c(0, plotData2$sens, 1)
            #     )
            #
            #     # Create plot with confidence band
            #     p <- ggplot(roc_points, aes(x=fpr, y=tpr)) +
            #         geom_line(color="blue", size=1) +
            #         geom_point(data=data.frame(
            #             fpr=1-plotData2$spec,
            #             tpr=plotData2$sens),
            #             color="red", size=3) +
            #         geom_abline(slope=1, intercept=0,
            #                     linetype="dashed", color="gray") +
            #         annotate("text", x=0.75, y=0.25,
            #                  label=sprintf("AUC = %.3f (%.3f-%.3f)",
            #                                auc, ci[1], ci[2])) +
            #         labs(x = "False Positive Rate (1 - Specificity)",
            #              y = "True Positive Rate (Sensitivity)",
            #              title = "ROC Curve") +
            #         theme_minimal() +
            #         coord_equal() +
            #         theme(plot.title = element_text(hjust = 0.5))
            #
            #     print(p)
            #     TRUE
            # }



            # ,
            # .plot_comparative_roc = function(image, ggtheme, ...) {
            #     test_data <- image$state
            #     if (is.null(test_data) || length(test_data) < 2) return(FALSE)
            #
            #     n_tests <- length(test_data)
            #
            #     # Create base plot
            #     p <- create_base_roc_plot(test_data)
            #
            #     # Add statistical tests if there are multiple tests
            #     if(n_tests >= 2) {
            #         p <- add_statistical_comparison(p, test_data)
            #     }
            #
            #     print(p)
            #     TRUE
            # }



        )
    )


File: R\decision.h.R
--------------------------------------------------
Content of R\decision.h.R:

# This file is automatically generated, you probably don't want to edit this

decisionOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "decisionOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            gold = NULL,
            goldPositive = NULL,
            newtest = NULL,
            testPositive = NULL,
            pp = FALSE,
            pprob = 0.3,
            od = FALSE,
            fnote = FALSE,
            ci = FALSE,
            fagan = FALSE, ...) {

            super$initialize(
                package="meddecide",
                name="decision",
                requiresData=TRUE,
                ...)

            private$..gold <- jmvcore::OptionVariable$new(
                "gold",
                gold,
                suggested=list(
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..goldPositive <- jmvcore::OptionLevel$new(
                "goldPositive",
                goldPositive,
                variable="(gold)")
            private$..newtest <- jmvcore::OptionVariable$new(
                "newtest",
                newtest,
                suggested=list(
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..testPositive <- jmvcore::OptionLevel$new(
                "testPositive",
                testPositive,
                variable="(newtest)")
            private$..pp <- jmvcore::OptionBool$new(
                "pp",
                pp,
                default=FALSE)
            private$..pprob <- jmvcore::OptionNumber$new(
                "pprob",
                pprob,
                default=0.3,
                min=0.001,
                max=0.999)
            private$..od <- jmvcore::OptionBool$new(
                "od",
                od,
                default=FALSE)
            private$..fnote <- jmvcore::OptionBool$new(
                "fnote",
                fnote,
                default=FALSE)
            private$..ci <- jmvcore::OptionBool$new(
                "ci",
                ci,
                default=FALSE)
            private$..fagan <- jmvcore::OptionBool$new(
                "fagan",
                fagan,
                default=FALSE)

            self$.addOption(private$..gold)
            self$.addOption(private$..goldPositive)
            self$.addOption(private$..newtest)
            self$.addOption(private$..testPositive)
            self$.addOption(private$..pp)
            self$.addOption(private$..pprob)
            self$.addOption(private$..od)
            self$.addOption(private$..fnote)
            self$.addOption(private$..ci)
            self$.addOption(private$..fagan)
        }),
    active = list(
        gold = function() private$..gold$value,
        goldPositive = function() private$..goldPositive$value,
        newtest = function() private$..newtest$value,
        testPositive = function() private$..testPositive$value,
        pp = function() private$..pp$value,
        pprob = function() private$..pprob$value,
        od = function() private$..od$value,
        fnote = function() private$..fnote$value,
        ci = function() private$..ci$value,
        fagan = function() private$..fagan$value),
    private = list(
        ..gold = NA,
        ..goldPositive = NA,
        ..newtest = NA,
        ..testPositive = NA,
        ..pp = NA,
        ..pprob = NA,
        ..od = NA,
        ..fnote = NA,
        ..ci = NA,
        ..fagan = NA)
)

decisionResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "decisionResults",
    inherit = jmvcore::Group,
    active = list(
        text1 = function() private$.items[["text1"]],
        text2 = function() private$.items[["text2"]],
        cTable = function() private$.items[["cTable"]],
        nTable = function() private$.items[["nTable"]],
        ratioTable = function() private$.items[["ratioTable"]],
        epirTable_ratio = function() private$.items[["epirTable_ratio"]],
        epirTable_number = function() private$.items[["epirTable_number"]],
        plot1 = function() private$.items[["plot1"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Medical Decision",
                refs=list(
                    "DiagnosticTests",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text1",
                title="Original Data",
                visible="(od)"))
            self$add(jmvcore::Html$new(
                options=options,
                name="text2",
                title="Original Data",
                visible="(od)"))
            self$add(jmvcore::Table$new(
                options=options,
                name="cTable",
                title="Recoded Data for Decision Test Statistics",
                rows=0,
                columns=list(
                    list(
                        `name`="newtest", 
                        `title`="", 
                        `type`="text"),
                    list(
                        `name`="GP", 
                        `title`="Gold Positive", 
                        `type`="number"),
                    list(
                        `name`="GN", 
                        `title`="Gold Negative", 
                        `type`="number"),
                    list(
                        `name`="Total", 
                        `title`="Total", 
                        `type`="number"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="nTable",
                title="n",
                swapRowsColumns=TRUE,
                rows=1,
                columns=list(
                    list(
                        `name`="tablename", 
                        `title`="", 
                        `type`="text"),
                    list(
                        `name`="TotalPop", 
                        `title`="Total", 
                        `type`="number"),
                    list(
                        `name`="DiseaseP", 
                        `title`="Diseased", 
                        `type`="number"),
                    list(
                        `name`="DiseaseN", 
                        `title`="Healthy", 
                        `type`="number"),
                    list(
                        `name`="TestP", 
                        `title`="Positive Tests", 
                        `type`="number"),
                    list(
                        `name`="TestN", 
                        `title`="Negative Tests", 
                        `type`="number"),
                    list(
                        `name`="TestT", 
                        `title`="True Test", 
                        `type`="number"),
                    list(
                        `name`="TestW", 
                        `title`="Wrong Test", 
                        `type`="number")),
                clearWith=list(
                    "pp",
                    "pprob")))
            self$add(jmvcore::Table$new(
                options=options,
                name="ratioTable",
                title="",
                swapRowsColumns=TRUE,
                rows=1,
                columns=list(
                    list(
                        `name`="tablename", 
                        `title`="", 
                        `type`="text"),
                    list(
                        `name`="Sens", 
                        `title`="Sensitivity", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="Spec", 
                        `title`="Specificity", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="AccurT", 
                        `title`="Accuracy", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="PrevalenceD", 
                        `title`="Prevalence", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="PPV", 
                        `title`="Positive Predictive Value", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="NPV", 
                        `title`="Negative Predictive Value", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="PostTestProbDisease", 
                        `title`="Post-test Disease Probability", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="PostTestProbHealthy", 
                        `title`="Post-test Health Probability", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="LRP", 
                        `title`="Positive Likelihood Ratio", 
                        `type`="number"),
                    list(
                        `name`="LRN", 
                        `title`="Negative Likelihood Ratio", 
                        `type`="number")),
                clearWith=list(
                    "pp",
                    "pprob")))
            self$add(jmvcore::Table$new(
                options=options,
                name="epirTable_ratio",
                title="EpiR Table Ratios",
                visible="(ci)",
                rows=0,
                columns=list(
                    list(
                        `name`="statsnames", 
                        `title`="Decision Statistics", 
                        `type`="text"),
                    list(
                        `name`="est", 
                        `title`="Estimate", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="lower", 
                        `title`="Lower", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="upper", 
                        `title`="Upper", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number", 
                        `format`="pc")),
                clearWith=list(
                    "pp",
                    "pprob"),
                refs="epiR"))
            self$add(jmvcore::Table$new(
                options=options,
                name="epirTable_number",
                title="",
                visible="(ci)",
                rows=0,
                columns=list(
                    list(
                        `name`="statsnames", 
                        `title`="Decision Statistics", 
                        `type`="text"),
                    list(
                        `name`="est", 
                        `title`="Estimate", 
                        `type`="number"),
                    list(
                        `name`="lower", 
                        `title`="Lower", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number"),
                    list(
                        `name`="upper", 
                        `title`="Upper", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number")),
                clearWith=list(
                    "pp",
                    "pprob"),
                refs="epiR"))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot1",
                title="Fagan nomogram",
                width=600,
                height=450,
                renderFun=".plot1",
                requiresData=TRUE,
                visible="(fagan)",
                clearWith=list(
                    "pp",
                    "pprob",
                    "fagan"),
                refs=list(
                    "Fagan",
                    "Fagan2")))}))

decisionBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "decisionBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "meddecide",
                name = "decision",
                version = c(1,0,0),
                options = options,
                results = decisionResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Medical Decision
#'
#' Function for Medical Decision Analysis. Sensitivity, specificity, positive 
#' predictive value, negative predictive value.
#' 
#'
#' @examples
#' \donttest{
#' # example will be added
#'}
#' @param data The data as a data frame. The data frame should contain the
#'   variables specified in the 'variables' option.
#' @param gold The golden standard variable.
#' @param goldPositive The positive level of the golden standard variable.
#' @param newtest The new test variable.
#' @param testPositive The positive level of the new test variable.
#' @param pp Boolean selection whether to show prior probability. Default is
#'   'false'.
#' @param pprob Prior probability (disease prevalence in the community).
#'   Requires a value between 0.001 and 0.999, default 0.300.
#' @param od Boolean selection whether to show frequency table. Default is
#'   'false'.
#' @param fnote Boolean selection whether to show footnotes. Default is
#'   'false'.
#' @param ci Boolean selection whether to show 95\% confidence intervals.
#'   Default is 'false'.
#' @param fagan Boolean selection whether to show Fagan Nomogram. Default is
#'   'false'.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$text1} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$text2} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$cTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$nTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$ratioTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$epirTable_ratio} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$epirTable_number} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$plot1} \tab \tab \tab \tab \tab an image \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$cTable$asDF}
#'
#' \code{as.data.frame(results$cTable)}
#'
#' @export
decision <- function(
    data,
    gold,
    goldPositive,
    newtest,
    testPositive,
    pp = FALSE,
    pprob = 0.3,
    od = FALSE,
    fnote = FALSE,
    ci = FALSE,
    fagan = FALSE) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("decision requires jmvcore to be installed (restart may be required)")

    if ( ! missing(gold)) gold <- jmvcore::resolveQuo(jmvcore::enquo(gold))
    if ( ! missing(newtest)) newtest <- jmvcore::resolveQuo(jmvcore::enquo(newtest))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(gold), gold, NULL),
            `if`( ! missing(newtest), newtest, NULL))

    for (v in gold) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])
    for (v in newtest) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- decisionOptions$new(
        gold = gold,
        goldPositive = goldPositive,
        newtest = newtest,
        testPositive = testPositive,
        pp = pp,
        pprob = pprob,
        od = od,
        fnote = fnote,
        ci = ci,
        fagan = fagan)

    analysis <- decisionClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\decisioncalculator.b.R
--------------------------------------------------
Content of R\decisioncalculator.b.R:
#' @title Decision Calculator
#' @importFrom R6 R6Class
#' @import jmvcore
#' @importFrom utils data
#'

decisioncalculatorClass <- if (requireNamespace("jmvcore")) R6::R6Class("decisioncalculatorClass",
    inherit = decisioncalculatorBase, private = list(



        .init = function() {

            cTable <- self$results$cTable

            cTable$addRow(rowKey = "Test Positive",
                          values = list(
                              newtest = "Test Positive"
                          )
            )


            cTable$addRow(rowKey = "Test Negative",
                          values = list(
                              newtest = "Test Negative"
                          )
            )




            cTable$addRow(rowKey = "Total",
                          values = list(
                              newtest = "Total"
                          )
            )

        },






        .run = function() {


        # # Error Message ----
        #
        # if (nrow(self$data) == 0) stop("Data contains no (complete) rows")
        #
        # if ( (is.null(self$options$vars) || is.null(self$options$facs)) && is.null(self$options$target) ) {
        #     # ToDo Message ----
        #     todo <- "
        #         <br>Welcome to ClinicoPath
        #                   <br><br>
        #                   This tool will help you form an Alluvial Plots.
        #                   "
        #     html <- self$results$todo
        #     html$setContent(todo)
        #
        # } else {
        #     todo <- ""
        #     html <- self$results$todo
        #     html$setContent(todo)
        #
        #
        #
        # }








        # TODO

        # todo <- glue::glue( 'This Module is still under development - - ' )

        # self$results$todo$setContent(todo)


        # read numbers from input ----

        TP <- self$options$TP

        FP <- self$options$FP

        TN <- self$options$TN

        FN <- self$options$FN


        # make table ----

        # table1 <- matrix(c(TP, FP, FN, TN), nrow = 2, ncol = 2, byrow = TRUE,
        # dimnames = list(c('Test Positive', 'Test Negative'), c('Gold
        # Positive','Gold Negative'))) self$results$text1$setContent(table1)

        table2 <- matrix(c(TP, FP, FN, TN), nrow = 2, ncol = 2, byrow = TRUE,
            dimnames = list(c("Positive", "Negative"), c("Positive", "Negative")))

        table3 <- as.table(table2)

        names(attributes(table3)$dimnames) <- c("Test", "Golden Standard")

        # Prior Probability ----

        pp <- self$options$pp

        pprob <- self$options$pprob


        # caret result ----

        # if (pp) {
        #     caretresult <- caret::confusionMatrix(table3, prevalence = pprob)
        #
        # } else {
        #
        #     caretresult <- caret::confusionMatrix(table3)
        #
        # }

        # self$results$text2$setContent(caretresult)



        # Cross Table in jamovi style ----

        cTable <- self$results$cTable


        cTable$setRow(rowKey = "Test Positive",
                      values = list(
                          newtest = "Test Positive",
                          GP = TP,
                          GN = FP,
                          Total = TP + FP
                      )
        )


        cTable$setRow(rowKey = "Test Negative",
                      values = list(
                          newtest = "Test Negative",
                          GP = FN,
                          GN = TN,
                          Total = FN + TN
                      )
        )

        cTable$setRow(rowKey = "Total",
                      values = list(
                          newtest = "Total",
                          GP = TP + FN,
                          GN = FP + TN,
                          Total = TP + FP + FN + TN
                      )
        )





        # Self Calculations ----

        # Self Calculation https://cran.r-project.org/web/packages/caret/caret.pdf
        # https://online.stat.psu.edu/stat509/node/150/

        # https://en.wikipedia.org/wiki/Sensitivity_and_specificity

        TotalPop <- TP + TN + FP + FN

        DiseaseP <- TP + FN

        DiseaseN <- TN + FP

        TestP <- TP + FP

        TestN <- TN + FN

        TestT <- TP + TN

        TestW <- FP + FN

        Sens <- TP/DiseaseP

        Spec <- TN/DiseaseN

        AccurT <- TestT/TotalPop

        PrevalenceD <- DiseaseP/TotalPop

        PPV <- TP/TestP

        NPV <- TN/TestN


        if (pp) {
            # Known prior probability from population
            PriorProb <- pprob
        } else {
            # From ConfusionMatrix
            PriorProb <- PrevalenceD
        }


        PostTestProbDisease <- (PriorProb * Sens)/((PriorProb * Sens) + ((1 -
            PriorProb) * (1 - Spec)))



        PostTestProbHealthy <- ((1 - PriorProb) * Spec)/(((1 - PriorProb) *
            Spec) + (PriorProb * (1 - Sens)))




        LRP <- Sens / (1 - Spec)

        LRN <- (1 - Sens) / Spec


        # nTable Populate Table ----

        nTable <- self$results$nTable
        nTable$setRow(rowNo = 1,
                           values = list(
            tablename = "n",
            TotalPop = TotalPop,
            DiseaseP = DiseaseP,
            DiseaseN = DiseaseN,
            TestP = TestP,
            TestN = TestN,
            TestT = TestT,
            TestW = TestW
                           )
        )

        # ratioTable Populate Table ----


        ratioTable <- self$results$ratioTable
        ratioTable$setRow(rowNo = 1,
                      values = list(
            tablename = "Ratios",
            Sens = Sens,
            Spec = Spec,
            AccurT = AccurT,
            PrevalenceD = PriorProb,
            PPV = PPV,
            NPV = NPV,
            PostTestProbDisease = PostTestProbDisease,
            PostTestProbHealthy = PostTestProbHealthy,
            LRP = LRP,
            LRN = LRN
            )
            )





        # nTable footnotes ----

        if (self$options$fnote) {

        # nTable$addFootnote(rowKey = "1", col = "TotalPop", "Total Population")

        nTable$addFootnote(rowNo = 1, col = "TotalPop", "Total Number of Subjects")

        nTable$addFootnote(rowNo = 1, col = "DiseaseP", "Total Number of Subjects with Disease")

        nTable$addFootnote(rowNo = 1, col = "DiseaseN", "Total Number of Healthy Subjects")

        nTable$addFootnote(rowNo = 1, col = "TestP", "Total Number of Positive Tests")

        nTable$addFootnote(rowNo = 1, col = "TestN", "Total Number of Negative Tests")

        nTable$addFootnote(rowNo = 1, col = "TestT", "Total Number of True Test Results")

        nTable$addFootnote(rowNo = 1, col = "TestW", "Total Number of Wrong Test Results")


        }


        # ratioTable footnotes ----


        if (self$options$fnote) {

        ratioTable$addFootnote(rowNo = 1, col = "Sens", "Sensitivity (True Positives among Diseased)")

        ratioTable$addFootnote(rowNo = 1, col = "Spec", "Specificity (True Negatives among Healthy)")

        ratioTable$addFootnote(rowNo = 1, col = "AccurT", "Accuracy (True Test Result Ratio)")

        ratioTable$addFootnote(rowNo = 1, col = "PrevalenceD", "Disease Prevalence in this population")

        ratioTable$addFootnote(rowNo = 1, col = "PPV", "Positive Predictive Value (Probability of having disease after a positive test using this experimental population)")

        ratioTable$addFootnote(rowNo = 1, col = "NPV", "Negative Predictive Value (Probability of being healthy after a negative test using this experimental population)")

        ratioTable$addFootnote(rowNo = 1, col = "PostTestProbDisease", "Post-test Probability of Having Disease  (Probability of having disease after a positive test using known Population Prevalence)")

        ratioTable$addFootnote(rowNo = 1, col = "PostTestProbHealthy", "Post-test Probability of Being Healthy (Probability of being healthy after a negative test using known Population Prevalence)")

        # ratioTable$addFootnote(rowNo = 1, col = "LRP", "")

        # ratioTable$addFootnote(rowNo = 1, col = "LRN", "")


        }




        # Reorganize Table



        # caretresult[['positive']]
        # caretresult[['table']]
        # caretresult[['overall']]
        # caretresult[['overall']][['Accuracy']]
        # caretresult[['overall']][['Kappa']]
        # caretresult[['overall']][['AccuracyLower']]
        # caretresult[['overall']][['AccuracyUpper']]
        # caretresult[['overall']][['AccuracyNull']]
        # caretresult[['overall']][['AccuracyPValue']]
        # caretresult[['overall']][['McnemarPValue']]
        # caretresult[['byClass']]
        # caretresult[['byClass']][['Sensitivity']]
        # caretresult[['byClass']][['Specificity']]
        # caretresult[['byClass']][['Pos Pred Value']]
        # caretresult[['byClass']][['Neg Pred Value']]
        # caretresult[['byClass']][['Precision']]
        # caretresult[['byClass']][['Recall']] caretresult[['byClass']][['F1']]
        # caretresult[['byClass']][['Prevalence']]
        # caretresult[['byClass']][['Detection Rate']]
        # caretresult[['byClass']][['Detection Prevalence']]
        # caretresult[['byClass']][['Balanced Accuracy']] caretresult[['mode']]
        # caretresult[['dots']]




        # Write Summary






        # 95% CI ----

        ci <- self$options$ci

        if (ci) {



        # epiR ----

        epirresult <- epiR::epi.tests(dat = table3)
        # self$results$text3$setContent(epirresult)



        epirresult2 <- summary(epirresult)
        epirresult2 <- as.data.frame(epirresult2) %>%
            tibble::rownames_to_column(.data = ., var = 'statsabv')


        epirresult2$statsnames <-
            c(
                "Apparent prevalence",
                "True prevalence",
                "Test sensitivity",
                "Test specificity",
                "Diagnostic accuracy",
                "Diagnostic odds ratio",
                "Number needed to diagnose",
                "Youden's index",
                "Positive predictive value",
                "Negative predictive value",
                "Likelihood ratio of a positive test",
                "Likelihood ratio of a negative test",
                "Proportion of subjects with the outcome ruled out",
                "Proportion of subjects with the outcome ruled in",
                "Proportion of false positives",
                "Proportion of false negative",
                "False Discovery Rate",
                "False Omission Rate"

            )

        ratiorows <- c(
            "ap",
            "tp",
            "se",
            "sp",
            "diag.ac",
            "pv.pos",
            "pv.neg",
            "p.tpdn",
            "p.tndp",
            "p.dntp",
            "p.dptn"
        )


        numberrows <- c(
            "diag.or",
            "nndx",
            "youden",
            "lr.pos",
            "lr.neg"
        )

        epirresult_number <- epirresult2[epirresult2$statistic %in% numberrows, ]

        epirresult_ratio <- epirresult2[epirresult2$statistic %in% ratiorows, ]



         # text4 <-
         #     list(

                 # "summary" = epirresult2

         # epirresult[[3]]$aprev,
         # epirresult[[3]]$tprev,
         # epirresult[[3]]$se,
         # epirresult[[3]]$sp,
         # epirresult[[3]]$diag.acc,
         # epirresult[[3]]$diag.or,
         # epirresult[[3]]$nnd,
         # epirresult[[3]]$youden,
         # epirresult[[3]]$ppv,
         # epirresult[[3]]$npv,
         # epirresult[[3]]$plr,
         # epirresult[[3]]$nlr,
         # epirresult[[3]]$pro,
         # epirresult[[3]]$pri,
         # epirresult[[3]]$pfp,
         # epirresult[[3]]$pfn
             # )







        # self$results$text4$setContent(text4)



        # epirTable_ratio -----

        epirTable_ratio <- self$results$epirTable_ratio

        data_frame <- epirresult_ratio
        for(i in seq_along(data_frame[,1,drop=T])) {
            epirTable_ratio$addRow(rowKey = i, values = c(data_frame[i,])) # This code produces a named vector/list, which is what the values argument expects
        }



        # epirTable_ratio footnotes ----

        # if (self$options$fnote) {
        #
        #     epirTable_ratio$addFootnote(
        #         rowNo = 5,
        #         col = "statsnames",
        #         "Proportion of all tests that give a correct result."
        #         )
        # }






        # epirTable_number ----


        epirTable_number <- self$results$epirTable_number

        data_frame <- epirresult_number
        for(i in seq_along(data_frame[,1,drop=T])) {
            epirTable_number$addRow(rowKey = i, values = c(data_frame[i,]))
        }



        # epirTable_number footnotes ----

        # if (self$options$fnote) {
        #
        #
        #     epirTable_number$addFootnote(
        #         rowNo = 1,
        #         col = "statsnames",
        #         "How much more likely will the test make a correct diagnosis than an incorrect diagnosis in patients with the disease."
        #         )
        #
        #     epirTable_number$addFootnote(
        #         rowNo = 2,
        #         col = "statsnames",
        #         "Number of patients that need to be tested to give one correct positive test."
        #     )
        #
        #
        #     epirTable_number$addFootnote(
        #         rowNo = 3,
        #         col = "statsnames",
        #         "Youden's index is the difference between the true positive rate and the false positive rate. Youden's index ranges from -1 to +1 with values closer to 1 if both sensitivity and specificity are high (i.e. close to 1)."
        #
        #     )
        #
        #
        # }

















                        }




        # Send Data to Plot ----


        plotData1 <- list(
            "Prevalence" = PriorProb,
            "Sens" = Sens,
            "Spec" = Spec,
            "Plr" = LRP,
            "Nlr" = LRN
        )

        image1 <- self$results$plot1
        image1$setState(plotData1)

        # plotData2 <- plotData1
        #
        # image2 <- self$results$plot2
        # image2$setState(plotData2)


            }


        ,

        .plot1 = function(image1, ggtheme, ...) {


            plotData1 <- image1$state

        plot1 <- nomogrammer(Prevalence = plotData1$Prevalence,
                            Sens = plotData1$Sens,
                            Spec = plotData1$Spec,
                            Plr = plotData1$Plr,
                            Nlr = plotData1$Nlr,
                            Detail = TRUE,
                            NullLine = TRUE,
                            LabelSize = (14/5),
                            Verbose = TRUE
                            )

        print(plot1)
        TRUE


        }


        # ,
        # .plot2 = function(image2, ggtheme, ...) {
        #
        #
        #     plotData2 <- image2$state
        #
        #     plot2 <- nomogrammer(Prevalence = plotData2$Prevalence,
        #                          Plr = plotData2$Plr,
        #                          Nlr = plotData2$Nlr,
        #                          Detail = TRUE,
        #                          NullLine = TRUE,
        #                          LabelSize = (14/5),
        #                          Verbose = TRUE
        #     )
        #
        #     print(plot2)
        #     TRUE
        #
        #
        # }
        #



        ))


File: R\decisioncalculator.h.R
--------------------------------------------------
Content of R\decisioncalculator.h.R:

# This file is automatically generated, you probably don't want to edit this

decisioncalculatorOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "decisioncalculatorOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            TP = 90,
            TN = 80,
            FP = 30,
            FN = 20,
            pp = FALSE,
            pprob = 0.3,
            fnote = FALSE,
            ci = FALSE,
            fagan = FALSE, ...) {

            super$initialize(
                package="meddecide",
                name="decisioncalculator",
                requiresData=FALSE,
                ...)

            private$..TP <- jmvcore::OptionNumber$new(
                "TP",
                TP,
                default=90)
            private$..TN <- jmvcore::OptionNumber$new(
                "TN",
                TN,
                default=80)
            private$..FP <- jmvcore::OptionNumber$new(
                "FP",
                FP,
                default=30)
            private$..FN <- jmvcore::OptionNumber$new(
                "FN",
                FN,
                default=20)
            private$..pp <- jmvcore::OptionBool$new(
                "pp",
                pp,
                default=FALSE)
            private$..pprob <- jmvcore::OptionNumber$new(
                "pprob",
                pprob,
                default=0.3,
                min=0.001,
                max=0.999)
            private$..fnote <- jmvcore::OptionBool$new(
                "fnote",
                fnote,
                default=FALSE)
            private$..ci <- jmvcore::OptionBool$new(
                "ci",
                ci,
                default=FALSE)
            private$..fagan <- jmvcore::OptionBool$new(
                "fagan",
                fagan,
                default=FALSE)

            self$.addOption(private$..TP)
            self$.addOption(private$..TN)
            self$.addOption(private$..FP)
            self$.addOption(private$..FN)
            self$.addOption(private$..pp)
            self$.addOption(private$..pprob)
            self$.addOption(private$..fnote)
            self$.addOption(private$..ci)
            self$.addOption(private$..fagan)
        }),
    active = list(
        TP = function() private$..TP$value,
        TN = function() private$..TN$value,
        FP = function() private$..FP$value,
        FN = function() private$..FN$value,
        pp = function() private$..pp$value,
        pprob = function() private$..pprob$value,
        fnote = function() private$..fnote$value,
        ci = function() private$..ci$value,
        fagan = function() private$..fagan$value),
    private = list(
        ..TP = NA,
        ..TN = NA,
        ..FP = NA,
        ..FN = NA,
        ..pp = NA,
        ..pprob = NA,
        ..fnote = NA,
        ..ci = NA,
        ..fagan = NA)
)

decisioncalculatorResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "decisioncalculatorResults",
    inherit = jmvcore::Group,
    active = list(
        cTable = function() private$.items[["cTable"]],
        nTable = function() private$.items[["nTable"]],
        ratioTable = function() private$.items[["ratioTable"]],
        epirTable_ratio = function() private$.items[["epirTable_ratio"]],
        epirTable_number = function() private$.items[["epirTable_number"]],
        plot1 = function() private$.items[["plot1"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Medical Decision Calculator",
                refs=list(
                    "DiagnosticTests",
                    "sensspecwiki",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Table$new(
                options=options,
                name="cTable",
                title="",
                rows=0,
                columns=list(
                    list(
                        `name`="newtest", 
                        `title`="", 
                        `type`="text"),
                    list(
                        `name`="GP", 
                        `title`="Gold Positive", 
                        `type`="number"),
                    list(
                        `name`="GN", 
                        `title`="Gold Negative", 
                        `type`="number"),
                    list(
                        `name`="Total", 
                        `title`="Total", 
                        `type`="number"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="nTable",
                title="",
                swapRowsColumns=TRUE,
                rows=1,
                columns=list(
                    list(
                        `name`="tablename", 
                        `title`="", 
                        `type`="text"),
                    list(
                        `name`="TotalPop", 
                        `title`="Total", 
                        `type`="number"),
                    list(
                        `name`="DiseaseP", 
                        `title`="Diseased", 
                        `type`="number"),
                    list(
                        `name`="DiseaseN", 
                        `title`="Healthy", 
                        `type`="number"),
                    list(
                        `name`="TestP", 
                        `title`="Positive Tests", 
                        `type`="number"),
                    list(
                        `name`="TestN", 
                        `title`="Negative Tests", 
                        `type`="number"),
                    list(
                        `name`="TestT", 
                        `title`="True Test", 
                        `type`="number"),
                    list(
                        `name`="TestW", 
                        `title`="Wrong Test", 
                        `type`="number")),
                clearWith=list(
                    "pp",
                    "pprob")))
            self$add(jmvcore::Table$new(
                options=options,
                name="ratioTable",
                title="",
                swapRowsColumns=TRUE,
                rows=1,
                columns=list(
                    list(
                        `name`="tablename", 
                        `title`="", 
                        `type`="text"),
                    list(
                        `name`="Sens", 
                        `title`="Sensitivity", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="Spec", 
                        `title`="Specificity", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="AccurT", 
                        `title`="Accuracy", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="PrevalenceD", 
                        `title`="Prevalence", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="PPV", 
                        `title`="Positive Predictive Value", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="NPV", 
                        `title`="Negative Predictive Value", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="PostTestProbDisease", 
                        `title`="Post-test Disease Probability", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="PostTestProbHealthy", 
                        `title`="Post-test Health Probability", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="LRP", 
                        `title`="Positive Likelihood Ratio", 
                        `type`="number"),
                    list(
                        `name`="LRN", 
                        `title`="Negative Likelihood Ratio", 
                        `type`="number")),
                clearWith=list(
                    "pp",
                    "pprob")))
            self$add(jmvcore::Table$new(
                options=options,
                name="epirTable_ratio",
                title="",
                visible="(ci)",
                rows=0,
                columns=list(
                    list(
                        `name`="statsnames", 
                        `title`="Decision Statistics", 
                        `type`="text"),
                    list(
                        `name`="est", 
                        `title`="Estimate", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="lower", 
                        `title`="Lower", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="upper", 
                        `title`="Upper", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number", 
                        `format`="pc")),
                clearWith=list(
                    "pp",
                    "pprob"),
                refs=list(
                    "epiR",
                    "sensspecwiki")))
            self$add(jmvcore::Table$new(
                options=options,
                name="epirTable_number",
                title="",
                visible="(ci)",
                rows=0,
                columns=list(
                    list(
                        `name`="statsnames", 
                        `title`="Decision Statistics", 
                        `type`="text"),
                    list(
                        `name`="est", 
                        `title`="Estimate", 
                        `type`="number"),
                    list(
                        `name`="lower", 
                        `title`="Lower", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number"),
                    list(
                        `name`="upper", 
                        `title`="Upper", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number")),
                clearWith=list(
                    "pp",
                    "pprob"),
                refs=list(
                    "epiR",
                    "sensspecwiki")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot1",
                title="Fagan nomogram",
                width=600,
                height=450,
                renderFun=".plot1",
                requiresData=TRUE,
                visible="(fagan)",
                clearWith=list(
                    "pp",
                    "pprob",
                    "fagan"),
                refs=list(
                    "Fagan",
                    "Fagan2",
                    "sensspecwiki")))}))

decisioncalculatorBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "decisioncalculatorBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "meddecide",
                name = "decisioncalculator",
                version = c(1,0,0),
                options = options,
                results = decisioncalculatorResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'na')
        }))

#' Medical Decision Calculator
#'
#' Function for Medical Decision Calculator.
#'
#' @examples
#' \donttest{
#' # example will be added
#'}
#' @param TP .
#' @param TN .
#' @param FP .
#' @param FN .
#' @param pp .
#' @param pprob Prior probability (disease prevalence in the community).
#'   Requires a value between 0.001 and 0.999, default 0.300.
#' @param fnote .
#' @param ci .
#' @param fagan .
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$cTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$nTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$ratioTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$epirTable_ratio} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$epirTable_number} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$plot1} \tab \tab \tab \tab \tab an image \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$cTable$asDF}
#'
#' \code{as.data.frame(results$cTable)}
#'
#' @export
decisioncalculator <- function(
    TP = 90,
    TN = 80,
    FP = 30,
    FN = 20,
    pp = FALSE,
    pprob = 0.3,
    fnote = FALSE,
    ci = FALSE,
    fagan = FALSE) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("decisioncalculator requires jmvcore to be installed (restart may be required)")


    options <- decisioncalculatorOptions$new(
        TP = TP,
        TN = TN,
        FP = FP,
        FN = FN,
        pp = pp,
        pprob = pprob,
        fnote = fnote,
        ci = ci,
        fagan = fagan)

    analysis <- decisioncalculatorClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\kappasizeci.b.R
--------------------------------------------------
Content of R\kappasizeci.b.R:
#' @title Confidence Interval Approach for the Number of Subjects Required
#' @importFrom R6 R6Class
#' @import jmvcore


kappaSizeCIClass <- if (requireNamespace('jmvcore', quietly=TRUE)) R6::R6Class(
    "kappaSizeCIClass",
    inherit = kappaSizeCIBase,
    private = list(
        .run = function() {


            outcome <- self$options$outcome
            kappa0 <- self$options$kappa0
            kappaL <- self$options$kappaL
            kappaU <- self$options$kappaU
            props  <- self$options$props
            raters  <- self$options$raters
            alpha  <- self$options$alpha

            props2 <- strsplit(props, ",")
            props3 <- unlist(props2, use.names = FALSE)
            props4 <- as.numeric(props3)

            if (outcome == 2) {

                text1 <-
                    kappaSize::CIBinary(
                        kappa0 = kappa0,
                        kappaL = kappaL,
                        kappaU = kappaU,
                        props = props4,
                        alpha = alpha,
                        raters = raters
                    )


                text2 <- paste0(
                    "Researchers would like to determine the required sample size to test","\n",
                    "kappa0=", kappa0,
                    " with precision of [kappaL=", kappaL, " - kappaU=", kappaU, "]",
                    " in a study of interobserver agreement with","\n",
                    raters, " raters. ",
                    "Further suppose that the prevalence of the trait is ",
                    props3,
                    ".",
                    sep = " ")


            self$results$text1$setContent(text1)
            self$results$text2$setContent(text2[1])


            }


            if (outcome == 3) {

                text1 <-
                    kappaSize::CI3Cats(
                        kappa0 = kappa0,
                        kappaL = kappaL,
                        kappaU = kappaU,
                        props = props4,
                        alpha = alpha,
                        raters = raters
                        )


                text2 <- paste0(
                    "Researchers would like to determine the required sample size to test","\n",
                    "kappa0=", kappa0,
                    " with precision of [kappaL=", kappaL, " - kappaU=", kappaU, "]",
                    " in a study of interobserver agreement with","\n",
                    raters, " raters. ",
                    "Further suppose that the prevalence of the categories are ",
                    props3[1], "," , props3[2], ", and ", props3[3],
                    ".",
                    sep = " ")


                self$results$text1$setContent(text1)
                self$results$text2$setContent(text2[1])


            }


            if (outcome == 4) {

                text1 <-
                    kappaSize::CI4Cats(
                        kappa0 = kappa0,
                        kappaL = kappaL,
                        kappaU = kappaU,
                        props = props4,
                        alpha = alpha,
                        raters = raters
                        )


                text2 <- paste0(
                    "Researchers would like to determine the required sample size to test","\n",
                    "kappa0=", kappa0,
                    " with precision of [kappaL=", kappaL, " - kappaU=", kappaU, "]",
                    " in a study of interobserver agreement with","\n",
                    raters, " raters. ",
                    "Further suppose that the prevalence of the categories are ",

                    props3[1], "," , props3[2], "," ,props3[3], ", and ", props3[4],
                    ".",
                    sep = " ")


                    self$results$text1$setContent(text1)
                    self$results$text2$setContent(text2[1])


                }


                    if (outcome == 5) {

                        text1 <-
                            kappaSize::CI5Cats(
                                kappa0 = kappa0,
                                kappaL = kappaL,
                                kappaU = kappaU,
                                props = props4,
                                alpha = alpha,
                                raters = raters
                                )


                        text2 <- paste0(
                            "Researchers would like to determine the required sample size to test","\n",
                            "kappa0=", kappa0,
                            " with precision of [kappaL=", kappaL, " - kappaU=", kappaU, "]",
                            " in a study of interobserver agreement with","\n",
                            raters, " raters. ",
                            "Further suppose that the prevalence of the categories are ",

                            props3[1], "," , props3[2], "," , props3[3], "," , props3[4], ", and ", props3[5],
                            ".",
                            sep = " ")


                        self$results$text1$setContent(text1)
                        self$results$text2$setContent(text2[1])


                    }




        })
)


File: R\kappasizeci.h.R
--------------------------------------------------
Content of R\kappasizeci.h.R:

# This file is automatically generated, you probably don't want to edit this

kappaSizeCIOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "kappaSizeCIOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            outcome = "2",
            kappa0 = 0.6,
            kappaL = 0.4,
            kappaU = 0.8,
            props = "0.20 , 0.80",
            raters = "2",
            alpha = 0.05, ...) {

            super$initialize(
                package="meddecide",
                name="kappaSizeCI",
                requiresData=FALSE,
                ...)

            private$..outcome <- jmvcore::OptionList$new(
                "outcome",
                outcome,
                options=list(
                    "2",
                    "3",
                    "4",
                    "5"),
                default="2")
            private$..kappa0 <- jmvcore::OptionNumber$new(
                "kappa0",
                kappa0,
                default=0.6,
                min=0.01,
                max=0.99)
            private$..kappaL <- jmvcore::OptionNumber$new(
                "kappaL",
                kappaL,
                default=0.4,
                min=0.01,
                max=0.99)
            private$..kappaU <- jmvcore::OptionNumber$new(
                "kappaU",
                kappaU,
                default=0.8,
                min=0.01,
                max=0.99)
            private$..props <- jmvcore::OptionString$new(
                "props",
                props,
                default="0.20 , 0.80")
            private$..raters <- jmvcore::OptionList$new(
                "raters",
                raters,
                options=list(
                    "2",
                    "3",
                    "4",
                    "5"),
                default="2")
            private$..alpha <- jmvcore::OptionNumber$new(
                "alpha",
                alpha,
                default=0.05,
                min=0.01,
                max=0.99)

            self$.addOption(private$..outcome)
            self$.addOption(private$..kappa0)
            self$.addOption(private$..kappaL)
            self$.addOption(private$..kappaU)
            self$.addOption(private$..props)
            self$.addOption(private$..raters)
            self$.addOption(private$..alpha)
        }),
    active = list(
        outcome = function() private$..outcome$value,
        kappa0 = function() private$..kappa0$value,
        kappaL = function() private$..kappaL$value,
        kappaU = function() private$..kappaU$value,
        props = function() private$..props$value,
        raters = function() private$..raters$value,
        alpha = function() private$..alpha$value),
    private = list(
        ..outcome = NA,
        ..kappa0 = NA,
        ..kappaL = NA,
        ..kappaU = NA,
        ..props = NA,
        ..raters = NA,
        ..alpha = NA)
)

kappaSizeCIResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "kappaSizeCIResults",
    inherit = jmvcore::Group,
    active = list(
        text1 = function() private$.items[["text1"]],
        text2 = function() private$.items[["text2"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Confidence Interval Approach for the Number of Subjects Required",
                refs=list(
                    "ClinicoPathJamoviModule",
                    "kappaSize"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text1",
                title="Analysis result"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text2",
                title="Study Explanation"))}))

kappaSizeCIBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "kappaSizeCIBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "meddecide",
                name = "kappaSizeCI",
                version = c(1,0,0),
                options = options,
                results = kappaSizeCIResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'na')
        }))

#' Confidence Interval Approach for the Number of Subjects Required
#'
#' Power Analysis for Interobserver Agreement Analysis.
#' 
#'
#' @examples
#' \donttest{
#' # example will be added
#'}
#' @param outcome Number of outcome level.
#' @param kappa0 The null hypothesis value of kappa.
#' @param kappaL The lower limit of the kappa.
#' @param kappaU The upper limit of the kappa.
#' @param props Proportions of outcome level.
#' @param raters Number of raters.
#' @param alpha The significance level.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$text1} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$text2} \tab \tab \tab \tab \tab a preformatted \cr
#' }
#'
#' @export
kappaSizeCI <- function(
    outcome = "2",
    kappa0 = 0.6,
    kappaL = 0.4,
    kappaU = 0.8,
    props = "0.20 , 0.80",
    raters = "2",
    alpha = 0.05) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("kappaSizeCI requires jmvcore to be installed (restart may be required)")


    options <- kappaSizeCIOptions$new(
        outcome = outcome,
        kappa0 = kappa0,
        kappaL = kappaL,
        kappaU = kappaU,
        props = props,
        raters = raters,
        alpha = alpha)

    analysis <- kappaSizeCIClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\kappasizefixedn.b.R
--------------------------------------------------
Content of R\kappasizefixedn.b.R:
#' @title Lowest Expected Value for a fixed sample size
#' @importFrom R6 R6Class
#' @import jmvcore


kappaSizeFixedNClass <- if (requireNamespace('jmvcore', quietly=TRUE)) R6::R6Class(
    "kappaSizeFixedNClass",
    inherit = kappaSizeFixedNBase,
    private = list(
        .run = function() {


            outcome <- self$options$outcome
            kappa0 <- self$options$kappa0
            props  <- self$options$props
            raters  <- self$options$raters
            alpha  <- self$options$alpha
            n  <- self$options$n

            props2 <- strsplit(props, ",")
            props3 <- unlist(props2, use.names = FALSE)
            props4 <- as.numeric(props3)

            if (outcome == 2) {

                text1 <-
                kappaSize::FixedNBinary(
                    kappa0=kappa0,
                    n=n,
                    props=props4,
                    alpha=alpha,
                    raters=raters
                    )

                text2 <- paste0(
                    "Researchers would like to determine the expected lower bound for","\n",
                    "kappa0=", kappa0,
                    " assuming they have access to ", n, " subjects and ", raters, " raters.", "\n",
                    "Further suppose that the prevalence of the trait is ",
                    props3,
                    ".",
                    sep = " ")


                self$results$text1$setContent(text1)
                self$results$text2$setContent(text2[1])


            }


            if (outcome == 3) {

                text1 <-
                    kappaSize::FixedN3Cats(
                        kappa0=kappa0,
                        n=n,
                        props=props4,
                        alpha=alpha,
                        raters=raters
                        )




                text2 <- paste0(
                    "Researchers would like to determine the expected lower bound for","\n",
                    "kappa0=", kappa0,
                    " assuming they have access to ", n, " subjects and ", raters, " raters.", "\n",
                "Further suppose that the prevalence of the categories are ",
                props3[1], "," , props3[2], ", and ", props3[3],
                ".",
                sep = " ")


                self$results$text1$setContent(text1)
                self$results$text2$setContent(text2[1])


            }


            if (outcome == 4) {

                text1 <-
                    kappaSize::FixedN4Cats(
                        kappa0=kappa0,
                        n=n,
                        props=props4,
                        alpha=alpha,
                        raters=raters
                        )


                text2 <- paste0(
                    "Researchers would like to determine the expected lower bound for","\n",
                    "kappa0=", kappa0,
                    " assuming they have access to ", n, " subjects and ", raters, " raters.", "\n",
                    "Further suppose that the prevalence of the categories are ",

                    props3[1], "," , props3[2], "," ,props3[3], ", and ", props3[4],
                    ".",
                    sep = " ")

                self$results$text1$setContent(text1)
                self$results$text2$setContent(text2[1])


            }


            if (outcome == 5) {

                text1 <-
                    kappaSize::FixedN5Cats(
                        kappa0=kappa0,
                        n=n,
                        props=props4,
                        alpha=alpha,
                        raters=raters
                        )

                text2 <- paste0(
                    "Researchers would like to determine the expected lower bound for","\n",
                    "kappa0=", kappa0,
                    " assuming they have access to ", n, " subjects and ", raters, " raters.", "\n",
                    "Further suppose that the prevalence of the categories are ",
                    props3[1], "," , props3[2], "," , props3[3], "," , props3[4], ", and ", props3[5],
                    ".",
                    sep = " ")

                self$results$text1$setContent(text1)
                self$results$text2$setContent(text2[1])


            }



        })
)


File: R\kappasizefixedn.h.R
--------------------------------------------------
Content of R\kappasizefixedn.h.R:

# This file is automatically generated, you probably don't want to edit this

kappaSizeFixedNOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "kappaSizeFixedNOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            outcome = "2",
            kappa0 = 0.4,
            props = "0.20 , 0.80",
            raters = "2",
            alpha = 0.05,
            n = 100, ...) {

            super$initialize(
                package="meddecide",
                name="kappaSizeFixedN",
                requiresData=FALSE,
                ...)

            private$..outcome <- jmvcore::OptionList$new(
                "outcome",
                outcome,
                options=list(
                    "2",
                    "3",
                    "4",
                    "5"),
                default="2")
            private$..kappa0 <- jmvcore::OptionNumber$new(
                "kappa0",
                kappa0,
                default=0.4,
                min=0.01,
                max=0.99)
            private$..props <- jmvcore::OptionString$new(
                "props",
                props,
                default="0.20 , 0.80")
            private$..raters <- jmvcore::OptionList$new(
                "raters",
                raters,
                options=list(
                    "2",
                    "3",
                    "4",
                    "5"),
                default="2")
            private$..alpha <- jmvcore::OptionNumber$new(
                "alpha",
                alpha,
                default=0.05,
                min=0.01,
                max=0.99)
            private$..n <- jmvcore::OptionNumber$new(
                "n",
                n,
                default=100)

            self$.addOption(private$..outcome)
            self$.addOption(private$..kappa0)
            self$.addOption(private$..props)
            self$.addOption(private$..raters)
            self$.addOption(private$..alpha)
            self$.addOption(private$..n)
        }),
    active = list(
        outcome = function() private$..outcome$value,
        kappa0 = function() private$..kappa0$value,
        props = function() private$..props$value,
        raters = function() private$..raters$value,
        alpha = function() private$..alpha$value,
        n = function() private$..n$value),
    private = list(
        ..outcome = NA,
        ..kappa0 = NA,
        ..props = NA,
        ..raters = NA,
        ..alpha = NA,
        ..n = NA)
)

kappaSizeFixedNResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "kappaSizeFixedNResults",
    inherit = jmvcore::Group,
    active = list(
        text1 = function() private$.items[["text1"]],
        text2 = function() private$.items[["text2"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Lowest Expected Value for a fixed sample size",
                refs=list(
                    "ClinicoPathJamoviModule",
                    "kappaSize"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text1",
                title="Analysis result"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text2",
                title="Study Explanation"))}))

kappaSizeFixedNBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "kappaSizeFixedNBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "meddecide",
                name = "kappaSizeFixedN",
                version = c(1,0,0),
                options = options,
                results = kappaSizeFixedNResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'na')
        }))

#' Lowest Expected Value for a fixed sample size
#'
#' Lowest Expected Value for a fixed sample size.
#' 
#'
#' @examples
#' \donttest{
#' # example will be added
#'}
#' @param outcome Number of outcome level.
#' @param kappa0 Expected value of kappa.
#' @param props Proportions of outcome level.
#' @param raters Number of raters.
#' @param alpha Significance level.
#' @param n Sample size.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$text1} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$text2} \tab \tab \tab \tab \tab a preformatted \cr
#' }
#'
#' @export
kappaSizeFixedN <- function(
    outcome = "2",
    kappa0 = 0.4,
    props = "0.20 , 0.80",
    raters = "2",
    alpha = 0.05,
    n = 100) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("kappaSizeFixedN requires jmvcore to be installed (restart may be required)")


    options <- kappaSizeFixedNOptions$new(
        outcome = outcome,
        kappa0 = kappa0,
        props = props,
        raters = raters,
        alpha = alpha,
        n = n)

    analysis <- kappaSizeFixedNClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\kappasizepower.b.R
--------------------------------------------------
Content of R\kappasizepower.b.R:
#' @title Power Approach for the Number of Subjects Required
#' @importFrom R6 R6Class
#' @import jmvcore


kappaSizePowerClass <- if (requireNamespace('jmvcore', quietly=TRUE)) R6::R6Class(
    "kappaSizePowerClass",
    inherit = kappaSizePowerBase,
    private = list(
        .run = function() {

            outcome <- self$options$outcome
            kappa0 <- self$options$kappa0
            kappa1 <- self$options$kappa1
            props  <- self$options$props
            raters  <- self$options$raters
            alpha  <- self$options$alpha
            power  <- self$options$power

            props2 <- strsplit(props, ",")
            props3 <- unlist(props2, use.names = FALSE)
            props4 <- as.numeric(props3)

            if (outcome == 2) {

            text1 <-
            kappaSize::PowerBinary(
                kappa0 = kappa0,
                kappa1 = kappa1,
                props = props4,
                raters = raters,
                alpha = alpha,
                power = power
                )

            text2 <- paste0(
                "Researchers would like to determine the required sample size to test","\n",
                "kappa0=", kappa0,
                " vs.",
                " kappa1=", kappa1,
                " with alpha=",alpha,
                " and power=", power,"\n",
                "in a study of interobserver agreement with ",
                raters, " raters. ","\n",
                "Further suppose that the prevalence of the trait is ",
                props3,
                ".",
                sep = " ")


            self$results$text1$setContent(text1)
            self$results$text2$setContent(text2[1])

        }


            if (outcome == 3) {


                text1 <-
                    kappaSize::Power3Cats(
                        kappa0 = kappa0,
                        kappa1 = kappa1,
                        props = props4,
                        raters = raters,
                        alpha = alpha,
                        power = power
                        )


                text2 <- paste0(
                    "Researchers would like to determine the required sample size to test","\n",
                    "kappa0=", kappa0,
                    " vs.",
                    " kappa1=", kappa1,
                    " with alpha=",alpha,
                    " and power=", power,"\n",
                    "in a study of interobserver agreement with ",
                    raters, " raters. ","\n",
                    "Further suppose that the prevalence of the categories are ",
                    props3[1], "," , props3[2], ", and ", props3[3],
                    ".",
                    sep = " ")

                self$results$text1$setContent(text1)
                self$results$text2$setContent(text2[1])


                            }


            if (outcome == 4) {

                text1 <-
                    kappaSize::Power4Cats(
                        kappa0 = kappa0,
                        kappa1 = kappa1,
                        props = props4,
                        raters = raters,
                        alpha = alpha,
                        power = power
                        )

                text2 <- paste0(
                    "Researchers would like to determine the required sample size to test","\n",
                    "kappa0=", kappa0,
                    " vs.",
                    " kappa1=", kappa1,
                    " with alpha=",alpha,
                    " and power=", power,"\n",
                    "in a study of interobserver agreement with ",
                    raters, " raters. ","\n",
                    "Further suppose that the prevalence of the categories are ",

                    props3[1], "," , props3[2], "," ,props3[3], ", and ", props3[4],
                    ".",
                    sep = " ")

                self$results$text1$setContent(text1)
                self$results$text2$setContent(text2[1])

                }


            if (outcome == 5) {

                text1 <-
                    kappaSize::Power5Cats(
                        kappa0 = kappa0,
                        kappa1 = kappa1,
                        props = props4,
                        raters = raters,
                        alpha = alpha,
                        power = power
                        )

                text2 <- paste0(
                    "Researchers would like to determine the required sample size to test","\n",
                    "kappa0=", kappa0,
                    " vs.",
                    " kappa1=", kappa1,
                    " with alpha=",alpha,
                    " and power=", power, "\n",
                    "in a study of interobserver agreement with ",
                    raters, " raters. ","\n",
                    "Further suppose that the prevalence of the categories are ",

                    props3[1], "," , props3[2], "," , props3[3], "," , props3[4], ", and ", props3[5],
                    ".",
                    sep = " ")






                self$results$text1$setContent(text1)
                self$results$text2$setContent(text2[1])


            }


        })
)


File: R\kappasizepower.h.R
--------------------------------------------------
Content of R\kappasizepower.h.R:

# This file is automatically generated, you probably don't want to edit this

kappaSizePowerOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "kappaSizePowerOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            outcome = "2",
            kappa0 = 0.4,
            kappa1 = 0.6,
            props = "0.20 , 0.80",
            raters = "2",
            alpha = 0.05,
            power = 0.8, ...) {

            super$initialize(
                package="meddecide",
                name="kappaSizePower",
                requiresData=FALSE,
                ...)

            private$..outcome <- jmvcore::OptionList$new(
                "outcome",
                outcome,
                options=list(
                    "2",
                    "3",
                    "4",
                    "5"),
                default="2")
            private$..kappa0 <- jmvcore::OptionNumber$new(
                "kappa0",
                kappa0,
                default=0.4,
                min=0.01,
                max=0.99)
            private$..kappa1 <- jmvcore::OptionNumber$new(
                "kappa1",
                kappa1,
                default=0.6,
                min=0.01,
                max=0.99)
            private$..props <- jmvcore::OptionString$new(
                "props",
                props,
                default="0.20 , 0.80")
            private$..raters <- jmvcore::OptionList$new(
                "raters",
                raters,
                options=list(
                    "2",
                    "3",
                    "4",
                    "5"),
                default="2")
            private$..alpha <- jmvcore::OptionNumber$new(
                "alpha",
                alpha,
                default=0.05,
                min=0.01,
                max=0.99)
            private$..power <- jmvcore::OptionNumber$new(
                "power",
                power,
                default=0.8,
                min=0.01,
                max=0.99)

            self$.addOption(private$..outcome)
            self$.addOption(private$..kappa0)
            self$.addOption(private$..kappa1)
            self$.addOption(private$..props)
            self$.addOption(private$..raters)
            self$.addOption(private$..alpha)
            self$.addOption(private$..power)
        }),
    active = list(
        outcome = function() private$..outcome$value,
        kappa0 = function() private$..kappa0$value,
        kappa1 = function() private$..kappa1$value,
        props = function() private$..props$value,
        raters = function() private$..raters$value,
        alpha = function() private$..alpha$value,
        power = function() private$..power$value),
    private = list(
        ..outcome = NA,
        ..kappa0 = NA,
        ..kappa1 = NA,
        ..props = NA,
        ..raters = NA,
        ..alpha = NA,
        ..power = NA)
)

kappaSizePowerResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "kappaSizePowerResults",
    inherit = jmvcore::Group,
    active = list(
        text1 = function() private$.items[["text1"]],
        text2 = function() private$.items[["text2"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Power Approach for the Number of Subjects Required",
                refs=list(
                    "ClinicoPathJamoviModule",
                    "kappaSize"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text1",
                title="Analysis result"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="text2",
                title="Study Explanation"))}))

kappaSizePowerBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "kappaSizePowerBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "meddecide",
                name = "kappaSizePower",
                version = c(1,0,0),
                options = options,
                results = kappaSizePowerResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'na')
        }))

#' Power Approach for the Number of Subjects Required
#'
#' Power Analysis for Interobserver Agreement Analysis.
#' 
#'
#' @examples
#' \donttest{
#' # example will be added
#'}
#' @param outcome Number of outcome level.
#' @param kappa0 Expected value of kappa.
#' @param kappa1 Expected value of kappa.
#' @param props Proportions of outcome level.
#' @param raters Number of raters.
#' @param alpha Significance level.
#' @param power Power.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$text1} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$text2} \tab \tab \tab \tab \tab a preformatted \cr
#' }
#'
#' @export
kappaSizePower <- function(
    outcome = "2",
    kappa0 = 0.4,
    kappa1 = 0.6,
    props = "0.20 , 0.80",
    raters = "2",
    alpha = 0.05,
    power = 0.8) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("kappaSizePower requires jmvcore to be installed (restart may be required)")


    options <- kappaSizePowerOptions$new(
        outcome = outcome,
        kappa0 = kappa0,
        kappa1 = kappa1,
        props = props,
        raters = raters,
        alpha = alpha,
        power = power)

    analysis <- kappaSizePowerClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\meddecide-data.R
--------------------------------------------------
Content of R\meddecide-data.R:
#' @title histopathology
#'
#' @description Fake histopathology research data.
#' @usage data(histopathology)
#' @format A data frame
"histopathology"



File: R\meddecide-package.R
--------------------------------------------------
Content of R\meddecide-package.R:
#' \code{meddecide}
#'
#' @title Functions for Medical Decision Making in ClinicoPath jamovi Module
#'
#' @description `meddecide` meddecide help researchers to generate natural
#' language summaries of their dataset, generate cross tables with statistical
#' tests, and survival analysis with survival tables, survival plots,
#' and natural language summaries.
#'
# @details The main functions are-
# \itemize{
#   \item \code{\link[tableone]{tableone}} function to produce Table One.
#  }
#'
#' For more documentation, see the
#' \href{https://sbalci.github.io/ClinicoPathJamoviModule/}{Website}.
#'
#' @docType package
#' @aliases meddecide meddecide-package
#' @name meddecide-package
"_PACKAGE"


File: R\meddecide-stats_utils.R
--------------------------------------------------
Content of R\meddecide-stats_utils.R:
#' @title Statistical Utility Functions
#' @description Functions for calculating confidence intervals and test statistics

#' Calculate AUC confidence intervals
#' @param auc Area under curve value
#' @param n_pos Number of positive cases
#' @param n_neg Number of negative cases
#' @param conf_level Confidence level (default 0.95)
#' @return Vector containing lower and upper CI bounds
#' #' @export
auc_ci <- function(auc, n_pos, n_neg, conf_level = 0.95) {
  if (!is.numeric(auc) || auc < 0 || auc > 1) {
    stop("AUC must be between 0 and 1")
  }
  if (!is.numeric(n_pos) || !is.numeric(n_neg) ||
      n_pos < 1 || n_neg < 1) {
    stop("Sample sizes must be positive integers")
  }

  se <- sqrt((auc * (1-auc)) / min(n_pos, n_neg))
  z <- qnorm(1 - (1-conf_level)/2)
  ci <- c(auc - z*se, auc + z*se)
  ci <- pmax(0, pmin(1, ci)) # Constrain to [0,1]
  return(ci)
}


#' Bootstrap confidence intervals for diagnostic metrics
#' @param data Data frame containing test results
#' @param metric Function to calculate desired metric
#' @param R Number of bootstrap iterations
#' @return List containing point estimate and confidence intervals
bootstrap_ci <- function(data, metric, R = 1000) {
  boot_results <- boot::boot(data, metric, R = R)
  ci <- boot::boot.ci(boot_results, type = "bca")
  return(list(
    estimate = boot_results$t0,
    ci_lower = ci$bca[4],
    ci_upper = ci$bca[5]
  ))
}


File: R\meddecide-utils.R
--------------------------------------------------
Content of R\meddecide-utils.R:
#' @title Utility functions for ROC curve analysis and comparison
#' @description Functions for ROC curve analysis, including DeLong's test and bootstrap comparisons
#' @name roc_utils
#' @importFrom stats pnorm pt qnorm pchisq friedman.test t.test p.adjust cov
#' @importFrom Matrix nearPD
#' @importFrom boot boot
#' @importFrom stats quantile
#' @importFrom tidyr gather
#' @importFrom RColorBrewer brewer.pal
NULL

#' Calculate confidence intervals for ROC curve
#' @keywords internal
calculate_ci_roc <- function(data, indices) {
  if (!all(c("test_pos", "disease_pos") %in% names(data))) {
    stop("Data must contain 'test_pos' and 'disease_pos' columns")
  }

  d <- data[indices, ]
  tp <- sum(d$test_pos & d$disease_pos, na.rm = TRUE)
  fp <- sum(d$test_pos & !d$disease_pos, na.rm = TRUE)
  tn <- sum(!d$test_pos & !d$disease_pos, na.rm = TRUE)
  fn <- sum(!d$test_pos & d$disease_pos, na.rm = TRUE)

  sens <- if(tp + fn > 0) tp / (tp + fn) else 0
  spec <- if(tn + fp > 0) tn / (tn + fp) else 0

  return(c(sens = sens, spec = spec))
}

#' Compare AUCs of two diagnostic tests
#' @keywords internal
compare_auc <- function(test1, test2) {
  required_fields <- c("sens", "spec", "n_pos", "n_neg")
  if (!all(required_fields %in% names(test1)) ||
      !all(required_fields %in% names(test2))) {
    stop("Test data must contain sensitivity, specificity, and sample sizes")
  }

  auc1 <- calculate_auc(test1$sens, test1$spec)
  auc2 <- calculate_auc(test2$sens, test2$spec)

  se1 <- calculate_se(auc1, test1$n_pos, test1$n_neg)
  se2 <- calculate_se(auc2, test2$n_pos, test2$n_neg)

  z <- (auc1 - auc2) / sqrt(se1^2 + se2^2)
  p_value <- 2 * (1 - pnorm(abs(z)))

  return(list(
    auc_diff = auc1 - auc2,
    z_stat = z,
    p_value = p_value,
    se = sqrt(se1^2 + se2^2)
  ))
}

#' Calculate AUC from sensitivity and specificity
#' @keywords internal
calculate_auc <- function(sens, spec) {
  0.5 * (sens * (1-spec)) + 0.5 * (1 * (1-(1-spec))) + 0.5 * ((1-sens) * spec)
}

#' Calculate standard error for AUC
#' @keywords internal
calculate_se <- function(auc, n_pos, n_neg) {
  sqrt((auc * (1-auc)) / min(n_pos, n_neg))
}

#' Calculate DeLong covariance matrix
#' @keywords internal
calculate_delong_cov <- function(V10, V01) {
  if (!is.matrix(V10) || !is.matrix(V01)) {
    stop("Placement values must be matrices")
  }

  n1 <- nrow(V10)
  n2 <- nrow(V01)

  S10 <- if(n1 > 1) stats::cov(V10) / n1 else matrix(0, 1, 1)
  S01 <- if(n2 > 1) stats::cov(V01) / n2 else matrix(0, 1, 1)

  return(S10 + S01)
}

#' Compare multiple ROC curves using DeLong's test
#' @param test_data List of test results
#' @param paired Logical indicating whether tests are paired
#' @return A list containing test results with the following components:
#'   \item{overall}{Overall test results including chi-square statistic and p-value}
#'   \item{pairwise}{Matrix of pairwise comparison p-values}
#'   \item{aucs}{Vector of AUC values for each test}
#'   \item{covariance}{Covariance matrix of the tests}
#' @export
delong_test <- function(test_data, paired = TRUE) {
  if (!is.list(test_data) || length(test_data) < 2) {
    stop("test_data must be a list containing at least two tests")
  }

  n_tests <- length(test_data)
  test_names <- names(test_data)
  if (is.null(test_names)) {
    test_names <- paste0("Test", 1:n_tests)
  }

  placement_values <- calculate_placement_values(test_data)
  V10 <- placement_values$V10
  V01 <- placement_values$V01

  cov_matrix <- tryCatch({
    cov_mat <- calculate_delong_cov(V10, V01)
    as.matrix(Matrix::nearPD(cov_mat)$mat)
  }, error = function(e) {
    warning("Error in covariance calculation, using diagonal matrix")
    diag(n_tests)
  })

  results <- calculate_delong_results(test_data, cov_matrix, test_names)

  return(results)
}

#' Calculate placement values for DeLong's test
#' @keywords internal
calculate_placement_values <- function(test_data) {
  n_tests <- length(test_data)
  n1 <- test_data[[1]]$n_pos
  n2 <- test_data[[1]]$n_neg

  V10 <- matrix(0, nrow = n1, ncol = n_tests)
  V01 <- matrix(0, nrow = n2, ncol = n_tests)

  for(i in seq_len(n_tests)) {
    test <- test_data[[i]]
    V10[,i] <- test$placement_values_diseased
    V01[,i] <- test$placement_values_healthy
  }

  list(V10 = V10, V01 = V01)
}

#' Compare ROC curves using bootstrap method
#' @param test_data List of test results
#' @param n_bootstrap Number of bootstrap iterations
#' @return A list containing bootstrap comparison results:
#'   \item{overall}{Overall comparison results using Friedman test}
#'   \item{pairwise}{Matrix of pairwise comparison p-values}
#' @export
bootstrap_roc_test <- function(test_data, n_bootstrap = 1000) {
  if (n_bootstrap < 100) {
    warning("Number of bootstrap iterations may be too low")
  }

  boot_data <- prepare_bootstrap_data(test_data)
  boot_results <- perform_bootstrap(boot_data, n_bootstrap)

  results <- calculate_bootstrap_results(boot_results, names(test_data))

  return(results)
}

#' Prepare data for bootstrap analysis
#' @keywords internal
prepare_bootstrap_data <- function(test_data) {
  if (!is.list(test_data) || length(test_data) < 2) {
    stop("test_data must be a list containing at least two tests")
  }

  data.frame(
    test_pos = rep(TRUE, sum(sapply(test_data, function(x) x$n_pos))),
    disease_pos = rep(TRUE, sum(sapply(test_data, function(x) x$n_pos)))
  )
}

#' Calculate bootstrap results
#' @keywords internal
calculate_bootstrap_results <- function(boot_results, test_names) {
  n_tests <- length(test_names)

  auc_matrix <- extract_auc_matrix(boot_results, n_tests)

  results <- list(
    overall = calculate_overall_comparison(auc_matrix),
    pairwise = calculate_pairwise_comparisons(auc_matrix, test_names)
  )

  return(results)
}


#' Compare multiple diagnostic tests
#' @param tests List of test results
#' @param method Method for comparison ("delong" or "bootstrap")
#' @return List containing test results
compare_tests <- function(tests, method = "delong") {
  if (method == "delong") {
    results <- delong_test(tests)
  } else {
    results <- bootstrap_roc_test(tests)
  }

  return(results)
}

#' DeLong's test for comparing ROC curves
#' @param roc1 First ROC curve data
#' @param roc2 Second ROC curve data
#' @return List containing test statistic and p-value
delong_test <- function(roc1, roc2) {
  # Calculate variance-covariance matrix
  v1 <- var(roc1$scores[roc1$labels == 1])
  v2 <- var(roc2$scores[roc2$labels == 1])
  cov12 <- cov(roc1$scores[roc1$labels == 1],
               roc2$scores[roc2$labels == 1])

  # Calculate test statistic
  z <- (roc1$auc - roc2$auc) /
    sqrt(v1/roc1$n + v2/roc2$n - 2*cov12/sqrt(roc1$n*roc2$n))

  # Calculate p-value
  p <- 2 * (1 - pnorm(abs(z)))

  return(list(
    statistic = z,
    p.value = p
  ))
}



File: R\stats_utils.R
--------------------------------------------------
Content of R\stats_utils.R:
#' @title Statistical Utility Functions
#' @description Functions for calculating confidence intervals and test statistics

#' Calculate AUC confidence intervals
#' @param auc Area under curve value
#' @param n_pos Number of positive cases
#' @param n_neg Number of negative cases
#' @param conf_level Confidence level (default 0.95)
#' @return Vector containing lower and upper CI bounds
#' #' @export
auc_ci <- function(auc, n_pos, n_neg, conf_level = 0.95) {
  if (!is.numeric(auc) || auc < 0 || auc > 1) {
    stop("AUC must be between 0 and 1")
  }
  if (!is.numeric(n_pos) || !is.numeric(n_neg) ||
      n_pos < 1 || n_neg < 1) {
    stop("Sample sizes must be positive integers")
  }

  se <- sqrt((auc * (1-auc)) / min(n_pos, n_neg))
  z <- qnorm(1 - (1-conf_level)/2)
  ci <- c(auc - z*se, auc + z*se)
  ci <- pmax(0, pmin(1, ci)) # Constrain to [0,1]
  return(ci)
}


#' Bootstrap confidence intervals for diagnostic metrics
#' @param data Data frame containing test results
#' @param metric Function to calculate desired metric
#' @param R Number of bootstrap iterations
#' @return List containing point estimate and confidence intervals
bootstrap_ci <- function(data, metric, R = 1000) {
  boot_results <- boot::boot(data, metric, R = R)
  ci <- boot::boot.ci(boot_results, type = "bca")
  return(list(
    estimate = boot_results$t0,
    ci_lower = ci$bca[4],
    ci_upper = ci$bca[5]
  ))
}


File: tests\testthat\test-decision.R
--------------------------------------------------
Content of tests\testthat\test-decision.R:
context("Medical Decision Analysis")

test_that("sensitivity calculation is correct", {
  expect_equal(calculate_sensitivity(tp = 90, fn = 10), 0.9)
  expect_equal(calculate_sensitivity(tp = 0, fn = 10), 0)
  expect_equal(calculate_sensitivity(tp = 50, fn = 50), 0.5)
})

test_that("specificity calculation is correct", {
  expect_equal(calculate_specificity(tn = 80, fp = 20), 0.8)
  expect_equal(calculate_specificity(tn = 0, fp = 20), 0)
  expect_equal(calculate_specificity(tn = 50, fp = 50), 0.5)
})

test_that("AUC calculation is correct", {
  expect_equal(calculate_auc(sens = 0.9, spec = 0.8), 0.85)
  expect_true(calculate_auc(sens = 1, spec = 1) <= 1)
  expect_true(calculate_auc(sens = 0, spec = 0) >= 0)
})


