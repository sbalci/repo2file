Directory Structure:
-------------------
/ 
├── data/
│   ├── histopathology.rda
│   ├── histopathologySurvival.omv
│   ├── response_to_treatment.omv
│   └── response_to_treatment.rds
├── docs/
│   ├── reference/
│   │   ├── histopathology.html
│   │   ├── index.html
│   │   ├── jsurvival-package.html
│   │   ├── multisurvival.html
│   │   ├── multisurvivalClass.html
│   │   ├── oddsratio.html
│   │   ├── oddsratioClass.html
│   │   ├── Rplot001.png
│   │   ├── singlearm.html
│   │   ├── singlearmClass.html
│   │   ├── survival.html
│   │   ├── survivalClass.html
│   │   ├── survivalcont.html
│   │   └── survivalcontClass.html
│   ├── 404.html
│   ├── authors.html
│   ├── bootstrap-toc.css
│   ├── bootstrap-toc.js
│   ├── docsearch.css
│   ├── docsearch.js
│   ├── index.html
│   ├── LICENSE.html
│   ├── link.svg
│   ├── pkgdown.css
│   ├── pkgdown.js
│   ├── pkgdown.yml
│   └── sitemap.xml
├── jamovi/
│   ├── 0000.yaml
│   ├── 00refs.yaml
│   ├── multisurvival.a.yaml
│   ├── multisurvival.r.yaml
│   ├── multisurvival.u.yaml
│   ├── oddsratio.a.yaml
│   ├── oddsratio.r.yaml
│   ├── oddsratio.u.yaml
│   ├── singlearm.a.yaml
│   ├── singlearm.r.yaml
│   ├── singlearm.u.yaml
│   ├── survival.a.yaml
│   ├── survival.r.yaml
│   ├── survival.u.yaml
│   ├── survivalcont.a.yaml
│   ├── survivalcont.r.yaml
│   └── survivalcont.u.yaml
├── man/
│   ├── histopathology.Rd
│   ├── jsurvival-package.Rd
│   ├── multisurvival.Rd
│   ├── multisurvivalClass.Rd
│   ├── oddsratio.Rd
│   ├── oddsratioClass.Rd
│   ├── singlearm.Rd
│   ├── singlearmClass.Rd
│   ├── survival.Rd
│   ├── survivalClass.Rd
│   ├── survivalcont.Rd
│   └── survivalcontClass.Rd
├── R/
│   ├── 00jmv.R
│   ├── jsurvival-data.R
│   ├── jsurvival-package.R
│   ├── multisurvival.b.R
│   ├── multisurvival.h.R
│   ├── oddsratio.b.R
│   ├── oddsratio.h.R
│   ├── singlearm.b.R
│   ├── singlearm.h.R
│   ├── survival.b.R
│   ├── survival.h.R
│   ├── survivalcont.b.R
│   └── survivalcont.h.R
├── .gitattributes
├── .Rbuildignore
├── DESCRIPTION
├── jsurvival.code-workspace
├── jsurvival.Rproj
├── jsurvival_0.0.2.40.jmo
├── jsurvival_0.0.2.46.jmo
├── LICENSE.md
├── NAMESPACE
└── README.md

File Contents:
--------------
File: jamovi\0000.yaml
--------------------------------------------------
Content of jamovi\0000.yaml:
---
title: Survival Module of ClinicoPath for jamovi
name: jsurvival
version: 0.0.2.46
jms: '1.0'
authors:
  - Serdar Balci
maintainer: Serdar Balci <serdarbalci@serdarbalci.com>
date: '2025-01-12'
type: R
description: >-
  Survival Module of ClinicoPath for jamovi ClinicoPath help researchers to
  generate natural language summaries of their dataset, generate cross tables
  with statistical tests, and survival analysis with survival tables, survival
  plots, and natural language summaries.
analyses:
  - title: Single Arm Survival
    name: singlearm
    ns: jsurvival
    menuGroup: Survival
    menuTitle: Single Arm Survival
    menuSubgroup: ClinicoPath Survival
    menuSubtitle: Survival for whole group, no explanatory factor
    description: >-
      Performs survival analysis for a single cohort of patients without group
      comparisons. Use this when you want to analyze overall survival
      characteristics of your entire study population - for example, to
      determine median survival time or 1/3/5-year survival rates for all
      patients collectively. This differs from regular survival analysis which
      compares survival between groups.
  - title: Survival Analysis
    name: survival
    ns: jsurvival
    menuGroup: Survival
    menuSubgroup: ClinicoPath Survival
    menuTitle: Survival Analysis
    description: Function for Generating Summaries for Survival Analysis.
    menuSubtitle: Univariate Survival Analysis, Cox, Kaplan-Meier, 1,3,5-yr
  - title: Survival Analysis for Continuous Variable
    name: survivalcont
    ns: jsurvival
    menuGroup: Survival
    menuSubgroup: ClinicoPath Survival
    menuTitle: Survival Analysis for Continuous Variable
    menuSubtitle: Cut-off & Univariate Survival Analysis
  - title: Multivariable Survival Analysis
    name: multisurvival
    ns: jsurvival
    menuGroup: Survival
    menuSubgroup: ClinicoPath Survival
    menuTitle: Multivariable Survival Analysis
    description: Function for Multivariable Survival Analysis using Cox-regression.
    menuSubtitle: Multivariable Cox-regression, Adjusted Survival
  - title: Odds Ratio Table and Plot
    name: oddsratio
    ns: jsurvival
    menuGroup: Survival
    menuSubgroup: ClinicoPath Survival
    menuTitle: Odds Ratio Table and Plot
    description: Function for Odds Ratio Table and Plot.
    menuSubtitle: Odds Ratio for Binary Outcomes
datasets:
  - name: histopathology including analysis
    path: histopathologySurvival.omv
    description: Example survival analysis for histopathology data
    tags:
      - Survival
      - Natural Language
usesNative: true
minApp: 1.8.1

...


File: jamovi\00refs.yaml
--------------------------------------------------
Content of jamovi\00refs.yaml:
---
refs:
    emmeans:
        type: 'software'
        author: Lenth, R.
        year: 2018
        title: 'emmeans: Estimated Marginal Means, aka Least-Squares Means'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=emmeans'
        url: https://CRAN.R-project.org/package=emmeans

    afex:
        type: 'software'
        author: Singmann, H.
        year: 2018
        title: 'afex: Analysis of Factorial Experiments'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=afex'
        url: https://CRAN.R-project.org/package=afex

    R:
        type: 'software'
        author: R Core Team
        year: 2018
        title: 'A Language and Envionment for Statistical Computing'
        publisher: '[Computer software]. Retrieved from https://CRAN.R-project.org/'
        url: https://CRAN.R-project.org/

    BF:
        type: 'software'
        author: Morey, R. D., & Rouder, J. N.
        year: 2018
        title: 'BayesFactor: Computation of Bayes Factors for Common Designs'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=BayesFactor'
        url: https://CRAN.R-project.org/package=BayesFactor

    btt:
        type: 'article'
        author: Rouder, J. N., Speckman, P. L., Sun, D., Morey, R. D., & Iverson, G.
        year: 2009
        title: Bayesian t tests for accepting and rejecting the null hypothesis
        publisher: Psychonomic Bulletin & Review
        volume: 16
        pages: 225-237

    car:
        type: 'software'
        author: Fox, J., & Weisberg, S.
        year: 2018
        title: 'car: Companion to Applied Regression'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=car'
        url: https://CRAN.R-project.org/package=car

    ggplot2:
        type: 'software'
        author: Wickham, H., Chang, W., Henry, L., Pedersen, T. L., Takahashi, K., Wilke, C., Woo, K., & RStudio
        year: 2018
        title: 'ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ggplot2'
        url: https://CRAN.R-project.org/package=ggplot2

    ggridges:
        type: 'software'
        author: Wilke, C., & RStudio
        year: 2018
        title: 'ggridges: Ridgeline Plots in ggplot2'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ggridges'
        url: https://CRAN.R-project.org/package=ggridges

    mvnormtest:
        type: 'software'
        author: Jarek, S.
        year: 2012
        title: 'mvnormtest: Normality test for multivariate variables'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=mvnormtest'
        url: https://CRAN.R-project.org/package=mvnormtest

    PMCMR:
        type: 'software'
        author: Pohlert, T.
        year: 2018
        title: 'PMCMR: Calculate Pairwise Multiple Comparisons of Mean Rank Sums'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=PMCMR'
        url: https://CRAN.R-project.org/package=PMCMR

    ROCR:
        type: 'software'
        author: Sing, T., Sander, O., Beerenwinkel, N., & Lengauer, T.
        year: 2015
        title: 'ROCR: Visualizing the Performance of Scoring Classifiers'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ROCR'
        url: https://CRAN.R-project.org/package=ROCR

    nnet:
        type: 'software'
        author: Ripley, B., Venables W.
        year: 2016
        title: 'nnet: Feed-Forward Neural Networks and Multinomial Log-Linear Models'
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=nnet'
        url: https://CRAN.R-project.org/package=nnet

    MASS:
        type: 'software'
        author: Ripley, B., Venables W., Bates, D. M., Hornik, K., Gebhardt, A., & Firth, D.
        year: 2018
        title: "MASS: Support Functions and Datasets for Venables and Ripley's MASS"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=MASS'
        url: https://CRAN.R-project.org/package=MASS

    vcd:
        type: 'software'
        author: Meyer, D., Zeileis, A., Hornik, K., Gerber, F., & Friendly, M.
        year: 2017
        title: "vcd: Visualizing Categorical Data"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=vcd'
        url: https://CRAN.R-project.org/package=vcd

    vcdExtra:
        type: 'software'
        author: Friendly M., Turner, H., Zeileis, A., Murdoch, D., & Firth, D.
        year: 2017
        title: "vcdExtra: 'vcd' Extensions and Additions"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=vcdExtra'
        url: https://CRAN.R-project.org/package=vcdExtra

    exact2x2:
        type: 'software'
        author: Fay, M. P., Hunsberger, S. A., Nason, M., & Gabriel, E.
        year: 2018
        title: "exact2x2: Exact Tests and Confidence Intervals for 2x2 Tables"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=exact2x2'
        url: https://CRAN.R-project.org/package=exact2x2

    psych:
        type: 'software'
        author: Revelle, W.
        year: 2019
        title: "psych: Procedures for Psychological, Psychometric, and Personality Research"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=psych'
        url: https://CRAN.R-project.org/package=psych

    lavaan:
        type: 'software'
        author: Rosseel, Y., et al.
        year: 2018
        title: "lavaan: Latent Variable Analysis"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=lavaan'
        url: https://CRAN.R-project.org/package=lavaan

    semPlot:
        type: 'software'
        author: Epskamp, S.
        year: 2017
        title: "semPlot: Path Diagrams and Visual Analysis of Various SEM Packages' Output"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=semPlot'
        url: https://CRAN.R-project.org/package=semPlot

    ggstatsplot:
        type: 'software'
        author: Patil, I.
        year: 2018
        title: "ggstatsplot: 'ggplot2' Based Plots with Statistical Details"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ggstatsplot'
        url: https://CRAN.R-project.org/package=ggstatsplot
        doi: '10.5281/zenodo.2074621'

    ggstatsplot_article:
        type: 'article'
        author: Patil, I.
        year: 2021
        title: "Visualizations with statistical details: The 'ggstatsplot' approach."
        publisher: 'PsyArxiv'
        doi: 'doi:10.31234/osf.io/p7mku'


    report:
        type: 'software'
        author: Makowski, Dominique, Lüdecke, Daniel
        year: 2019
        title: "The report package for R: Ensuring the use of best practices for results reporting"
        publisher: '[R package]. Retrieved from https://github.com/easystats/report'
        url: https://github.com/easystats/report

    arsenal:
        type: 'software'
        author: Heinzen, E Sinnwell, J Atkinson, E Gunderson, T Dougherty, G
        year: 2018
        title: "arsenal: An Arsenal of 'R' Functions for Large-Scale Statistical Summaries"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=arsenal'
        url: https://CRAN.R-project.org/package=arsenal

    tangram:
        type: 'software'
        author: Garbett, S.
        year: 2018
        title: "tangram: The Grammar of Tables"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=tangram'
        url: https://CRAN.R-project.org/package=tangram

    irr:
        type: 'software'
        author: Matthias Gamer, Jim Lemon, Ian Fellows, Puspendra Singh
        year: 2019
        title: "Various Coefficients of Interrater Reliability and Agreement."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=irr'
        url: https://CRAN.R-project.org/package=irr

    tableone:
        type: 'software'
        author: Kazuki, Y.
        year: 2019
        title: "tableone: Create 'Table 1' to Describe Baseline Characteristics"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=tableone'
        url: https://CRAN.R-project.org/package=tableone

    janitor:
        type: 'software'
        author: Firke, S.
        year: 2019
        title: "janitor: Simple Tools for Examining and Cleaning Dirty Data."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=janitor'
        url: https://CRAN.R-project.org/package=janitor


    finalfit:
        type: 'software'
        author: Ewen Harrison and Tom Drake and Riinu Ots
        year: 2019
        title: "finalfit: Quickly Create Elegant Regression Results Tables and Plots when Modelling"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=finalfit'
        url: https://CRAN.R-project.org/package=finalfit


    caret:
        type: 'software'
        author: Max Kuhn
        year: 2020
        title: "caret: Classification and Regression Training"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=caret'
        url: https://CRAN.R-project.org/package=caret

    psycho:
        type: 'software'
        author: Makowski, D.
        year: 2018
        title: "The Psycho Package: An Efficient and Publishing-Oriented Workflow for Psychological Science. Journal of Open Source Software, 3(22), 470."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=psycho.R'
        url: https://CRAN.R-project.org/package=psycho.R

    survival:
        type: 'software'
        author: Terry M Therneau, Thomas Lumley
        year: 2019
        title: "survival: Survival Analysis"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=survival'
        url: https://CRAN.R-project.org/package=survival

    survminer:
        type: 'software'
        author: Alboukadel Kassambara and Marcin Kosinski and Przemyslaw Biecek
        year: 2019
        title: "survminer: Drawing Survival Curves using 'ggplot2'"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=survminer'
        url: https://CRAN.R-project.org/package=survminer


    ggalluvial:
        type: 'software'
        author: Jason Cory Brunson
        year: 2019
        title: "ggalluvial: Alluvial Plots in 'ggplot2'."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=ggalluvial'
        url: https://CRAN.R-project.org/package=ggalluvial

    explore:
        type: 'software'
        author: Roland Krasser
        year: 2020
        title: "explore: Simplifies Exploratory Data Analysis."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=explore'
        url: https://CRAN.R-project.org/package=explore

    FFTrees:
        type: 'software'
        author: Nathaniel Phillips, Hansjoerg Neth, Jan Woike and Wolfgang Gaissmaer
        year: 2019
        title: "FFTrees: Generate, Visualise, and Evaluate Fast-and-Frugal Decision Trees"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=FFTrees'
        url: https://CRAN.R-project.org/package=FFTrees


    rpart:
        type: 'software'
        author: Terry Therneau and Beth Atkinson
        year: 2019
        title: "rpart: Recursive Partitioning and Regression Trees."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=rpart'
        url: https://CRAN.R-project.org/package=rpart

    rpart.plot:
        type: 'software'
        author: Stephen Milborrow
        year: 2019
        title: "rpart.plot: Plot 'rpart' Models: An Enhanced Version of 'plot.rpart'"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=rpart.plot'
        url: https://CRAN.R-project.org/package=rpart.plot

    gtsummary:
        type: 'software'
        author: Daniel D. Sjoberg, Margie Hannum, Karissa Whiting and Emily C. Zabor
        year: 2020
        title: "gtsummary: Presentation-Ready Data Summary and Analytic Result Tables"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=gtsummary'
        url: https://CRAN.R-project.org/package=gtsummary

    rmngb:
        type: 'software'
        author: Antoine Filipovic Pierucci
        year: 2014
        title: "rmngb: Miscellaneous Collection of Functions for Medical Data Analysis"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=rmngb'
        url: https://CRAN.R-project.org/package=rmngb

    RVAideMemoire:
        type: 'software'
        author: Maxime Hervé
        year: 2020
        title: "RVAideMemoire: Testing and Plotting Procedures for Biostatistics"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=RVAideMemoire'
        url: https://CRAN.R-project.org/package=RVAideMemoire


    chisq.posthoc.test:
        type: 'software'
        author: Daniel Ebbert
        year: 2019
        title: "chisq.posthoc.test: A Post Hoc Analysis for Pearson's Chi-Squared Test for Count Data"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=chisq.posthoc.test'
        url: https://CRAN.R-project.org/package=chisq.posthoc.test



    easyalluvial:
        type: 'software'
        author: Bjoern Koneswarakantha
        year: 2019
        title: "easyalluvial: Generate Alluvial Plots with a Single Line of Code."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=easyalluvial'
        url: https://CRAN.R-project.org/package=easyalluvial


    parcats:
        type: 'software'
        author: Bjoern Koneswarakantha
        year: 2019
        title: "parcats: Interactive Parallel Categories Diagrams for 'easyalluvial'"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=parcats'
        url: https://CRAN.R-project.org/package=parcats


    plotROC:
        type: 'software'
        author: Michael C. Sachs
        year: 2017
        title: "plotROC: A Tool for Plotting ROC Curves.Journal of Statistical Software, Code Snippets, 79(2), 1-19. doi:10.18637/jss.v079.c02"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=plotROC'
        url: https://CRAN.R-project.org/package=plotROC


    RGraphGallery:
        type: 'website'
        author: Holtz Yan
        year: 2020
        title: "The R Graph Gallery"
        publisher: 'A website that displays hundreds of R charts https://www.r-graph-gallery.com'
        url: https://github.com/holtzy/R-graph-gallery


    hrbrthemes:
        type: 'software'
        author: Bob Rudis
        year: 2020
        title: "hrbrthemes: Additional Themes, Theme Components and Utilities for 'ggplot2'."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=hrbrthemes'
        url: https://CRAN.R-project.org/package=hrbrthemes


    retractcheck:
        type: 'software'
        author: Chris Hartgerink and Frederik Aust
        year: 2019
        title: "retractcheck: Retraction Scanner"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=retractcheck'
        url: https://CRAN.R-project.org/package=retractcheck


    RefManageR:
        type: 'software'
        author: McLean MW
        year: 2017
        title: 'RefManageR: Import and Manage BibTeX and BibLaTeX References in R. The Journal of Open Source Software.'
        doi: 10.21105/joss.00338
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=RefManageR'
        url: https://CRAN.R-project.org/package=RefManageR


    rcrossref:
        type: 'software'
        author: Scott Chamberlain and Hao Zhu and Najko Jahn and Carl Boettiger and Karthik Ram
        year: 2020
        title: "rcrossref: Client for Various 'CrossRef' 'APIs'"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=rcrossref'
        url: https://CRAN.R-project.org/package=rcrossref


    epiR:
        type: 'software'
        author: >-
            Mark Stevenson with contributions from Telmo Nunes,
            Cord Heuer, Jonathon Marshall, Javier Sanchez, Ron
            Thornton, Jeno Reiczigel, Jim Robison-Cox, Paola
            Sebastiani, Peter Solymos, Kazuki Yoshida, Geoff Jones,
            Sarah Pirikahu, Simon Firestone, Ryan Kyle, Johann
            Popp, Mathew Jay and Charles Reynard.
        year: 2020
        title: "epiR: Tools for the Analysis of Epidemiological Data."
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=epiR'
        url: https://CRAN.R-project.org/package=epiR


    KMunicate:
        type: 'software'
        author: Alessandro Gasparini
        year: 2020
        title: "KMunicate: KMunicate-Style Kaplan–Meier Plots"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=KMunicate'
        url: https://CRAN.R-project.org/package=KMunicate


    KMunicate2:
        type: 'article'
        author: Morris TP, Jarvis CI, Cragg W, et al
        title: "Proposals on Kaplan–Meier plots in medical research and a survey of stakeholder views: KMunicate"
        year: 2019
        publisher: 'BMJ Open 2019;9:e030215.'
        doi: 10.1136/bmjopen-2019-030215
        url: https://bmjopen.bmj.com/content/9/9/e030215


    Fagan:
        type: 'software'
        author: Adam Chekroud
        title: "nomogrammer: Fagan's nomograms with ggplot2"
        publisher: 'GitHub'
        year: 2020
        url: https://github.com/achekroud/nomogrammer


    Fagan2:
        type: 'article'
        author:
        title: 'StATS: What is a Fagan nomogram?'
        publisher: 'website'
        year: 2020
        url: http://www.pmean.com/definitions/fagan.htm


    benford.analysis:
        type: 'software'
        author: Carlos Cinelli
        year: 2020
        title: "benford.analysis: Benford Analysis for Data Validation and Forensic Analytics"
        publisher: '[R package]. Retrieved from http://github.com/carloscinelli/benford.analysis'
        url: http://github.com/carloscinelli/benford.analysis


    benford.nedir:
        type: 'website'
        author: "Ümit Işlak"
        year: 2021
        title: "Benford (ilk basamak) kanunu nedir?"
        publisher: 'sarkac.org'
        url: https://sarkac.org/2021/09/benford-ilk-basamak-kanunu-nedir/


    vtree:
        type: 'software'
        author: Nick Barrowman
        year: 2020
        title: "vtree: Display Information About Nested Subsets of a Data Frame"
        publisher: '[R package]. Retrieved from https://CRAN.R-project.org/package=vtree'
        url: https://CRAN.R-project.org/package=vtree


    PathologyKappa:
        type: 'article'
        title: Pathologists should probably forget about kappa. Percent agreement, diagnostic specificity and related metrics provide more clinically applicable measures of interobserver variability
        year: 2020
        author:
        publisher: Annals of Diagnostic Pathology
        volume: 47
        url: https://www.sciencedirect.com/science/article/abs/pii/S1092913420301040


    DiagnosticTests:
        type: 'article'
        title: The Interpretation of SARS-CoV-2 Diagnostic Tests
        year: 2020
        author: Stites EC, Wilen CB.
        publisher:  Med (N Y).
        doi: 10.1016/j.medj.2020.08.001
        url: https://www.cell.com/med/fulltext/S2666-6340(20)30016-7

    dichotomizing:
        type: 'article'
        title: 'Dichotomizing continuous predictors in multiple regression: a bad idea.'
        year: 2006
        author: Royston, P., Altman, D.G. and Sauerbrei, W.
        publisher:  Statist. Med.
        volume: 25
        pages: 127-141
        doi: 10.1002/sim.2331
        url: https://onlinelibrary.wiley.com/doi/abs/10.1002/sim.2331

    bbccookbook:
        type: 'article'
        title: 'BBC Visual and Data Journalism cookbook for R graphics'
        year: 2019
        author: BBC data team
        url: https://bbc.github.io/rcookbook/

    bbplot:
        type: 'software'
        author: Nassos Stylianou and Will william.dahlgreen@bbc.co.uk Dahlgreen and Robert robert.cuffe@bbc.co.uk Cuffe and Tom Calver and Ransome Mpini
        year: 2020
        title: "bbplot: MAKING GGPLOT GRAPHICS IN BBC NEWS STYLE"
        publisher: '[R package]. Retrieved from https://github.com/bbc/bbplot'
        url: https://github.com/bbc/bbplot

    venn:
        type: 'software'
        author: Linlin Yan
        year: 2020
        title: "Venn Diagram by ggplot2, with really easy-to-use API"
        publisher: '[R package]. Retrieved from https://github.com/yanlinlin82/ggvenn'
        url: https://github.com/yanlinlin82/ggvenn

    padjust:
        type: 'website'
        year: 2020
        title: "p.adjust {stats} Adjust P-values for Multiple Comparisons"
        publisher: '[R package]. Retrieved from https://stat.ethz.ch/R-manual/R-devel/library/stats/html/p.adjust.html'
        url: https://stat.ethz.ch/R-manual/R-devel/library/stats/html/p.adjust.html


    multivariable:
        type: 'article'
        title: 'Multivariate or Multivariable Regression?'
        year: 2013
        author: Hidalgo B, Goodman M.
        publisher:  Am J Public Health.
        volume: 103
        pages: 39-40
        doi: 10.2105/AJPH.2012.300897
        url: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3518362/

    ClinicoPathJamoviModule:
        type: 'software'
        author: Serdar Balci
        year: 2022
        title: "ClinicoPath jamovi Module doi:10.5281/zenodo.3997188"
        publisher: '[R package]. Retrieved from https://github.com/sbalci/ClinicoPathJamoviModule'
        doi: 10.17605/OSF.IO/9SZUD
        url: https://www.serdarbalci.com/ClinicoPathJamoviModule/


    iwillsurvive:
        type: 'software'
        author: Nathaniel Phillips
        year: 2021
        title: "iwillsurvive"
        publisher: '[R package]. Retrieved from https://github.com/ndphillips/iwillsurvive'
        url: https://github.com/ndphillips/iwillsurvive

    sensspecwiki:
        type: 'webpage'
        author: "Wikipedia contributors"
        title: "Sensitivity and specificity --- Wikipedia, The Free Encyclopedia"
        year: "2022"
        url: https://en.wikipedia.org/w/index.php?title=Sensitivity_and_specificity&oldid=1077556477
        note: "[Online; accessed 3-April-2022]"



    kappaSize:
        type: 'software'
        author: Michael A Rotondi
        year: 2022
        title: "kappaSize: Sample Size Estimation Functions for Studies of Interobserver Agreement"
        publisher: '[R package]. Retrieved from https://cran.r-project.org/web/packages/kappaSize/'
        url: https://cran.r-project.org/web/packages/kappaSize/


    gtExtras:
        type: 'software'
        author: Thomas Mock, Daniel D. Sjoberg
        year: 2023
        title: "gtExtras"
        publisher: '[R package]. Retrieved from https://cran.r-project.org/web/packages/gtExtras/'
        url: https://cran.r-project.org/web/packages/gtExtras/


    survivaltutorial:
        type: 'article'
        author: Emily C. Zabor
        year: 2022
        title: "Survival analysis in R: A detailed tutorial on conducting survival analyses in R, including an introduction to the basics of survival analysis, landmark analyses and time-dependent covariates, competing risks, and a selection of advanced topics."
        publisher: '[GitHub Repository]. Retrieved from https://github.com/zabore/tutorials'
        url: https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html

    survivalrviews:
        type: 'article'
        author: Joseph Rickert
        year: 2017
        title: "Survival Analysis with R"
        publisher: 'R Views, An R community blog edited by RStudio'
        url: https://rviews.rstudio.com/2017/09/25/survival-analysis-with-r/


    appliedsurvivalanalysisR:
        type: 'book'
        author: Dirk F. Moore
        year: 2016
        title: "Applied Survival Analysis Using R"
        publisher: 'Springer Cham'
        doi: 10.1007/978-3-319-31245-3
        url: https://link.springer.com/book/10.1007/978-3-319-31245-3

    survivalrwnahhas:
        type: 'book chapter'
        author: Ramzi W. Nahhas
        year: 2023
        title: "Chapter 7 Survival Analysis. Introduction to Regression Methods for Public Health Using R."
        url: https://bookdown.org/rwnahhas/RMPH/survival.html
        


...


File: jamovi\multisurvival.a.yaml
--------------------------------------------------
Content of jamovi\multisurvival.a.yaml:
---
name:  multisurvival
title: Multivariable Survival Analysis
menuGroup: Survival
menuSubgroup: ClinicoPath Survival
menuSubtitle: 'Multivariable Cox-regression, Adjusted Survival'
version: '1.0.0'
jas: '1.2'

description:
    main: Function for Multivariable Survival Analysis using Cox-regression.
    R:
        dontrun: true
        usage: |
            # example will be added


options:

# Data ----

    - name: data
      type: Data
      description:
          R: >
            The dataset to be analyzed, provided as a data frame. Must contain the
            variables specified in the options below.

# Time ----



    - name: elapsedtime
      title: 'Time Elapsed'
      type: Variable
      suggested: [ continuous ]
      permitted: [ numeric ]
      description:
        R: >
          The numeric variable representing follow-up time until the event or last observation.
          If `tint` = false, this should be a pre-calculated numeric time variable.
          If `tint` = true, `dxdate` and `fudate` will be used to calculate this time.

    - name: tint
      title: Using Dates to Calculate Survival Time
      type: Bool
      default: false
      description:
        R: >
          If true, survival time will be calculated from `dxdate` and `fudate`.
          If false, `elapsedtime` should be provided as a pre-calculated numeric variable.

    - name: dxdate
      title: 'Diagnosis Date'
      type: Variable
      description:
        R: >
          Date of diagnosis. Required if `tint` = true.
          Must match the format specified in `timetypedata`.

    - name: fudate
      title: 'Follow-up Date'
      type: Variable
      description:
        R: >
          Follow-up date or date of last observation. Required if `tint` = true.
          Must match the format specified in `timetypedata`.




    - name: timetypedata
      title: 'Time Type in Data (e.g., YYYY-MM-DD)'
      type: List
      options:
        - title: 'Year-Month-Day Hour-Minute-Second'
          name: ymdhms
        - title: 'Year-Month-Day'
          name: ymd
        - title: 'Year-Day-Month'
          name: ydm
        - title: 'Month-Day-Year'
          name: mdy
        - title: 'Month-Year-Day'
          name: myd
        - title: 'Day-Month-Year'
          name: dmy
        - title: 'Day-Year-Month'
          name: dym
      default: ymd
      description:
        R: >
          Specifies the format of the date variables in the input data.
          This is critical if `tint = true`, as `dxdate` and `fudate` will be parsed
          according to this format to calculate survival time. For example, if your
          data files record dates as "YYYY-MM-DD", select `ymd`.

    - name: timetypeoutput
      title: Time Type in Output
      type: List
      options:
        - title: days
          name: days
        - title: weeks
          name: weeks
        - title: months
          name: months
        - title: years
          name: years
      default: months
      description:
        R: >
          The units in which survival time is reported in the output. Choose from days, weeks,
          months, or years.

    - name: uselandmark
      title: Use Landmark Time
      type: Bool
      default: false
      description:
        R: >
          If true, applies a landmark analysis starting at a specified time point.

    - name: landmark
      title: Landmark Time
      type: Integer
      default: 3
      description:
        R: >
          The time point (in the units defined by `timetypeoutput`) at which to start landmark analyses.
          Only used if `uselandmark` = true.


    - name: calculatedtime
      title: Add Calculated Time to Data
      type: Output
      description:
        R: >
          If true, adds a calculated survival time variable to the dataset, based on `dxdate` and `fudate`
          if `tint` = true, or confirms `elapsedtime` if already provided.



# Outcome ----



    - name: outcome
      title: 'Outcome'
      type: Variable
      suggested: [ ordinal, nominal, continuous ]
      permitted: [ factor, numeric ]
      description:
        R: >
          The outcome variable. Typically indicates event status (e.g., death, recurrence).
          For survival analysis, this may be a factor or numeric event indicator.

    - name: outcomeLevel
      title: Event Level
      type: Level
      variable: (outcome)
      description:
        R: >
          The level of `outcome` considered as the event. For example, if `outcome` is a factor,
          specify which level indicates the event occurrence.

    - name: dod
      title: Dead of Disease
      type: Level
      variable: (outcome)
      allowNone: true
      description:
        R: >
          The level of `outcome` corresponding to death due to disease, if applicable.

    - name: dooc
      title: Dead of Other
      type: Level
      variable: (outcome)
      allowNone: true
      description:
        R: >
          The level of `outcome` corresponding to death due to other causes, if applicable.

    - name: awd
      title: Alive w Disease
      type: Level
      variable: (outcome)
      allowNone: true
      description:
        R: >
          The level of `outcome` corresponding to alive with disease, if applicable.

    - name: awod
      title: Alive w/o Disease
      type: Level
      variable: (outcome)
      allowNone: true
      description:
        R: >
          The level of `outcome` corresponding to alive without disease, if applicable.


    - name: analysistype
      title: 'Survival Type'
      type: List
      options:
        - title: Overall
          name: overall
        - title: Cause Specific
          name: cause
        - title: Competing Risk
          name: compete
      default: overall
      description:
        R: >
          Type of survival analysis:
          - overall: All-cause survival
          - cause: Cause-specific survival
          - compete: Competing risks analysis



    - name: outcomeredefined
      title: Add Redefined Outcome to Data
      type: Output
      description:
        R: >
          If true, adds a new outcome variable (redefined based on the chosen event specification)
          to the data set.

# Explanatory ----

    - name: explanatory
      title: Explanatory Variables
      type: Variables
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]
      description:
        R: >
          Categorical explanatory (predictor) variables included in the Cox model.

# Cont Explanatory ----

    - name: contexpl
      title: Continuous Explanatory Variable
      type: Variables
      suggested: [ continuous ]
      permitted: [ numeric ]
      description:
        R: >
          Continuous explanatory (predictor) variables included in the Cox model.


# Multievent ----

    - name: multievent
      title: Multiple Event Levels
      type: Bool
      default: false
      description:
        R: >
          If true, multiple event levels will be considered for competing risks analysis.
          Requires specifying `dod`, `dooc`, etc.


# Plots ----

    - name: hr
      title: Hazards Regression Plot
      type: Bool
      default: false
      description:
        R: >
          If true, generates a plot of hazard ratios for each explanatory variable in the Cox model.

    - name: sty
      title: Plot Style
      type: List
      options:
        - title: finalfit
          name: t1
        # - title: ggstatsplot
        #   name: t2
        - title: survminer forestplot
          name: t3
      default: t1
      description:
        R: >
          The style of the hazard ratio (forest) plot. "finalfit" or "survminer forestplot".


    - name: ph_cox
      title: Proportional Hazards Assumption
      type: Bool
      default: false
      description:
        R: >
          If true, tests the proportional hazards assumption for the Cox model.
          Use if you suspect violations of the PH assumption.



    - name: km
      title: Kaplan-Meier
      type: Bool
      default: false
      description:
        R: >
          If true, produces a Kaplan-Meier survival plot. Useful for visualization of
          survival functions without covariate adjustment.

# Plot Options ----




    - name: endplot
      title: Plot End Time
      type: Integer
      default: 60
      description:
        R: >
          The maximum follow-up time (in units defined by `timetypeoutput`) to display on survival plots.


    - name: byplot
      title: Time Interval
      type: Integer
      default: 12
      description:
        R: >
          The interval (in units defined by `timetypeoutput`) at which time points or labels are shown on plots.


    - name: ci95
      title: '95% CI'
      type: Bool
      default: false
      description:
        R: >
          If true, displays 95% confidence intervals around the survival estimates on plots.

    - name: risktable
      title: risktable
      type: Bool
      default: false
      description:
        R: >
          If true, displays the number of subjects at risk at each time point below the survival plot.

    - name: censored
      title: censored
      type: Bool
      default: false
      description:
        R: >
          If true, marks censored observations (e.g., using tick marks) on the survival plot.

    - name: medianline
      title: medianline
      type: List
      options:
        - title: none
          name: none
        - title: horizontal
          name: h
        - title: vertical
          name: v
        - title: both
          name: hv
      default: none
      description:
        R: >
          If true, displays a line indicating the median survival time on the survival plot.


    - name: pplot
      title: p-value
      type: Bool
      default: true
      description:
        R: >
          If true, displays the p-value from the survival comparison test on the survival plot.









# Risk Score ----

    - name: calculateRiskScore
      title: Calculate Risk Score
      type: Bool
      default: false
      description:
        R: >
          If true, calculates a risk score from the Cox model coefficients for each individual.

    - name: plotRiskGroups
      title: Plot Risk Group Survival
      type: Bool
      default: false
      description:
        R: >
          If true, stratifies individuals into risk groups based on their calculated risk scores
          and plots their survival curves.

    - name: addRiskScore
      title: Add Risk Score to Data
      type: Output
      description:
        R: >
          If true, adds a computed risk score variable to the dataset.


    - name: addRiskGroup
      title: Add Risk Group to Data
      type: Output
      description:
        R: >
          If true, adds a categorical variable indicating risk group assignment to the dataset.


# Adjusted Survival ----

    - name: ac
      title: Adjusted Survival Curve
      type: Bool
      default: false

    - name: adjexplanatory
      title: Variable for Adjusted Curve
      type: Variable
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]

    - name: ac_method
      title: Adjustment Method
      type: List
      options:
        - title: Average
          name: average
        - title: Conditional Mean
          name: conditional
        - title: Single
          name: single
        - title: Marginal
          name: marginal
      default: average
      description:
          R: Method for computing adjusted survival curves

    # - name: ac_summary
    #   title: Show Summary Statistics
    #   type: Bool
    #   default: false
    #   description:
    #       R: Calculate and display summary statistics for adjusted curves

    # - name: ac_timepoints
    #   title: Summary Timepoints
    #   type: String
    #   default: '12, 36, 60'
    #   description:
    #       R: Timepoints for calculating summary statistics (comma-separated)

    # - name: ac_compare
    #   title: Compare Curves
    #   type: Bool
    #   default: false
    #   description:
    #       R: Perform statistical comparison between adjusted curves


# Reduced Explanatory ----

    # - name: reduced_explanatory
    #   title: Reduced Model Variables
    #   type: Variables
    #   suggested: [ ordinal, nominal ]
    #   permitted: [ factor ]
    #   description:
    #     R: >
    #       Variables to include in a reduced model for comparison. This can be used to test
    #       whether excluding some variables affects model fit.
    #
    #
    # - name: compare_models
    #   title: Compare with reduced model
    #   type: Bool
    #   default: false
    #   description:
    #     R: >
    #       If true, compares the full model against the reduced model to assess the impact of removing
    #       certain explanatory variables.


  # - type: CollapseBox
  #   label: Reduced Model Options
  #   collapsed: true
  #   children:
  #     - type: Label
  #       label: Model Comparison
  #       children:
  #         - type: CheckBox
  #           name: compare_models
  #           fitToGrid: true
  #         - type: Label
  #           label: Select Reduced Model Variables
  #           fitToGrid: true
  #           stretchFactor: 1
  #           children:
  #             - type: VariableSupplier
  #               persistentItems: false
  #               stretchFactor: 1
  #               children:
  #                 - type: TargetLayoutBox
  #                   label: Reduced Model Variables
  #                   children:
  #                     - type: VariablesListBox
  #                       name: reduced_explanatory
  #                       isTarget: true
  #                       fitToGrid: true
  #                       stretchFactor: 1




# Model Selection ----


    # - name: use_modelSelection
    #   title: Use Models
    #   type: Bool
    #   default: false
    #   description:
    #     R: >
    #       If true, applies a variable selection procedure to find the best-fitting model based on
    #       criteria like AIC or likelihood ratio tests.
    #
    # - name: modelSelection
    #   title: Model Selection Method
    #   type: List
    #   options:
    #     - title: Enter (No Selection)
    #       name: enter
    #     - title: Forward Selection
    #       name: forward
    #     - title: Backward Selection
    #       name: backward
    #     - title: Stepwise (Both)
    #       name: both
    #   default: enter
    #   description:
    #     R: >
    #       The method used to select variables:
    #       - enter: Includes all variables (no selection)
    #       - forward: Adds variables one at a time if they improve the model
    #       - backward: Removes variables that do not significantly contribute
    #       - both: Combination of forward and backward steps
    #
    # - name: selectionCriteria
    #   title: Selection Criteria
    #   type: List
    #   options:
    #     - title: AIC (Akaike Information Criterion)
    #       name: aic
    #     - title: Likelihood Ratio Test
    #       name: lrt
    #   default: aic
    #   description:
    #     R: >
    #       The criterion used for adding or removing variables in model selection:
    #       - aic: Balances model fit and complexity
    #       - lrt: Uses likelihood ratio tests to decide inclusion/removal
    #
    # - name: pEntry
    #   title: Entry Significance
    #   type: Number
    #   min: 0
    #   max: 1
    #   default: 0.05
    #   description:
    #     R: >
    #       Significance level at which a variable enters the model during forward or stepwise selection.
    #
    # - name: pRemoval
    #   title: Removal Significance
    #   type: Number
    #   min: 0
    #   max: 1
    #   default: 0.10
    #   description:
    #     R: >
    #       Significance level at which a variable is removed from the model during backward or stepwise selection.

  # - type: CollapseBox
  #   label: Model Selection
  #   collapsed: true
  #   children:
  #     - type: Label
  #       label: Variable Selection Method
  #       children:
  #         - type: CheckBox
  #           name: use_modelSelection
  #         - type: LayoutBox
  #           margin: large
  #           children:
  #             - type: ComboBox
  #               name: modelSelection
  #               enable: (use_modelSelection)
  #             - type: ComboBox
  #               name: selectionCriteria
  #               enable: (use_modelSelection)
  #             - type: TextBox
  #               name: pEntry
  #               format: number
  #               label: Entry Significance (p-value)
  #               enable: (use_modelSelection)
  #             - type: TextBox
  #               name: pRemoval
  #               format: number
  #               label: Removal Significance (p-value)
  #               enable: (use_modelSelection)



# Stratify Variables ----



    - name: use_stratify
      title: Use Variable Stratification
      type: Bool
      default: false
    #   description:
    #     R: >
    #       If true, uses stratification to handle variables that violate the proportional hazards assumption.
    #       Stratification creates separate baseline hazard functions for different groups.


    # - name: stratvar
    #   title: Stratification Variables
    #   type: Variables
    #   suggested: [ ordinal, nominal ]
    #   permitted: [ factor ]
    #   description:
    #     R: >
    #       Variables used for stratification. When proportional hazards are not met,
    #       stratification can adjust the model to better fit the data by allowing different baseline hazards.

  # - type: CollapseBox
  #   label: Stratification Variables
  #   collapsed: true
  #   children:
  #     - type: Label
  #       label: Stratification Variables
  #       children:
  #         - type: CheckBox
  #           name: use_stratify
  #           fitToGrid: true
  #         - type: Label
  #           label: Select Stratification Variables
  #           fitToGrid: true
  #           stretchFactor: 1
  #           children:
  #             - type: VariableSupplier
  #               persistentItems: false
  #               stretchFactor: 1
  #               children:
  #                 - type: TargetLayoutBox
  #                   label: Stratification Variables
  #                   children:
  #                     - type: VariablesListBox
  #                       name: stratvar
  #                       isTarget: true
  #                       fitToGrid: true
  #                       stretchFactor: 1






...


File: jamovi\multisurvival.r.yaml
--------------------------------------------------
Content of jamovi\multisurvival.r.yaml:
---
name:  multisurvival
title: Multivariable Survival Analysis
jrs:   '1.1'


items:

    - name:  todo
      title: To Do
      type:  Html
      clearWith:
          - outcome
          - outcomeLevel
          - overalltime
          - explanatory
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent




    - name:  text
      title: Multivariable Survival
      type:  Html
      refs: finalfit
      clearWith:
          - outcome
          - outcomeLevel
          - overalltime
          - explanatory
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name:  text2
      title: ''
      type:  Html
      refs: finalfit
      clearWith:
          - outcome
          - outcomeLevel
          - overalltime
          - explanatory
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name: plot
      title: Hazards Regression Plot
      type: Image
      width:  600
      height: 450
      renderFun: .plot
      requiresData: true
      visible: (hr && sty:t1)
      refs: finalfit
      clearWith:
          - hr
          - sty
          - outcome
          - outcomeLevel
          - overalltime
          - explanatory
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    # - name: plot2
    #   title: Hazards Regression Plot
    #   type: Image
    #   width:  800
    #   height: 600
    #   renderFun: .plot2
    #   requiresData: true
    #   clearWith:
    #       - explanatory
    #       - outcome
    #       - overalltime
    #   visible: (sty:t2)
    #   refs: ggstatsplot
      # clearWith:
      #     - hr
      #     - sty


    - name: plot3
      title: Hazards Regression Plot
      type: Image
      width:  800
      height: 600
      renderFun: .plot3
      requiresData: true
      visible: (hr && sty:t3)
      refs: survminer
      clearWith:
          - hr
          - sty
          - outcome
          - outcomeLevel
          - overalltime
          - explanatory
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent


    - name: cox_ph
      title: 'Proportional Hazards Assumption'
      type:  Preformatted
      visible: (ph_cox)
      clearWith:
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent
          - contexpl


    - name: plot8
      title: 'Proportional Hazards Assumption'
      type: Image
      width:  600
      height: 450
      renderFun: .plot8
      visible: (ph_cox)
      requiresData: true
      clearWith:
          - ph_cox
          - endplot
          - byplot
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent
          - contexpl



    # - name:  mydataview_adj_stats
    #   title: mydataview
    #   type:  Preformatted


    # - name:  mydataview_adj_summary
    #   title: mydataview
    #   type:  Preformatted





    # - name: plot4
    #   title: coxzph Plot
    #   type: Image
    #   width:  800
    #   height: 600
    #   renderFun: .plot4




    - name: plotKM
      title: Kaplan-Meier
      type: Image
      width:  600
      height: 450
      renderFun: .plotKM
      requiresData: true
      visible: (km)
      refs: finalfit
      clearWith:
          - km
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - explanatory
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent
          - adjexplanatory
          - pplot
          - censored
          - medianline



    # - name: plot7
    #   title: '`Adjusted Survival Curve - ${adjexplanatory}`'
    #   type: Image
    #   width:  800
    #   height: 600
    #   renderFun: .plot7
    #   requiresData: true
    #   visible: (ac)
    #   refs: survminer
    #   clearWith:
    #       - ac
    #       - adjexplanatory
    #       - endplot
    #       - byplot
    #       - ci95
    #       - risktable
    #       - outcome
    #       - outcomeLevel
    #       - overalltime
    #       - explanatory
    #       - contexpl
    #       - fudate
    #       - dxdate
    #       - tint
    #       - multievent
    #       - adjexplanatory
    #       - pplot
    #       - censored







    - name: riskScoreTable
      title: Risk Score Summary
      type: Table
      visible: (calculateRiskScore)
      rows: 0
      columns:
        - name: group
          title: Risk Group
          type: text
        - name: n_patients
          title: N
          type: integer
        - name: percent
          title: Percent
          type: number
        - name: median_score
          title: Median Score
          type: number
        - name: events
          title: Events
          type: integer
      clearWith:
          - calculateRiskScore
          - outcome
          - outcomeLevel
          - explanatory
          - contexpl


    - name: riskScoreMetrics
      title: Risk Score Model Metrics
      type: Html
      visible: (calculateRiskScore)
      clearWith:
          - calculateRiskScore
          - outcome
          - outcomeLevel
          - explanatory
          - contexpl



    - name: riskGroupPlot
      title: Risk Group Survival Plot
      type: Image
      width: 600
      height: 450
      renderFun: .plotRiskGroups
      requiresData: true
      visible: (plotRiskGroups)





    - name: calculatedtime
      title: Add Calculated Time to Data
      type: Output
      varTitle: '`Calculated Time in Multivariable Survival Function - from ${ dxdate } to { fudate }`'
      varDescription: Calculated Time from given Dates in Multivariable Survival Analysis
      clearWith:
          - tint
          - dxdate
          - fudate


    - name: outcomeredefined
      title: Add Redefined Outcome to Data
      type: Output
      varTitle: '`Redefined Outcome in Multivariable Survival Function - from ${ outcome } for analysis { analysistype }`'
      varDescription: Redefined Outcome from Outcome based on Analysis Type in Multivariable Survival Analysis
      clearWith:
          - outcome
          - analysistype
          - multievent



    - name: addRiskScore
      title: Add Calculated Risk Score to Data
      type: Output
      varTitle: '`Calculated Risk Score in Multivariable Survival Function`'
      varDescription: Calculated Risk Score Based on Model
      clearWith:
          - addRiskScore
          - calculateRiskScore
          - outcome
          - outcomeLevel
          - overalltime
          - explanatory
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent
          - addRiskGroup


    - name: addRiskGroup
      title: Add Calculated Risk Group to Data
      type: Output
      varTitle: '`Calculated Risk Group in Multivariable Survival Function`'
      varDescription: Calculated Risk Group Based on Model
      clearWith:
          - addRiskScore
          - calculateRiskScore
          - outcome
          - outcomeLevel
          - overalltime
          - explanatory
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent
          - addRiskGroup


    # - name:  mydataview_plot_adj
    #   title: mydataview_plot_adj
    #   type:  Preformatted


    # - name:  mydataview_calculateAdjustedStats
    #   title: mydataview_calculateAdjustedStats
    #   type:  Preformatted




    - name: plot_adj
      title: Adjusted Survival Plot
      type: Image
      width: 600
      height: 450
      renderFun: .plot_adj
      visible: (ac)
      refs: survminer
      clearWith:
          - ac
          - adjexplanatory
          - ci95
          - risktable
          - ac_method
          - endplot
          - byplot
          - outcome
          - outcomeLevel
          - overalltime
          - explanatory
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent
          - adjexplanatory
          - pplot
          - censored
          - medianline



    # - name: adjustedSummaryTable2
    #   title: Adjusted Survival Summary 2
    #   type: Preformatted
    #   visible: (ac_summary)


    # - name: adjustedSummaryTable
    #   title: Adjusted Survival Summary
    #   type: Table
    #   visible: (ac_summary)
    #   rows: 0
    #   columns:
    #     - name: Level
    #       title: Level
    #       type: text
    #     - name: Timepoint
    #       title: "Time"
    #       type: integer
    #     - name: Survival
    #       title: "Adjusted Survival"
    #       type: number
    #       format: proportion
    #     - name: SE
    #       title: "SE"
    #       type: number
    #     - name: CI_Lower
    #       title: "95% CI Lower"
    #       type: number
    #       format: proportion
    #     - name: CI_Upper
    #       title: "95% CI Upper"
    #       type: number
    #       format: proportion
    #   clearWith:
    #       - ac_summary
    #       - ac_timepoints
    #       - ac_method
    #       - adjexplanatory

    # - name: adjustedComparison
    #   title: Statistical Comparison of Adjusted Curves
    #   type: Preformatted
    #   visible: (ac_compare)
    #   clearWith:
    #       - ac_compare
    #       - ac_method
    #       - adjexplanatory

    # - name: adjustedComparison_survdiff_res
    #   title: Statistical Comparison of Adjusted Curves
    #   type: Preformatted
    #   visible: (ac_compare)
    #   clearWith:
    #       - ac_compare
    #       - ac_method
    #       - adjexplanatory

    # - name: adjustedSurvTable2
    #   title: Adjusted Survival Table 2
    #   type: Preformatted


    # - name: adjustedSurvTable
    #   title: Adjusted Survival Table
    #   type: Table
    #   rows: 0
    #   columns:
    #     - name: strata
    #       title: "Level"
    #       type: text
    #     - name: time
    #       title: "Time"
    #       type: integer
    #     - name: n.risk
    #       title: "Number at Risk"
    #       type: integer
    #     - name: n.event
    #       title: "Events"
    #       type: integer
    #     - name: surv
    #       title: "Adjusted Survival"
    #       type: text
    #     - name: lower
    #       title: "95% CI Lower"
    #       type: text
    #     - name: upper
    #       title: "95% CI Upper"
    #       type: text
    #   clearWith:
    #       - ac
    #       - ac_timepoints
    #       - adjexplanatory

    # - name: adjustedSurvTableSummary
    #   title: Adjusted Survival Summary
    #   type: Html
    #   clearWith:
    #       - ac
    #       - ac_timepoints
    #       - adjexplanatory

    # - name: adjustedPairwiseTable
    #   title: Pairwise Comparisons of Adjusted Survival
    #   type: Table
    #   rows: 0
    #   columns:
    #     - name: rowname
    #       title: "Group 1"
    #       type: text
    #     - name: name
    #       title: "Group 2"
    #       type: text
    #     - name: value
    #       title: "Adjusted p-value"
    #       type: number
    #       format: zto,pvalue
    #   visible: (ac_compare)
    #   clearWith:
    #       - ac
    #       - ac_compare
    #       - adjexplanatory
    #       - padjustmethod
    #   refs:
    #       - padjust

    # - name: adjustedPairwiseSummary
    #   title: Pairwise Comparison Summary
    #   type: Html
    #   visible: (ac_compare)
    #   clearWith:
    #       - ac
    #       - ac_compare
    #       - adjexplanatory
    #       - padjustmethod

    # - name: adjustedMedianTable
    #   title: Adjusted Median Survival
    #   type: Table
    #   rows: 0
    #   columns:
    #     - name: factor
    #       title: "Level"
    #       type: text
    #     - name: records
    #       title: "Records"
    #       type: integer
    #     - name: events
    #       title: "Events"
    #       type: integer
    #     - name: median
    #       title: "Median"
    #       type: number
    #     - name: x0_95lcl
    #       title: "Lower"
    #       superTitle: "95% CI"
    #       type: number
    #     - name: x0_95ucl
    #       title: "Upper"
    #       superTitle: "95% CI"
    #       type: number
    #   clearWith:
    #       - ac
    #       - adjexplanatory

    # - name: adjustedMedianSummary
    #   title: Adjusted Median Survival Summary
    #   type: Html
    #   clearWith:
    #       - ac
    #       - adjexplanatory

    # - name: adjustedCoxTable
    #   title: Adjusted Cox Model Results
    #   type: Table
    #   rows: 0
    #   columns:
    #     - name: Variable
    #       title: "Variable"
    #       type: text
    #     - name: HR
    #       title: "HR (95% CI)"
    #       type: text
    #     - name: Pvalue
    #       title: "P-value"
    #       type: number
    #       format: zto,pvalue
    #   clearWith:
    #       - ac
    #       - adjexplanatory

    # - name: adjustedCoxText
    #   title: Adjusted Cox Model Metrics
    #   type: Html
    #   clearWith:
    #       - ac
    #       - adjexplanatory

    # - name: adjustedCoxSummary
    #   title: Adjusted Cox Model Interpretation
    #   type: Html
    #   clearWith:
    #       - ac
    #       - adjexplanatory

    # - name: adjustedCoxPH
    #   title: Proportional Hazards Test
    #   type: Html
    #   visible: (ph_cox)
    #   clearWith:
    #       - ac
    #       - adjexplanatory
    #       - ph_cox

    # - name: adjustedCoxPHPlot
    #   title: Proportional Hazards Plot
    #   type: Image
    #   width: 600
    #   height: 450
    #   renderFun: .plotAdjustedPH
    #   visible: (ph_cox)
    #   clearWith:
    #       - ac
    #       - adjexplanatory
    #       - ph_cox



    # - name: model_comparison
    #   title: Model Comparison
    #   type: Html
    #   visible: (compare_models)

    # - name: reduced_model_metrics
    #   title: Reduced Model Performance Metrics
    #   type: Html
    #   visible: (compare_models)




    # - name:  text_model_selection
    #   title: Multivariable Survival with Model Selection
    #   type:  Html
    #   refs: finalfit
    #   visible: (use_modelSelection)
    #   clearWith:
    #       - outcome
    #       - outcomeLevel
    #       - overalltime
    #       - explanatory
    #       - contexpl
    #       - fudate
    #       - dxdate
    #       - tint
    #       - multievent
    #       - modelSelection
    #       - selectionCriteria
    #       - pEntry
    #       - pRemoval


    # - name:  text2_model_selection
    #   title: ''
    #   type:  Html
    #   refs: finalfit
    #   visible: (use_modelSelection)
    #   clearWith:
    #       - outcome
    #       - outcomeLevel
    #       - overalltime
    #       - explanatory
    #       - contexpl
    #       - fudate
    #       - dxdate
    #       - tint
    #       - multievent
    #       - modelSelection
    #       - selectionCriteria
    #       - pEntry
    #       - pRemoval

    # - name: selectionSteps
    #   title: Model Selection Steps
    #   type: Table
    #   visible: (use_modelSelection)
    #   columns:
    #     - name: step
    #       title: Step
    #       type: integer
    #     - name: variable
    #       title: Variable
    #       type: text
    #     - name: action
    #       title: Action
    #       type: text
    #     - name: criterion
    #       title: Criterion Value
    #       type: number
    #     - name: pvalue
    #       title: P-value
    #       type: number
    #   refs: finalfit
    #   clearWith:
    #       - outcome
    #       - outcomeLevel
    #       - overalltime
    #       - explanatory
    #       - contexpl
    #       - fudate
    #       - dxdate
    #       - tint
    #       - multievent
    #       - modelSelection
    #       - selectionCriteria
    #       - pEntry
    #       - pRemoval

refs:
    - multivariable
    - survivaltutorial
    - survivalrwnahhas
    - ClinicoPathJamoviModule



...


File: jamovi\multisurvival.u.yaml
--------------------------------------------------
Content of jamovi\multisurvival.u.yaml:
title: Multivariable Survival Analysis
name: multisurvival
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Time Elapsed
        children:
          - type: VariablesListBox
            name: elapsedtime
            maxItemCount: 1
            isTarget: true
      - type: TargetLayoutBox
        label: Outcome
        children:
          - type: VariablesListBox
            name: outcome
            maxItemCount: 1
            isTarget: true
            fitToGrid: true
          - type: LevelSelector
            name: outcomeLevel
            enable: (outcome && !multievent)
      - type: TargetLayoutBox
        label: Explanatory Variables
        children:
          - type: VariablesListBox
            name: explanatory
            isTarget: true
      - type: TargetLayoutBox
        label: Continuous Explanatory Variable
        children:
          - type: VariablesListBox
            name: contexpl
            isTarget: true
  - type: CollapseBox
    label: Advanced Elapsed Time Options
    collapsed: true
    stretchFactor: 1
    children:
      - type: Label
        label: Time Interval
        fitToGrid: true
        stretchFactor: 1
        children:
          - type: LayoutBox
            margin: large
            stretchFactor: 1
            children:
              - type: CheckBox
                name: tint
                fitToGrid: true
              - type: Label
                label: Date Variables
                fitToGrid: true
                stretchFactor: 1
                children:
                  - type: VariableSupplier
                    persistentItems: false
                    stretchFactor: 1
                    children:
                      - type: TargetLayoutBox
                        children:
                          - type: VariablesListBox
                            name: dxdate
                            maxItemCount: 1
                            isTarget: true
                            fitToGrid: true
                            stretchFactor: 1
                      - type: TargetLayoutBox
                        children:
                          - type: VariablesListBox
                            name: fudate
                            maxItemCount: 1
                            isTarget: true
                            fitToGrid: true
                            stretchFactor: 1
              - type: Label
                label: Time Type
                fitToGrid: true
                stretchFactor: 1
                children:
                  - type: LayoutBox
                    margin: large
                    fitToGrid: true
                    children:
                      - type: ComboBox
                        name: timetypedata
                        enable: (tint)
                      - type: ComboBox
                        name: timetypeoutput
                        enable: (tint)
      - type: Label
        label: Landmark Time
        fitToGrid: true
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: CheckBox
                name: uselandmark
                children:
                  - type: TextBox
                    name: landmark
                    format: number
                    enable: (uselandmark)
      - type: Label
        label: Calculated Time to Data
        fitToGrid: true
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: Output
                name: calculatedtime
                enable: (tint)
  - type: CollapseBox
    label: Analysis with Multiple Outcomes
    collapsed: true
    children:
      - type: Label
        label: Multiple Event Levels
        fitToGrid: true
        children:
          - type: CheckBox
            name: multievent
            enable: (outcome)
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: LevelSelector
                name: dod
                enable: (outcome && multievent)
              - type: LevelSelector
                name: dooc
                enable: (outcome && multievent)
              - type: LevelSelector
                name: awd
                enable: (outcome && multievent)
              - type: LevelSelector
                name: awod
                enable: (outcome && multievent)
      - type: Label
        label: Analysis Type
        children:
          - type: ComboBox
            name: analysistype
            enable: (outcome && multievent)
      - type: Label
        label: Calculated Outcome to Data
        fitToGrid: true
        children:
          - type: Output
            name: outcomeredefined
  - type: CollapseBox
    label: Plots
    collapsed: true
    stretchFactor: 1
    children:
      - type: Label
        label: Hazard Regression Plots
        fitToGrid: true
        children:
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: CheckBox
                name: hr
          - type: LayoutBox
            margin: large
            children:
              - type: ComboBox
                name: sty
                enable: (hr)
      - type: Label
        label: Proportional Hazards Assumption
        fitToGrid: true
        children:
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: CheckBox
                name: ph_cox
      - type: Label
        label: Kaplan-Meier for 2 Explanatory Variables
        fitToGrid: true
        children:
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: CheckBox
                name: km

  - type: CollapseBox
    label: Plot Options
    collapsed: true
    children:
      - type: Label
        label: Plot Arguments
        children:
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: CheckBox
                name: ci95
                enable: (ac || km || plotRiskGroups)
              - type: CheckBox
                name: risktable
                enable: (ac || km || plotRiskGroups)
              - type: CheckBox
                name: censored
                enable: (ac || km || plotRiskGroups)
              - type: CheckBox
                name: pplot
                enable: (ac || km || plotRiskGroups)
              - type: TextBox
                name: endplot
                format: number
                enable: (ac || km || plotRiskGroups)
              - type: TextBox
                name: byplot
                format: number
                enable: (ac || km || plotRiskGroups)
              - type: ComboBox
                name: medianline
                enable:  (ac || km || plotRiskGroups)

  - type: CollapseBox
    label: Risk Score Grouping - Being Updated
    collapsed: true
    stretchFactor: 1
    children:
      - type: Label
        label: Risk Score Analysis
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: CheckBox
                name: calculateRiskScore
                enable: ()
              - type: CheckBox
                name: plotRiskGroups
                enable: (calculateRiskScore)
              - type: Label
                label: Risk Score Output
                children:
                  - type: LayoutBox
                    margin: large
                    children:
                      - type: Output
                        name: addRiskScore
                        enable: (calculateRiskScore)
                      - type: Output
                        name: addRiskGroup
                        enable: (calculateRiskScore)
  - type: CollapseBox
    label: Adjusted Survival Analysis
    collapsed: true
    stretchFactor: 1
    children:
      - type: Label
        label: Adjusted Survival Curves
        fitToGrid: true
        stretchFactor: 1
        children:
          - type: LayoutBox
            margin: large
            stretchFactor: 1
            children:
              - type: CheckBox
                name: ac
                fitToGrid: true
              - type: Label
                label: Select Adjusted Variable
                fitToGrid: true
                stretchFactor: 1
                children:
                  - type: VariableSupplier
                    persistentItems: false
                    stretchFactor: 1
                    children:
                      - type: TargetLayoutBox
                        label: Adjustment Variable
                        children:
                          - type: VariablesListBox
                            name: adjexplanatory
                            maxItemCount: 1
                            isTarget: true
                            fitToGrid: true
                            stretchFactor: 1
                            enable: (ac)
      - type: Label
        label: Adjustment Method
        children:
          - type: ComboBox
            name: ac_method
            enable: (ac)
      # - type: Label
      #   label: Summary Statistics
      #   children:
      #     - type: LayoutBox
      #       margin: large
      #       children:
      #         - type: CheckBox
      #           name: ac_summary
      #           enable: (ac)
      #         - type: TextBox
      #           name: ac_timepoints
      #           format: string
      #           enable: (ac_summary)
      #           width: large
      #         - type: CheckBox
      #           name: ac_compare
      #           enable: (ac_summary)
  # - type: CollapseBox
  #   label: Reduced Model Options
  #   collapsed: true
  #   children:
  #     - type: Label
  #       label: Model Comparison
  #       children:
  #         - type: CheckBox
  #           name: compare_models
  #           fitToGrid: true
  #         - type: Label
  #           label: Select Reduced Model Variables
  #           fitToGrid: true
  #           stretchFactor: 1
  #           children:
  #             - type: VariableSupplier
  #               persistentItems: false
  #               stretchFactor: 1
  #               children:
  #                 - type: TargetLayoutBox
  #                   label: Reduced Model Variables
  #                   children:
  #                     - type: VariablesListBox
  #                       name: reduced_explanatory
  #                       isTarget: true
  #                       fitToGrid: true
  #                       stretchFactor: 1
  # - type: CollapseBox
  #   label: Model Selection
  #   collapsed: true
  #   children:
  #     - type: Label
  #       label: Variable Selection Method
  #       children:
  #         - type: CheckBox
  #           name: use_modelSelection
  #         - type: LayoutBox
  #           margin: large
  #           children:
  #             - type: ComboBox
  #               name: modelSelection
  #               enable: (use_modelSelection)
  #             - type: ComboBox
  #               name: selectionCriteria
  #               enable: (use_modelSelection)
  #             - type: TextBox
  #               name: pEntry
  #               format: number
  #               label: Entry Significance (p-value)
  #               enable: (use_modelSelection)
  #             - type: TextBox
  #               name: pRemoval
  #               format: number
  #               label: Removal Significance (p-value)
  #               enable: (use_modelSelection)
  - type: CollapseBox
    label: Stratification Variables - Being Updated
    collapsed: true
    children:
      - type: Label
        label: Stratification Variables
        children:
          - type: CheckBox
            name: use_stratify
            fitToGrid: true
            enable: ()
  #         - type: Label
  #           label: Select Stratification Variables
  #           fitToGrid: true
  #           stretchFactor: 1
  #           children:
  #             - type: VariableSupplier
  #               persistentItems: false
  #               stretchFactor: 1
  #               children:
  #                 - type: TargetLayoutBox
  #                   label: Stratification Variables
  #                   children:
  #                     - type: VariablesListBox
  #                       name: stratvar
  #                       isTarget: true
  #                       fitToGrid: true
  #                       stretchFactor: 1


File: jamovi\oddsratio.a.yaml
--------------------------------------------------
Content of jamovi\oddsratio.a.yaml:
---
name:  oddsratio
title: Odds Ratio Table and Plot
menuGroup: Survival
menuSubgroup: ClinicoPath Survival
menuSubtitle: 'Odds Ratio for Binary Outcomes'
version: '1.0.0'
jas: '1.2'

description:
    main: Function for Odds Ratio Table and Plot.
    R:
        dontrun: true
        usage: |
            # example will be added

options:
    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.

    - name: explanatory
      title: Explanatory Variables
      type: Variables
      suggested: [ nominal, continuous ]
      permitted: [ factor, numeric ]
      description:
          main: >
              The explanatory variables to be used in the analysis.
          R: >
              The explanatory variables to be used in the analysis.

    - name: outcome
      title: Mortality or Recurrence
      type: Variable
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]
      description:
          main: >
              The outcome variable to be used in the analysis.
          R: >
              The outcome variable to be used in the analysis.

    # - name: outcomeLevel
    #   title: Event Level
    #   type: Level
    #   variable: (outcome)

...


File: jamovi\oddsratio.r.yaml
--------------------------------------------------
Content of jamovi\oddsratio.r.yaml:
---
name:  oddsratio
title: Odds Ratio Table and Plot
jrs:   '1.1'

items:

    - name:  todo
      title: To Do
      type:  Html
      clearWith:
          - explanatory
          - outcome


    # - name:  textmydata
    #   title: 'textmydata'
    #   type:  Preformatted


    - name:  text
      title: Odds Ratio Table
      type:  Html
      clearWith:
          - explanatory
          - outcome

    - name:  text2
      title: ''
      type:  Html



    - name: plot
      title: Odds Ratio Plot
      type: Image
      width:  600
      height: 450
      renderFun: .plot
      requiresData: true
      clearWith:
          - explanatory
          - outcome


    # - name: plot2
    #   title: Odds Ratio Plot
    #   type: Image
    #   width:  800
    #   height: 600
    #   renderFun: .plot2
    #   requiresData: true
    #   clearWith:
    #       - explanatory
    #       - outcome

refs:
    - finalfit
    - survivaltutorial
    - ClinicoPathJamoviModule



...


File: jamovi\oddsratio.u.yaml
--------------------------------------------------
Content of jamovi\oddsratio.u.yaml:
title: Odds Ratio Table and Plot
name: oddsratio
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Explanatory Variables
        children:
          - type: VariablesListBox
            name: explanatory
            isTarget: true
      - type: TargetLayoutBox
        label: Mortality or Recurrence
        children:
          - type: VariablesListBox
            name: outcome
            maxItemCount: 1
            isTarget: true
            fitToGrid: true


File: jamovi\singlearm.a.yaml
--------------------------------------------------
Content of jamovi\singlearm.a.yaml:
---
name:  singlearm
title: Single Arm Survival
menuGroup: Survival
menuSubgroup: ClinicoPath Survival
menuSubtitle: 'Survival for whole group, no explanatory factor'
version: '1.0.0'
jas: '1.2'

description:
    main: >-
      Performs survival analysis for a single cohort of patients without group comparisons.
      Use this when you want to analyze overall survival characteristics of your entire
      study population - for example, to determine median survival time or 1/3/5-year
      survival rates for all patients collectively. This differs from regular survival
      analysis which compares survival between groups.
    R:
        dontrun: true
        usage: |
            # Example analyzing overall survival for a patient cohort:
            # singlearm(
            #   data = patient_data,
            #   time = "months_survival",
            #   outcome = "death_status",
            #   outcome_level = "Dead"
            # )


options:

    # - name: lang
    #   title: Language
    #   type: List
    #   options:
    #     - title: English
    #       name: English
    #     - title: Türkçe
    #       name: Türkçe
    #     - title: Deutsch
    #       name: Deutsch
    #   default: English
    #   description:
    #       R: select language

    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.

    - name: elapsedtime
      title: 'Time Elapsed'
      type: Variable
      suggested: [ continuous ]
      permitted: [ numeric ]
      description: >-
        The time-to-event or follow-up duration for each patient. Should be numeric and
        continuous, measured in consistent units (e.g., months or years). Can be calculated
        automatically from dates if using the date options below.


    - name: tint
      title: Using Dates to Calculate Survival Time
      type: Bool
      default: false
      description: >-
        Enable this option if you want to calculate survival time from dates in your data.
        This is useful when you have separate columns for diagnosis date and follow-up date
        and want to calculate the time elapsed between them.

    - name: dxdate
      title: 'Diagnosis Date'
      type: Variable
      description: >-
        The date of diagnosis or study entry for each patient. Should be in a consistent
        date format (e.g., YYYY-MM-DD).

    - name: fudate
      title: 'Follow-up Date'
      type: Variable
      description: >-
        The date of last follow-up or event for each patient. Should be in a consistent
        date format (e.g., YYYY-MM-DD).


    - name: calculatedtime
      title: Add Calculated Time to Data
      type: Output
      description: >-
        If enabled, the calculated time-to-event will be added to your data as a new
        variable. This is useful for verifying the accuracy of the calculated time.


    - name: outcome
      title: 'Outcome'
      type: Variable
      suggested: [ ordinal, nominal, continuous ]
      permitted: [ factor, numeric ]
      description: >-
        The outcome or event of interest for each patient. Should be a factor or numeric
        variable indicating whether the patient experienced the event (e.g., death) or
        censoring (e.g., end of follow-up).

    - name: outcomeLevel
      title: Event Level
      type: Level
      variable: (outcome)
      description: >-
        Select the level of the outcome variable that represents the event of interest.
        For example, if the outcome variable is "death_status" with levels "Alive" and
        "Dead", select "Dead" as the event level.

    - name: dod
      title: Dead of Disease
      type: Level
      variable: (outcome)
      allowNone: true
      description: >-
        Select the level of the outcome variable that represents death due to disease.
        This is useful for competing risk analysis when there are multiple event types.

    - name: dooc
      title: Dead of Other
      type: Level
      variable: (outcome)
      allowNone: true
      description: >-
        Select the level of the outcome variable that represents death due to other causes.
        This is useful for competing risk analysis when there are multiple event types.

    - name: awd
      title: Alive w Disease
      type: Level
      variable: (outcome)
      allowNone: true
      description: >-
        Select the level of the outcome variable that represents being alive with disease.
        This is useful for competing risk analysis when there are multiple event types.

    - name: awod
      title: Alive w/o Disease
      type: Level
      variable: (outcome)
      allowNone: true
      description: >-
        Select the level of the outcome variable that represents being alive without disease.
        This is useful for competing risk analysis when there are multiple event types.

    - name: analysistype
      title: 'Survival Type'
      type: List
      options:
        - title: Overall
          name: overall
        - title: Cause Specific
          name: cause
        - title: Competing Risk
          name: compete
      default: overall
      description: >-
        Select the type of survival analysis to perform. "Overall" analyzes the survival
        of all patients regardless of event type. "Cause Specific" analyzes the survival
        for a specific event type (e.g., death due to disease). "Competing Risk" analyzes
        the survival for multiple event types simultaneously.


    - name: outcomeredefined
      title: Add Redefined Outcome to Data
      type: Output
      description: >-
        If enabled, the redefined outcome variable will be added to your data as a new
        variable. This is useful for verifying the accuracy of the redefined outcome.




    - name: cutp
      title: Cutpoints
      type: String
      default: '12, 36, 60'
      description: >-
        Specify the time points at which to calculate survival probabilities. Enter a
        comma-separated list of time points in consistent units (e.g., months or years).
        For example, "12, 36, 60" calculates survival probabilities at 1, 3, and 5 years.


    - name: timetypedata
      title: 'Time Type in Data (e.g., YYYY-MM-DD)'
      type: List
      options:
        - title: ymdhms
          name: ymdhms
        - title: ymd
          name: ymd
        - title: ydm
          name: ydm
        - title: mdy
          name: mdy
        - title: myd
          name: myd
        - title: dmy
          name: dmy
        - title: dym
          name: dym
      default: ymd
      description:
          R: select the time type in data (e.g., YYYY-MM-DD)


    - name: timetypeoutput
      title: Time Type in Output
      type: List
      options:
        - title: days
          name: days
        - title: weeks
          name: weeks
        - title: months
          name: months
        - title: years
          name: years
      default: months
      description:
          R: select the time type in output (default is months)


    - name: uselandmark
      title: Use Landmark Time
      type: Bool
      default: false
      description: >-
        Enables landmark analysis, which addresses immortal time bias by analyzing survival
        only for patients who survive to a specified timepoint (the landmark). Use this when
        you want to eliminate the effect of early deaths or when comparing treatments that
        can only be given to patients who survive long enough to receive them.

    - name: landmark
      title: Landmark Time
      type: Integer
      default: 3
      description: >-
        Enables landmark analysis, which addresses immortal time bias by analyzing survival
        only for patients who survive to a specified timepoint (the landmark). Use this when
        you want to eliminate the effect of early deaths or when comparing treatments that
        can only be given to patients who survive long enough to receive them.

    - name: sc
      title: "Kaplan-Meier Survival Plot"
      type: Bool
      default: false
      description: >-
        Enable this option to generate a Kaplan-Meier survival plot with confidence intervals.
        This plot shows the estimated survival probability over time and is useful for
        visualizing survival trends in your data.

    - name: kmunicate
      title: "KMunicate-Style Plot"
      type: Bool
      default: false
      description: >-
        Enable this option to generate a publication-ready survival plot in the style of
        KMunicate. This plot shows the estimated survival probability over time with
        confidence intervals and is suitable for publication or presentation.


    - name: ce
      title: Cumulative Events
      type: Bool
      default: false
      description: >-
        Enable this option to calculate and plot the cumulative number of events over time.
        This plot shows the total number of events (e.g., deaths) that have occurred at each
        time point and is useful for visualizing event rates in your data.


    - name: ch
      title: Cumulative Hazard
      type: Bool
      default: false
      description: >-
        Enable this option to calculate and plot the cumulative hazard function over time.
        This plot shows the cumulative risk of experiencing the event (e.g., death) at each
        time point and is useful for visualizing the risk of the event over time.


    - name: endplot
      title: Plot End Time
      type: Integer
      default: 60
      description: >-
        The maximum time point to include in the survival plots. This is the end time for
        the survival curves and cumulative event/hazard plots. Enter a positive integer
        representing the time in consistent units (e.g., months or years).

    - name: ybegin_plot
      title: Start y-axis
      type: Number
      default: 0.00
      description: >-
        The minimum value for the y-axis in the survival plots. Enter a number between 0
        and 1 to set the lower limit of the y-axis.

    - name: yend_plot
      title: End y-axis
      type: Number
      default: 1.00
      description: >-
        The maximum value for the y-axis in the survival plots. Enter a number between 0
        and 1 to set the upper limit of the y-axis.

    - name: byplot
      title: Time Interval
      type: Integer
      default: 12
      description: >-
        The interval for plotting survival probabilities. Enter a positive integer
        representing the time interval in consistent units (e.g., months or years).


    - name: multievent
      title: "Multiple Event Levels"
      type: Bool
      default: false
      description: >-
        Enable this option to perform survival analysis for datasets with multiple event
        levels. This is useful for competing risk analysis when there are multiple event
        types (e.g., death due to disease, death due to other causes).

    - name: ci95
      title: '95% CI'
      type: Bool
      default: false
      description: >-
        Enable this option to display 95% confidence intervals on the survival plots.
        These intervals show the range of uncertainty around the estimated survival
        probabilities and are useful for assessing the precision of the estimates.

    - name: risktable
      title: risktable
      type: Bool
      default: false
      description: >-
        Enable this option to display a table of risk estimates at each time point.
        This table shows the estimated survival probability, cumulative event rate,
        and cumulative hazard at each time point and is useful for summarizing the
        survival characteristics of your data.

    - name: censored
      title: censored
      type: Bool
      default: false
      description: >-
        Enable this option to display censored observations on the survival plots.
        Censored observations are patients who have not experienced the event of
        interest by the end of follow-up and are indicated by vertical ticks on the
        survival curves.

    - name: medianline
      title: medianline
      type: List
      options:
        - title: none
          name: none
        - title: horizontal
          name: h
        - title: vertical
          name: v
        - title: both
          name: hv
      default: none
      description:
        R: >
          If true, displays a line indicating the median survival time on the survival plot.
...



File: jamovi\singlearm.r.yaml
--------------------------------------------------
Content of jamovi\singlearm.r.yaml:
---
name:  singlearm
title: Single Arm Survival
jrs:   '1.1'

items:

    - name:  todo
      title: To Do
      type:  Html
      clearWith:
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent


    # - name:  mydataview
    #   title: mydataview
    #   type:  Preformatted


    - name:  medianSummary
      title: Median Survival Summary and Table
      type:  Preformatted
      clearWith:
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent

    # - name:  medianSummary2
    #   title: medianSummary2
    #   type:  Preformatted

    - name:  medianTable
      title: Median Survival Table
      type:  Table
      rows: 0
      columns:
        - name: records
          title: "Records"
          type: integer
        # - name: n_max
        #   title: "n_max"
        #   type: number
        # - name: n_start
        #   title: "n_start"
        #   type: number
        - name: events
          title: "Events"
          type: integer
        - name: rmean
          title: "rmean"
          type: number
        - name: se_rmean
          title: "se_rmean"
          type: number
        - name: median
          title: "Median"
          type: number
        - name: x0_95lcl
          title: "Lower"
          superTitle: '95% Confidence Interval'
          type: number
        - name: x0_95ucl
          title: "Upper"
          superTitle: '95% Confidence Interval'
          type: number
      clearWith:
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent


    - name:  survTableSummary
      title: '1, 3, 5-yr Survival Summary and Table'
      type:  Preformatted
      clearWith:
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent




    - name:  survTable
      title: '1, 3, 5 year Survival'
      type:  Table
      rows: 0
      columns:
        - name: 'time'
          title: "time"
          type: integer
        - name: n.risk
          title: "Number at Risk"
          type: integer
        - name: n.event
          title: "Number of Events"
          type: integer
        - name: surv
          title: "Survival"
          type: number
          format: pc
        - name: lower
          title: "Lower"
          superTitle: '95% Confidence Interval'
          type: number
          format: pc
        - name: upper
          title: "Upper"
          superTitle: '95% Confidence Interval'
          type: number
          format: pc
      clearWith:
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent




    - name: plot
      title: Survival Plot
      type: Image
      width:  600
      height: 450
      renderFun: .plot
      visible: (sc)
      requiresData: true
      clearWith:
          - sc
          - endplot
          - byplot
          - sas
          - ci95
          - risktable
          - censored
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent



    - name: plot2
      title: Cumulative Events
      type: Image
      width:  600
      height: 450
      renderFun: .plot2
      visible: (ce)
      requiresData: true
      clearWith:
          - ce
          - endplot
          - byplot
          - sas
          - ci95
          - risktable
          - censored
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent



    - name: plot3
      title: Cumulative Hazard
      type: Image
      width:  600
      height: 450
      renderFun: .plot3
      visible: (ch)
      requiresData: true
      clearWith:
          - ch
          - endplot
          - byplot
          - sas
          - ci95
          - risktable
          - censored
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent



    - name: plot6
      title: 'KMunicate-Style Plot'
      type: Image
      width:  600
      height: 450
      renderFun: .plot6
      visible: (kmunicate)
      requiresData: true
      clearWith:
          - kmunicate
          - endplot
          - byplot
          - sas
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent
      refs:
          - KMunicate
          - KMunicate2


    - name: calculatedtime
      title: Add Calculated Time to Data
      type: Output
      varTitle: 'Calculated Time Single Arm'
      varDescription: '`Calculated Time from given Dates in Single Arm Analysis - from ${ dxdate } to { fudate }`'
      clearWith:
          - tint
          - dxdate
          - fudate


    - name: outcomeredefined
      title: Add Redefined Outcome to Data
      type: Output
      varTitle: 'Redefined Outcome Single Arm'
      varDescription: '`Redefined Outcome - from ${ outcome } for analysis { analysistype } in Single Arm Analysis`'
      clearWith:
          - outcome
          - analysistype
          - multievent
          - outcomeLevel

refs:
    - finalfit
    - survival
    - survminer
    - ClinicoPathJamoviModule
    - survivaltutorial
    - survivalrwnahhas


...


File: jamovi\singlearm.u.yaml
--------------------------------------------------
Content of jamovi\singlearm.u.yaml:
title: Single Arm Survival
name: singlearm
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Time Elapsed
        children:
          - type: VariablesListBox
            name: elapsedtime
            maxItemCount: 1
            isTarget: true
      - type: TargetLayoutBox
        label: Outcome
        children:
          - type: VariablesListBox
            name: outcome
            maxItemCount: 1
            isTarget: true
            fitToGrid: true
          - type: LevelSelector
            name: outcomeLevel
            enable: (outcome && !multievent)
  - type: CollapseBox
    label: Advanced Elapsed Time Options
    collapsed: true
    stretchFactor: 1
    children:
      - type: Label
        label: Time Interval
        fitToGrid: true
        stretchFactor: 1
        children:
          - type: LayoutBox
            margin: large
            stretchFactor: 1
            children:
              - type: CheckBox
                name: tint
                fitToGrid: true
              - type: Label
                label: Date Variables
                fitToGrid: true
                stretchFactor: 1
                children:
                  - type: VariableSupplier
                    persistentItems: false
                    stretchFactor: 1
                    children:
                      - type: TargetLayoutBox
                        children:
                          - type: VariablesListBox
                            name: dxdate
                            maxItemCount: 1
                            isTarget: true
                            fitToGrid: true
                            stretchFactor: 1
                      - type: TargetLayoutBox
                        children:
                          - type: VariablesListBox
                            name: fudate
                            maxItemCount: 1
                            isTarget: true
                            fitToGrid: true
                            stretchFactor: 1
              - type: Label
                label: Time Type
                fitToGrid: true
                stretchFactor: 1
                children:
                  - type: LayoutBox
                    margin: large
                    fitToGrid: true
                    children:
                      - type: ComboBox
                        name: timetypedata
                        enable: (tint)
                      - type: ComboBox
                        name: timetypeoutput
                        enable: (tint)
      - type: Label
        label: Landmark Time
        fitToGrid: true
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: CheckBox
                name: uselandmark
                children:
                  - type: TextBox
                    name: landmark
                    format: number
                    enable: (uselandmark)
      - type: Label
        label: Calculated Time to Data 
        fitToGrid: true
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: Output
                name: calculatedtime
                enable: (tint)
  - type: CollapseBox
    label: Analysis with Multiple Outcomes
    collapsed: true
    children:
      - type: Label
        label: Multiple Event Levels
        fitToGrid: true
        children:
          - type: CheckBox
            name: multievent
            enable: (outcome)
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: LevelSelector
                name: dod
                enable: (outcome && multievent)
              - type: LevelSelector
                name: dooc
                enable: (outcome && multievent)
              - type: LevelSelector
                name: awd
                enable: (outcome && multievent)
              - type: LevelSelector
                name: awod
                enable: (outcome && multievent)
      - type: Label
        label: Analysis Type
        children:
          - type: ComboBox
            name: analysistype
            enable: (outcome && multievent)
      - type: Label
        label: Calculated Outcome to Data 
        fitToGrid: true
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: Output
                name: outcomeredefined
                enable: (outcome && multievent)
                
  - type: CollapseBox
    label: Plots
    collapsed: true
    children:
      - type: Label
        label: Plots
        fitToGrid: true
        children:
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: CheckBox
                name: sc
              - type: CheckBox
                name: kmunicate
              - type: CheckBox
                name: ce
              - type: CheckBox
                name: ch
      - type: Label
        label: Plot Arguments
        children:
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: TextBox
                name: endplot
                format: number
              - type: TextBox
                name: byplot
                format: number
              - type: TextBox
                name: ybegin_plot
                format: number
              - type: TextBox
                name: yend_plot
                format: number
              - type: CheckBox
                name: ci95
              - type: CheckBox
                name: risktable
              - type: CheckBox
                name: censored
              - type: ComboBox
                name: medianline
  - type: CollapseBox
    label: Survival Tables
    collapsed: true
    children:
      - type: Label
        label: Survival table
        children:
          - type: TextBox
            name: cutp
            format: string
            width: large



File: jamovi\survival.a.yaml
--------------------------------------------------
Content of jamovi\survival.a.yaml:
---
name:  survival
title: Survival Analysis
menuGroup: Survival
menuSubgroup: ClinicoPath Survival
menuSubtitle: 'Univariate Survival Analysis, Cox, Kaplan-Meier, 1,3,5-yr'
version: '1.0.0'
jas: '1.2'

description:
    main: Function for Generating Summaries for Survival Analysis.
    R:
        dontrun: false
        usage: |
            # example will be added


options:

    # - name: lang
    #   title: Language
    #   type: List
    #   options:
    #     - title: English
    #       name: English
    #     - title: Türkçe
    #       name: Türkçe
    #     - title: Deutsch
    #       name: Deutsch
    #   default: English
    #   description:
    #       R: select language

    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.

    - name: elapsedtime
      title: 'Time Elapsed'
      type: Variable
      suggested: [ continuous ]
      permitted: [ numeric ]
      description:
          R: >
            The time elapsed from the start of the study to the event or censoring.


    - name: tint
      title: Using Dates to Calculate Survival Time
      type: Bool
      default: false
      description:
          R: >
            If the time is in date format, select this option to calculate the survival time. The time will be calculated as the
            difference between the event date and the diagnosis date. If the follow-up date is available, the time will be 
            calculated as the difference between the event date and the follow-up date.

    - name: dxdate
      title: 'Diagnosis Date'
      type: Variable
      description:
          R: >
            The date of diagnosis. If the time is in date format, the time will be calculated as the difference between the event date and the diagnosis date.

    - name: fudate
      title: 'Follow-up Date'
      type: Variable
      description:
          R: >
            The date of follow-up. If the time is in date format, the time will be calculated as the difference between the event date and the follow-up date.


    - name: calculatedtime
      title: Add Calculated Time to Data
      type: Output
      description:
          R: >
            If the time is in date format, the time will be calculated as the difference between the event date and the diagnosis date. If the follow-up date is available, the time will be calculated as the difference between the event date and the follow-up date.


    - name: explanatory
      title: Explanatory Variable
      type: Variable
      suggested: [ ordinal, nominal ]
      permitted: [ factor ]
      description:
          R: >
            The explanatory variable that will be used to compare the survival times of different groups.


    - name: outcome
      title: 'Outcome'
      type: Variable
      suggested: [ ordinal, nominal, continuous ]
      permitted: [ factor, numeric ]
      description:
          R: >
            The outcome variable that will be used to compare the survival times of different groups.

    - name: outcomeLevel
      title: Event Level
      type: Level
      variable: (outcome)
      description:
          R: >
            The level of the outcome variable that will be used as the event level.

    - name: dod
      title: Dead of Disease
      type: Level
      variable: (outcome)
      allowNone: true
    - name: dooc
      title: Dead of Other
      type: Level
      variable: (outcome)
      allowNone: true
    - name: awd
      title: Alive w Disease
      type: Level
      variable: (outcome)
      allowNone: true
    - name: awod
      title: Alive w/o Disease
      type: Level
      variable: (outcome)
      allowNone: true

    - name: analysistype
      title: 'Survival Type'
      type: List
      options:
        - title: Overall
          name: overall
        - title: Cause Specific
          name: cause
        - title: Competing Risk
          name: compete
      default: overall


    - name: outcomeredefined
      title: Add Redefined Outcome to Data
      type: Output




    - name: cutp
      title: Cutpoints
      type: String
      default: '12, 36, 60'


    - name: timetypedata
      title: 'Time Type in Data (e.g., YYYY-MM-DD)'
      type: List
      options:
        - title: ymdhms
          name: ymdhms
        - title: ymd
          name: ymd
        - title: ydm
          name: ydm
        - title: mdy
          name: mdy
        - title: myd
          name: myd
        - title: dmy
          name: dmy
        - title: dym
          name: dym
      default: ymd
      description:
          R: select the time type in data


    - name: timetypeoutput
      title: Time Type in Output
      type: List
      options:
        - title: days
          name: days
        - title: weeks
          name: weeks
        - title: months
          name: months
        - title: years
          name: years
      default: months
      description:
          R: select the time type in output


    - name: uselandmark
      title: Use Landmark Time
      type: Bool
      default: false

    - name: landmark
      title: Landmark Time
      type: Integer
      default: 3

    - name: pw
      title: Pairwise comparisons
      type: Bool
      default: false



    - name: padjustmethod
      title: 'Adjustment Method'
      type: List
      options:
        - title: holm
          name: holm
        - title: hochberg
          name: hochberg
        - title: hommel
          name: hommel
        - title: bonferroni
          name: bonferroni
        - title: BH
          name: BH
        - title: BY
          name: BY
        - title: fdr
          name: fdr
        - title: none
          name: none
      default: holm


    - name: ph_cox
      title: Proportional Hazards Assumption
      type: Bool
      default: false

    - name: sc
      title: Survival Plot
      type: Bool
      default: false

    - name: kmunicate
      title: KMunicate-Style Plot
      type: Bool
      default: false


    - name: ce
      title: Cumulative Events
      type: Bool
      default: false


    - name: ch
      title: Cumulative Hazard
      type: Bool
      default: false


    - name: endplot
      title: Plot End Time
      type: Integer
      default: 60

    - name: ybegin_plot
      title: Start y-axis
      type: Number
      default: 0.00

    - name: yend_plot
      title: End y-axis
      type: Number
      default: 1.00


    - name: byplot
      title: Time Interval
      type: Integer
      default: 12


    - name: multievent
      title: Multiple Event Levels
      type: Bool
      default: false

    - name: ci95
      title: '95% CI'
      type: Bool
      default: false

    - name: risktable
      title: risktable
      type: Bool
      default: false

    - name: censored
      title: censored
      type: Bool
      default: false

    - name: pplot
      title: p-value
      type: Bool
      default: true

    - name: medianline
      title: medianline
      type: List
      options:
        - title: none
          name: none
        - title: horizontal
          name: h
        - title: vertical
          name: v
        - title: both
          name: hv
      default: none
      description:
        R: >
          If true, displays a line indicating the median survival time on the survival plot.

...


File: jamovi\survival.r.yaml
--------------------------------------------------
Content of jamovi\survival.r.yaml:
---
name:  survival
title: Survival Analysis
# title: '`Survival Analysis - ${explanatory}`'
jrs:   '1.1'


items:
    - name: subtitle
      title: '`Survival Analysis - ${explanatory}`'
      type:  Preformatted



    - name:  todo
      title: To Do
      type:  Html
      clearWith:
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent


    # - name:  mydataview
    #   title: mydataview
    #   type:  Preformatted


    # - name:  medianSummary2
    #   title: medianSummary2
    #   type:  Preformatted



    - name:  medianSummary
      # title: Median Survival Summary and Table
      title: '`Median Survival Summary and Table - ${explanatory}`'
      type:  Preformatted
      clearWith:
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent




    - name:  medianTable
      # title: Median Survival Table
      title: '`Median Survival Table: Levels for ${explanatory}`'
      type:  Table
      rows: 0
      columns:
        - name: factor
          title: "Levels"
          # title: '`Factor - ${explanatory}`'
          type: text
        - name: records
          title: "Records"
          type: integer
        # - name: n_max
        #   title: "n_max"
        #   type: number
        # - name: n_start
        #   title: "n_start"
        #   type: number
        - name: events
          title: "Events"
          type: integer
        - name: rmean
          title: "rmean"
          type: number
        - name: se_rmean
          title: "se_rmean"
          type: number
        - name: median
          title: "Median"
          type: number
        - name: x0_95lcl
          title: "Lower"
          superTitle: '95% Confidence Interval'
          type: number
        - name: x0_95ucl
          title: "Upper"
          superTitle: '95% Confidence Interval'
          type: number
      clearWith:
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent


    - name:  coxSummary
      # title: Cox Regression Summary and Table
      title: '`Cox Regression Summary and Table - ${explanatory}`'
      type:  Preformatted
      clearWith:
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent



    - name:  coxTable
      # title: Cox Table
      title: '`Cox Table- ${explanatory}`'
      type:  Table
      rows: 0
      columns:
        - name: Explanatory
          title: "Explanatory"
          type: text
        - name: 'Levels'
          title: "Levels"
          type: text
        - name: 'all'
          title: "all"
          type: text
        - name: 'HR_univariable'
          title: "HR (Univariable)"
          type: text
        # - name: 'HR_multivariable'
        #   title: "HR (Multivariable)"
        #   type: text
      clearWith:
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent



    - name:  tCoxtext2
      title: ''
      type:  Html
      refs: finalfit
      clearWith:
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent
          - contexpl



    - name: cox_ph
      title: 'Proportional Hazards Assumption'
      type:  Preformatted
      visible: (ph_cox)
      clearWith:
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent
          - contexpl



    - name: plot8
      title: '`Proportional Hazards Assumption - ${explanatory}`'
      type: Image
      width:  600
      height: 450
      renderFun: .plot8
      visible: (ph_cox)
      requiresData: true
      clearWith:
          - ph_cox
          - endplot
          - byplot
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent


    - name:  survTableSummary
      # title: '1, 3, 5-yr Survival Summary and Table'
      title: '`1, 3, 5-yr Survival Summary and Table  - ${explanatory}`'
      type:  Preformatted
      clearWith:
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent


    # - name:  tableview
    #   title: tableview
    #   type:  Preformatted


    - name:  survTable
      title: '`1, 3, 5 year Survival - ${explanatory}`'
      # title: '1, 3, 5 year Survival'
      type:  Table
      rows: 0
      columns:
        - name: strata
          title: "Levels"
          type: text
        - name: 'time'
          title: "time"
          type: integer
        - name: n.risk
          title: "Number at Risk"
          type: integer
        - name: n.event
          title: "Number of Events"
          type: integer
        - name: surv
          title: "Survival"
          type: number
          format: pc
        - name: lower
          title: "Lower"
          superTitle: '95% Confidence Interval'
          type: number
          format: pc
        - name: upper
          title: "Upper"
          superTitle: '95% Confidence Interval'
          type: number
          format: pc
      clearWith:
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent




    - name:  pairwiseSummary
      # title: Pairwise Comparison Summary and Table
      title: '`Pairwise Comparison Summary and Table - ${explanatory}`'
      type:  Preformatted
      clearWith:
          - pw
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent
      visible: (pw)




    - name:  pairwiseTable
      title: '`Pairwise Comparison Table - ${explanatory}`'
      type:  Table
      rows: 0
      columns:
        - name: rowname
          title: "Levels"
          type: text
        - name: name
          title: "Levels"
          type: text
        - name: value
          title: p-value
          type: number
          format: zto,pvalue
      visible: (pw)
      clearWith:
          - pw
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent
      refs:
          - padjust



    - name: plot
      title: '`Survival Plot - ${explanatory}`'
      type: Image
      width:  600
      height: 450
      renderFun: .plot
      visible: (sc)
      requiresData: true
      clearWith:
          - sc
          - endplot
          - byplot
          - ybegin_plot
          - yend_plot
          - ci95
          - risktable
          - censored
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent
          - pplot



    - name: plot2
      title: '`Cumulative Events - ${explanatory}`'
      type: Image
      width:  600
      height: 450
      renderFun: .plot2
      visible: (ce)
      requiresData: true
      clearWith:
          - ce
          - endplot
          - byplot
          - ybegin_plot
          - yend_plot
          - ci95
          - risktable
          - censored
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent



    - name: plot3
      title: '`Cumulative Hazard - ${explanatory}`'
      type: Image
      width:  600
      height: 450
      renderFun: .plot3
      visible: (ch)
      requiresData: true
      clearWith:
          - ch
          - endplot
          - byplot
          - ybegin_plot
          - yend_plot
          - ci95
          - risktable
          - censored
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent



    - name: plot6
      title: '`KMunicate-Style Plot - ${explanatory}`'
      type: Image
      width:  600
      height: 450
      renderFun: .plot6
      visible: (kmunicate)
      requiresData: true
      clearWith:
          - kmunicate
          - endplot
          - byplot
          - ybegin_plot
          - yend_plot
          - explanatory
          - outcome
          - outcomeLevel
          - overalltime
          - fudate
          - dxdate
          - tint
          - multievent
      refs:
          - KMunicate
          - KMunicate2





    # - name:  mydataview
    #   title: mydataview
    #   type:  Preformatted



    - name: calculatedtime
      title: Add Calculated Time to Data
      type: Output
      varTitle: '`Calculated Time - from ${ dxdate } to { fudate }`'
      varDescription: '`Calculated Time from Given Dates - from ${ dxdate } to { fudate } in Survival Analysis`'
      measureType: continuous
      clearWith:
          - tint
          - dxdate
          - fudate
          - overalltime
          - calculatedtime



    - name: outcomeredefined
      title: Add Redefined Outcome to Data
      type: Output
      varTitle: '`Redefined Outcome - from ${ outcome } for { analysistype } survival analysis`'
      varDescription: Redefined Outcome from Outcome based on Analysis Type in Survival Analysis
      clearWith:
          - outcome
          - analysistype
          - multievent
          - explanatory
          - outcomeLevel

refs:
    - finalfit
    - survival
    - survminer
    - survivaltutorial
    - survivalrwnahhas
    - survivalrviews
    - appliedsurvivalanalysisR
    - ClinicoPathJamoviModule

...


File: jamovi\survival.u.yaml
--------------------------------------------------
Content of jamovi\survival.u.yaml:
title: Survival Analysis
name: survival
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Time Elapsed
        children:
          - type: VariablesListBox
            name: elapsedtime
            maxItemCount: 1
            isTarget: true
      - type: TargetLayoutBox
        label: Outcome
        children:
          - type: VariablesListBox
            name: outcome
            maxItemCount: 1
            isTarget: true
            fitToGrid: true
          - type: LevelSelector
            name: outcomeLevel
            enable: (outcome && !multievent)
      - type: TargetLayoutBox
        label: Explanatory Variable
        children:
          - type: VariablesListBox
            name: explanatory
            maxItemCount: 1
            isTarget: true
  - type: CollapseBox
    label: Advanced Elapsed Time Options
    collapsed: true
    stretchFactor: 1
    children:
      - type: Label
        label: Time Interval
        fitToGrid: true
        stretchFactor: 1
        children:
          - type: LayoutBox
            margin: large
            stretchFactor: 1
            children:
              - type: CheckBox
                name: tint
                fitToGrid: true
              - type: Label
                label: Date Variables
                fitToGrid: true
                stretchFactor: 1
                children:
                  - type: VariableSupplier
                    persistentItems: false
                    stretchFactor: 1
                    children:
                      - type: TargetLayoutBox
                        children:
                          - type: VariablesListBox
                            name: dxdate
                            maxItemCount: 1
                            isTarget: true
                            fitToGrid: true
                            stretchFactor: 1
                      - type: TargetLayoutBox
                        children:
                          - type: VariablesListBox
                            name: fudate
                            maxItemCount: 1
                            isTarget: true
                            fitToGrid: true
                            stretchFactor: 1
              - type: Label
                label: Time Type
                fitToGrid: true
                stretchFactor: 1
                children:
                  - type: LayoutBox
                    margin: large
                    fitToGrid: true
                    children:
                      - type: ComboBox
                        name: timetypedata
                        enable: (tint)
                      - type: ComboBox
                        name: timetypeoutput
                        enable: (tint)
      - type: Label
        label: Landmark Time
        fitToGrid: true
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: CheckBox
                name: uselandmark
                children:
                  - type: TextBox
                    name: landmark
                    format: number
                    enable: (uselandmark)
      - type: Label
        label: Calculated Time to Data
        fitToGrid: true
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: Output
                name: calculatedtime
                enable: (tint)
  - type: CollapseBox
    label: Analysis with Multiple Outcomes
    collapsed: true
    children:
      - type: Label
        label: Multiple Event Levels
        fitToGrid: true
        children:
          - type: CheckBox
            name: multievent
            enable: (outcome)
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: LevelSelector
                name: dod
                enable: (outcome && multievent)
              - type: LevelSelector
                name: dooc
                enable: (outcome && multievent)
              - type: LevelSelector
                name: awd
                enable: (outcome && multievent)
              - type: LevelSelector
                name: awod
                enable: (outcome && multievent)
      - type: Label
        label: Analysis Type
        children:
          - type: ComboBox
            name: analysistype
            enable: (outcome && multievent)
      - type: Label
        label: Calculated Outcome to Data
        fitToGrid: true
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: Output
                name: outcomeredefined
                enable: (outcome && multievent)


  - type: CollapseBox
    label: Pairwise Comparisons
    collapsed: true
    children:
      - type: Label
        label: Pairwise comparisons
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: CheckBox
                name: pw
              - type: ComboBox
                name: padjustmethod
                enable: (pw)

  - type: CollapseBox
    label: Plots
    collapsed: true
    children:
      - type: Label
        label: Plots
        fitToGrid: true
        children:
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: CheckBox
                name: ph_cox
              - type: CheckBox
                name: sc
              - type: CheckBox
                name: kmunicate
              - type: CheckBox
                name: ce
              - type: CheckBox
                name: ch
      - type: Label
        label: Plot Arguments
        children:
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: TextBox
                name: endplot
                format: number
              - type: TextBox
                name: byplot
                format: number
              - type: TextBox
                name: ybegin_plot
                format: number
              - type: TextBox
                name: yend_plot
                format: number
              - type: CheckBox
                name: ci95
              - type: CheckBox
                name: risktable
              - type: CheckBox
                name: censored
              - type: CheckBox
                name: pplot
              - type: ComboBox
                name: medianline
  - type: CollapseBox
    label: Survival Tables
    collapsed: true
    children:
      - type: Label
        label: Survival table
        children:
          - type: TextBox
            name: cutp
            format: string
            width: large


File: jamovi\survivalcont.a.yaml
--------------------------------------------------
Content of jamovi\survivalcont.a.yaml:
---
name:  survivalcont
title: Survival Analysis for Continuous Variable
menuGroup: Survival
menuSubgroup: ClinicoPath Survival
menuSubtitle: 'Cut-off & Univariate Survival Analysis'
version: '1.0.0'
jas: '1.2'

options:

    - name: data
      type: Data
      description:
          R: >
            The data as a data frame.

    - name: elapsedtime
      title: 'Time Elapsed'
      type: Variable
      suggested: [ continuous ]
      permitted: [ numeric ]
      description: >-
        The time-to-event or follow-up duration for each patient. Should be numeric and
        continuous, measured in consistent units (e.g., months or years). Can be calculated
        automatically from dates if using the date options below.


    - name: tint
      title: Using Dates to Calculate Survival Time
      type: Bool
      default: false
      description: >-
        Enable this option if you want to calculate survival time from dates in your data.
        This is useful when you have separate columns for diagnosis date and follow-up date
        and want to calculate the time elapsed between them.

    - name: dxdate
      title: 'Diagnosis Date'
      type: Variable
      description: >-
        The date of diagnosis or study entry for each patient. Should be in a consistent
        date format (e.g., YYYY-MM-DD).

    - name: fudate
      title: 'Follow-up Date'
      type: Variable
      description: >-
        The date of last follow-up or event for each patient. Should be in a consistent
        date format (e.g., YYYY-MM-DD).

    - name: calculatedtime
      title: Add Calculated Time to Data
      type: Output
      description: >-
        If you enable this option, the calculated time-to-event or follow-up duration will be
        added to your data as a new variable.

    - name: contexpl
      title: Continuous Explanatory Variable
      type: Variable
      suggested: [ continuous ]
      permitted: [ numeric ]
      description: >-
        The continuous explanatory variable to be used in the analysis.

    - name: outcome
      title: 'Outcome'
      type: Variable
      suggested: [ ordinal, nominal, continuous ]
      permitted: [ factor, numeric ]
      description: >-
        The outcome variable to be used in the analysis.

    - name: outcomeLevel
      title: Event Level
      type: Level
      variable: (outcome)
      description: >-
        The level of the outcome variable that represents the event of interest.

    - name: dod
      title: Dead of Disease
      type: Level
      variable: (outcome)
      allowNone: true
    - name: dooc
      title: Dead of Other
      type: Level
      variable: (outcome)
      allowNone: true
    - name: awd
      title: Alive w Disease
      type: Level
      variable: (outcome)
      allowNone: true
    - name: awod
      title: Alive w/o Disease
      type: Level
      variable: (outcome)
      allowNone: true
      description: >-
        Select the levels of the outcome variable that correspond to different event types
        in your data. For example, you might have separate levels for "Dead of Disease" and
        "Alive w Disease" in a survival analysis of cancer patients.

    - name: analysistype
      title: 'Survival Type'
      type: List
      options:
        - title: Overall
          name: overall
        - title: Cause Specific
          name: cause
        - title: Competing Risk
          name: compete
      default: overall
      description: >-
        Select the type of survival analysis to perform. "Overall" survival analysis
        considers all events as equivalent, while "Cause Specific" analysis distinguishes
        between different event types. "Competing Risk" analysis accounts for competing
        risks that may prevent the event of interest from occurring.

    - name: outcomeredefined
      title: Add Redefined Outcome to Data
      type: Output
      description: >-
        If you enable this option, the redefined outcome variable will be added to your data
        as a new variable. This variable will have two levels: "Event" for the event of
        interest and "Censored" for patients who were lost to follow-up or experienced a
        competing event.

    - name: cutp
      title: Cutpoints
      type: String
      default: '12, 36, 60'
      description: >-
        Specify the cutpoints at which to divide the continuous explanatory variable into
        groups for survival analysis. Separate multiple cutpoints with commas (e.g., "12,
        36, 60").


    - name: timetypedata
      title: 'Time Type in Data (e.g., YYYY-MM-DD)'
      type: List
      options:
        - title: ymdhms
          name: ymdhms
        - title: ymd
          name: ymd
        - title: ydm
          name: ydm
        - title: mdy
          name: mdy
        - title: myd
          name: myd
        - title: dmy
          name: dmy
        - title: dym
          name: dym
      default: ymd
      description:
          R: select the time type in data


    - name: timetypeoutput
      title: Time Type in Output
      type: List
      options:
        - title: days
          name: days
        - title: weeks
          name: weeks
        - title: months
          name: months
        - title: years
          name: years
      default: months
      description:
          R: select the time type in output

    - name: uselandmark
      title: Use Landmark Time
      type: Bool
      default: false
      description: >-
        Enable this option to perform landmark survival analysis at a specified time point.

    - name: landmark
      title: Landmark Time
      type: Integer
      default: 3
      description: >-
        Specify the landmark time at which to evaluate survival probabilities in landmark
        analysis. This option is only available if you enable the "Use Landmark Time" option.



    - name: sc
      title: Survival Plot
      type: Bool
      default: false
      description: >-
        Enable this option to create a Kaplan-Meier survival plot for the continuous
        explanatory variable.

    - name: kmunicate
      title: KMunicate-Style Plot
      type: Bool
      default: false
      description: >-
        Enable this option to create a KMunicate-style survival plot for the continuous
        explanatory variable.


    - name: ce
      title: Cumulative Events
      type: Bool
      default: false
      description: >-
        Enable this option to create a plot of cumulative events over time for the continuous
        explanatory variable.


    - name: ch
      title: Cumulative Hazard
      type: Bool
      default: false
      description: >-
        Enable this option to create a plot of cumulative hazard over time for the continuous
        explanatory variable.


    - name: endplot
      title: Plot End Time
      type: Integer
      default: 60
      description: >-
        Specify the end time for the survival plots. This option determines the maximum time
        point to include in the plots.

    - name: ybegin_plot
      title: Start y-axis
      type: Number
      default: 0.00
      description: >-
        Specify the starting value for the y-axis in the survival plots. This option allows
        you to customize the range of the y-axis.

    - name: yend_plot
      title: End y-axis
      type: Number
      default: 1.00
      description: >-
        Specify the ending value for the y-axis in the survival plots. This option allows you
        to customize the range of the y-axis.

    - name: byplot
      title: Time Interval
      type: Integer
      default: 12
      description: >-
        Specify the time interval for the survival plots. This option determines the spacing
        of tick marks on the x-axis.



    - name: findcut
      title: Find Cut-off for Continious Explanatory Variable
      type: Bool
      default: false
      description: >-
        Enable this option to automatically find the optimal cut-off point for the continuous explanatory variable using the maximally
        selected rank statistic. This option is only available if you enable the "Survival Plot" option. The optimal cut-off point
        will be displayed on the survival plot as a vertical dashed line.
        
    - name: calculatedcutoff
      title: Add Calculated Cut-off Group to Data
      type: Output
      description: >-
        If you enable this option, the calculated cut-off group will be added to your data as a new variable. This variable will have
        two levels: "Below Cut-off" and "Above Cut-off" based on the optimal cut-off point found using the maximally selected rank
        statistic. This option is only available if you enable the "Find Cut-off for Continious Explanatory Variable" option.


    - name: multievent
      title: Multiple Event Levels
      type: Bool
      default: false
      description: >-
        Enable this option if your data includes multiple event levels (e.g., different types
        of events or outcomes). This option is required for cause-specific and competing risk
        survival analyses.

    - name: ci95
      title: '95% CI'
      type: Bool
      default: false
      description: >-
        Enable this option to display 95% confidence intervals around the survival estimates
        in the plots.

    - name: risktable
      title: risktable
      type: Bool
      default: false
      description: >-
        Enable this option to display a table of risk estimates for each group in the survival
        analysis.

    - name: censored
      title: censored
      type: Bool
      default: false
      description: >-
        Enable this option to display censored observations in the survival plots.

    - name: medianline
      title: medianline
      type: List
      options:
        - title: none
          name: none
        - title: horizontal
          name: h
        - title: vertical
          name: v
        - title: both
          name: hv
      default: none
      description:
        R: >
          If true, displays a line indicating the median survival time on the survival plot.
...


File: jamovi\survivalcont.r.yaml
--------------------------------------------------
Content of jamovi\survivalcont.r.yaml:
---
name:  survivalcont
title: Survival Analysis for Continuous Explanatory Variable
jrs:   '1.1'


items:

    - name:  todo
      title: To Do
      type:  Html

    # - name:  mydataview2
    #   title: mydataview2
    #   type:  Preformatted

    # - name:  mydataview
    #   title: mydataview
    #   type:  Preformatted

    - name:  coxSummary
      title: '`Cox Regression Summary and Table - ${contexpl}`'
      type:  Preformatted
      clearWith:
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name:  coxTable
      title: '`Cox Table- ${contexpl}`'
      type:  Table
      rows: 0
      columns:
        - name: Explanatory
          title: "Explanatory"
          type: text
        - name: 'Levels'
          title: "Levels"
          type: text
        - name: 'all'
          title: "all"
          type: text
        - name: 'HR_univariable'
          title: "HR (Univariable)"
          type: text
        - name: 'HR_multivariable'
          title: "HR (Multivariable)"
          type: text
      clearWith:
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name:  tCoxtext2
      title: ''
      type:  Html
      refs: finalfit
      clearWith:
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name:  rescutTable
      title: Cut Point
      type:  Table
      rows: 0
      columns:
        - name: cutpoint
          title: 'Cut Point'
          type: number
        - name: statistic
          title: 'Statistic'
          type: number
      visible: (findcut)
      clearWith:
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name: plot4
      title: 'Cutpoint Plot'
      type: Image
      width:  600
      height: 450
      renderFun: .plot4
      visible: (findcut)
      requiresData: true
      clearWith:
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name: plot5
      title: '`Survival Plot - ${contexpl} Grouped with New Cut-Off`'
      type: Image
      width:  600
      height: 450
      renderFun: .plot5
      visible: (findcut && sc)
      requiresData: true
      clearWith:
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name:  medianSummary
      # title: Median Survival Summary and Table
      title: '`Median Survival Summary and Table - ${contexpl}`'
      type:  Preformatted
      visible: (findcut)
      clearWith:
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent


    - name:  medianTable
      title: '`Median Survival Table: Levels for ${contexpl}`'
      type:  Table
      rows: 0
      columns:
      # columns: &idcols
        - name: factor
          title: "Levels"
          # title: '`Factor - ${contexpl}`'
          type: text
        - name: records
          title: "Records"
          type: number
        # - name: n_max
        #   title: "n_max"
        #   type: number
        # - name: n_start
        #   title: "n_start"
        #   type: number
        - name: events
          title: "Events"
          type: integer
        - name: rmean
          title: "rmean"
          type: number
        - name: se_rmean
          title: "se_rmean"
          type: number
        - name: median
          title: "Median"
          type: number
        - name: x0_95lcl
          title: "Lower"
          superTitle: '95% Confidence Interval'
          type: number
        - name: x0_95ucl
          title: "Upper"
          superTitle: '95% Confidence Interval'
          type: number
      visible: (findcut)
      clearWith:
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent



    - name:  survTableSummary
      title: '`1, 3, 5-yr Survival Summary and Table  - ${contexpl}`'
      type:  Preformatted
      visible: (findcut)
      clearWith:
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent


    - name:  survTable
      title: '`1, 3, 5 year Survival - ${contexpl}`'
      type:  Table
      rows: 0
      columns:
      # columns: &idcols
        - name: strata
          title: "Levels"
          type: text
        - name: 'time'
          title: "time"
          type: integer
        - name: n.risk
          title: "Number at Risk"
          type: integer
        - name: n.event
          title: "Number of Events"
          type: integer
        - name: surv
          title: "Survival"
          type: number
          format: pc
        - name: lower
          title: "Lower"
          superTitle: '95% Confidence Interval'
          type: number
          format: pc
        - name: upper
          title: "Upper"
          superTitle: '95% Confidence Interval'
          type: number
          format: pc
      visible: (findcut)
      clearWith:
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name: plot2
      title: '`Cumulative Events  - ${contexpl} Grouped with New Cut-Off`'
      type: Image
      width:  600
      height: 450
      renderFun: .plot2
      visible: (findcut && ce)
      requiresData: true
      clearWith:
          - ce
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name: plot3
      title: '`Cumulative Hazard  - ${contexpl} Grouped with New Cut-Off`'
      type: Image
      width:  600
      height: 450
      renderFun: .plot3
      visible: (findcut && ch)
      requiresData: true
      clearWith:
          - ch
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name: plot6
      title: '`KMunicate-Style Plot  - ${contexpl} Grouped with New Cut-Off`'
      type: Image
      width:  600
      height: 450
      renderFun: .plot6
      visible: (findcut && kmunicate)
      requiresData: true
      clearWith:
          - kmunicate
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent
      refs:
          - KMunicate
          - KMunicate2


    - name: calculatedtime
      title: Add Calculated Time to Data
      type: Output
      varTitle: '`Calculated Time in Continious Survival Function - from ${ dxdate } to { fudate }`'
      varDescription: Calculated Time from given Dates in Continious Survival Function
      clearWith:
          - tint
          - dxdate
          - fudate
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name: outcomeredefined
      title: Add Redefined Outcome to Data
      type: Output
      varTitle: '`Redefined Outcome in Continious Survival Function - from ${ outcome } for analysis { analysistype }`'
      varDescription: Redefined Outcome from Outcome based on Analysis Type in Continious Survival Function
      clearWith:
          - outcome
          - analysistype
          - multievent
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent

    - name: calculatedcutoff
      title: Add Calculated Cut-off Group to Data
      type: Output
      varTitle: '`Calculated Cut-off Group - from ${ contexpl }`'
      varDescription: Calculated Cut-off Group from given Cut-off in Continious Survival Function
      clearWith:
          - outcome
          - analysistype
          - multievent
          - contexpl
          - findcut
          - sc
          - endplot
          - byplot
          - ci95
          - risktable
          - outcome
          - outcomeLevel
          - overalltime
          - findcut
          - contexpl
          - fudate
          - dxdate
          - tint
          - multievent




refs:
    - finalfit
    - survival
    - survminer
    - dichotomizing
    - survivaltutorial
    - survivalrwnahhas
    - ClinicoPathJamoviModule

...


File: jamovi\survivalcont.u.yaml
--------------------------------------------------
Content of jamovi\survivalcont.u.yaml:
title: Survival Analysis for Continuous Explanatory
name: survivalcont
jus: '3.0'
stage: 0
compilerMode: tame
children:
  - type: VariableSupplier
    persistentItems: false
    stretchFactor: 1
    children:
      - type: TargetLayoutBox
        label: Time Elapsed
        children:
          - type: VariablesListBox
            name: elapsedtime
            maxItemCount: 1
            isTarget: true
      - type: TargetLayoutBox
        label: Outcome
        children:
          - type: VariablesListBox
            name: outcome
            maxItemCount: 1
            isTarget: true
            fitToGrid: true
          - type: LevelSelector
            name: outcomeLevel
            enable: (outcome && !multievent)
      - type: TargetLayoutBox
        label: Continuous Explanatory Variable
        children:
          - type: VariablesListBox
            name: contexpl
            maxItemCount: 1
            isTarget: true
  - type: CollapseBox
    label: Finding Cut-off
    collapsed: true
    children:
      - type: Label
        label: Cut-off
        fitToGrid: true
        children:
          - type: CheckBox
            name: findcut
            enable: (contexpl)
          - type: Output
            name: calculatedcutoff
            enable: (findcut)


  - type: CollapseBox
    label: Advanced Elapsed Time Options
    collapsed: true
    stretchFactor: 1
    children:
      - type: Label
        label: Time Interval
        fitToGrid: true
        stretchFactor: 1
        children:
          - type: LayoutBox
            margin: large
            stretchFactor: 1
            children:
              - type: CheckBox
                name: tint
                fitToGrid: true
              - type: Label
                label: Date Variables
                fitToGrid: true
                stretchFactor: 1
                children:
                  - type: VariableSupplier
                    persistentItems: false
                    stretchFactor: 1
                    children:
                      - type: TargetLayoutBox
                        children:
                          - type: VariablesListBox
                            name: dxdate
                            maxItemCount: 1
                            isTarget: true
                            fitToGrid: true
                            stretchFactor: 1
                      - type: TargetLayoutBox
                        children:
                          - type: VariablesListBox
                            name: fudate
                            maxItemCount: 1
                            isTarget: true
                            fitToGrid: true
                            stretchFactor: 1
              - type: Label
                label: Time Type
                fitToGrid: true
                stretchFactor: 1
                children:
                  - type: LayoutBox
                    margin: large
                    fitToGrid: true
                    children:
                      - type: ComboBox
                        name: timetypedata
                        enable: (tint)
                      - type: ComboBox
                        name: timetypeoutput
                        enable: (tint)
      - type: Label
        label: Landmark Time
        fitToGrid: true
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: CheckBox
                name: uselandmark
                children:
                  - type: TextBox
                    name: landmark
                    format: number
                    enable: (uselandmark)
      - type: Label
        label: Calculated Time to Data 
        fitToGrid: true
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: Output
                name: calculatedtime
                enable: (tint)
  - type: CollapseBox
    label: Analysis with Multiple Outcomes
    collapsed: true
    children:
      - type: Label
        label: Multiple Event Levels
        fitToGrid: true
        children:
          - type: CheckBox
            name: multievent
            enable: (outcome)
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: LevelSelector
                name: dod
                enable: (outcome && multievent)
              - type: LevelSelector
                name: dooc
                enable: (outcome && multievent)
              - type: LevelSelector
                name: awd
                enable: (outcome && multievent)
              - type: LevelSelector
                name: awod
                enable: (outcome && multievent)
      - type: Label
        label: Analysis Type
        children:
          - type: ComboBox
            name: analysistype
            enable: (outcome && multievent)
      - type: Label
        label: Calculated Outcome to Data 
        fitToGrid: true
        children:
          - type: LayoutBox
            margin: large
            children:
              - type: Output
                name: outcomeredefined
                enable: (outcome && multievent)



  - type: CollapseBox
    label: Plots
    collapsed: true
    children:
      - type: Label
        label: Plots
        fitToGrid: true
        children:
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: CheckBox
                name: sc
                enable: (findcut)
              - type: CheckBox
                name: kmunicate
                enable: (findcut)
              - type: CheckBox
                name: ce
                enable: (findcut)
              - type: CheckBox
                name: ch
                enable: (findcut)

      - type: Label
        label: Plot Arguments
        children:
          - type: LayoutBox
            fitToGrid: true
            children:
              - type: TextBox
                name: endplot
                format: number
                enable: (findcut)
              - type: TextBox
                name: byplot
                enable: (findcut)
                format: number
              - type: TextBox
                name: ybegin_plot
                enable: (findcut)
                format: number
              - type: TextBox
                name: yend_plot
                format: number
                enable: (findcut)
              - type: CheckBox
                name: ci95
                enable: (findcut)
              - type: CheckBox
                name: risktable
                enable: (findcut)
              - type: CheckBox
                name: censored
                enable: (findcut)
              - type: ComboBox
                name: medianline
                enable: (findcut)




  - type: CollapseBox
    label: Survival Tables
    collapsed: true
    children:
      - type: Label
        label: Survival table
        children:
          - type: TextBox
            name: cutp
            enable: (findcut)
            format: string
            width: large



File: R\00jmv.R
--------------------------------------------------
Content of R\00jmv.R:

# This file is automatically generated, you probably don't want to edit this

.jmvrefs <- list(
    `emmeans`=list(
        `type`="software", 
        `author`="Lenth, R.", 
        `year`=2018, 
        `title`="emmeans: Estimated Marginal Means, aka Least-Squares Means", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=emmeans", 
        `url`="https://CRAN.R-project.org/package=emmeans"), 
    `afex`=list(
        `type`="software", 
        `author`="Singmann, H.", 
        `year`=2018, 
        `title`="afex: Analysis of Factorial Experiments", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=afex", 
        `url`="https://CRAN.R-project.org/package=afex"), 
    `R`=list(
        `type`="software", 
        `author`="R Core Team", 
        `year`=2018, 
        `title`="A Language and Envionment for Statistical Computing", 
        `publisher`="[Computer software]. Retrieved from https://CRAN.R-project.org/", 
        `url`="https://CRAN.R-project.org/"), 
    `BF`=list(
        `type`="software", 
        `author`="Morey, R. D., & Rouder, J. N.", 
        `year`=2018, 
        `title`="BayesFactor: Computation of Bayes Factors for Common Designs", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=BayesFactor", 
        `url`="https://CRAN.R-project.org/package=BayesFactor"), 
    `btt`=list(
        `type`="article", 
        `author`="Rouder, J. N., Speckman, P. L., Sun, D., Morey, R. D., & Iverson, G.", 
        `year`=2009, 
        `title`="Bayesian t tests for accepting and rejecting the null hypothesis", 
        `publisher`="Psychonomic Bulletin & Review", 
        `volume`=16, 
        `pages`="225-237"), 
    `car`=list(
        `type`="software", 
        `author`="Fox, J., & Weisberg, S.", 
        `year`=2018, 
        `title`="car: Companion to Applied Regression", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=car", 
        `url`="https://CRAN.R-project.org/package=car"), 
    `ggplot2`=list(
        `type`="software", 
        `author`="Wickham, H., Chang, W., Henry, L., Pedersen, T. L., Takahashi, K., Wilke, C., Woo, K., & RStudio", 
        `year`=2018, 
        `title`="ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ggplot2", 
        `url`="https://CRAN.R-project.org/package=ggplot2"), 
    `ggridges`=list(
        `type`="software", 
        `author`="Wilke, C., & RStudio", 
        `year`=2018, 
        `title`="ggridges: Ridgeline Plots in ggplot2", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ggridges", 
        `url`="https://CRAN.R-project.org/package=ggridges"), 
    `mvnormtest`=list(
        `type`="software", 
        `author`="Jarek, S.", 
        `year`=2012, 
        `title`="mvnormtest: Normality test for multivariate variables", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=mvnormtest", 
        `url`="https://CRAN.R-project.org/package=mvnormtest"), 
    `PMCMR`=list(
        `type`="software", 
        `author`="Pohlert, T.", 
        `year`=2018, 
        `title`="PMCMR: Calculate Pairwise Multiple Comparisons of Mean Rank Sums", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=PMCMR", 
        `url`="https://CRAN.R-project.org/package=PMCMR"), 
    `ROCR`=list(
        `type`="software", 
        `author`="Sing, T., Sander, O., Beerenwinkel, N., & Lengauer, T.", 
        `year`=2015, 
        `title`="ROCR: Visualizing the Performance of Scoring Classifiers", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ROCR", 
        `url`="https://CRAN.R-project.org/package=ROCR"), 
    `nnet`=list(
        `type`="software", 
        `author`="Ripley, B., Venables W.", 
        `year`=2016, 
        `title`="nnet: Feed-Forward Neural Networks and Multinomial Log-Linear Models", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=nnet", 
        `url`="https://CRAN.R-project.org/package=nnet"), 
    `MASS`=list(
        `type`="software", 
        `author`="Ripley, B., Venables W., Bates, D. M., Hornik, K., Gebhardt, A., & Firth, D.", 
        `year`=2018, 
        `title`="MASS: Support Functions and Datasets for Venables and Ripley's MASS", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=MASS", 
        `url`="https://CRAN.R-project.org/package=MASS"), 
    `vcd`=list(
        `type`="software", 
        `author`="Meyer, D., Zeileis, A., Hornik, K., Gerber, F., & Friendly, M.", 
        `year`=2017, 
        `title`="vcd: Visualizing Categorical Data", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=vcd", 
        `url`="https://CRAN.R-project.org/package=vcd"), 
    `vcdExtra`=list(
        `type`="software", 
        `author`="Friendly M., Turner, H., Zeileis, A., Murdoch, D., & Firth, D.", 
        `year`=2017, 
        `title`="vcdExtra: 'vcd' Extensions and Additions", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=vcdExtra", 
        `url`="https://CRAN.R-project.org/package=vcdExtra"), 
    `exact2x2`=list(
        `type`="software", 
        `author`="Fay, M. P., Hunsberger, S. A., Nason, M., & Gabriel, E.", 
        `year`=2018, 
        `title`="exact2x2: Exact Tests and Confidence Intervals for 2x2 Tables", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=exact2x2", 
        `url`="https://CRAN.R-project.org/package=exact2x2"), 
    `psych`=list(
        `type`="software", 
        `author`="Revelle, W.", 
        `year`=2019, 
        `title`="psych: Procedures for Psychological, Psychometric, and Personality Research", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=psych", 
        `url`="https://CRAN.R-project.org/package=psych"), 
    `lavaan`=list(
        `type`="software", 
        `author`="Rosseel, Y., et al.", 
        `year`=2018, 
        `title`="lavaan: Latent Variable Analysis", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=lavaan", 
        `url`="https://CRAN.R-project.org/package=lavaan"), 
    `semPlot`=list(
        `type`="software", 
        `author`="Epskamp, S.", 
        `year`=2017, 
        `title`="semPlot: Path Diagrams and Visual Analysis of Various SEM Packages' Output", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=semPlot", 
        `url`="https://CRAN.R-project.org/package=semPlot"), 
    `ggstatsplot`=list(
        `type`="software", 
        `author`="Patil, I.", 
        `year`=2018, 
        `title`="ggstatsplot: 'ggplot2' Based Plots with Statistical Details", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ggstatsplot", 
        `url`="https://CRAN.R-project.org/package=ggstatsplot", 
        `doi`="10.5281/zenodo.2074621"), 
    `ggstatsplot_article`=list(
        `type`="article", 
        `author`="Patil, I.", 
        `year`=2021, 
        `title`="Visualizations with statistical details: The 'ggstatsplot' approach.", 
        `publisher`="PsyArxiv", 
        `doi`="doi:10.31234/osf.io/p7mku"), 
    `report`=list(
        `type`="software", 
        `author`="Makowski, Dominique, L\u00FCdecke, Daniel", 
        `year`=2019, 
        `title`="The report package for R: Ensuring the use of best practices for results reporting", 
        `publisher`="[R package]. Retrieved from https://github.com/easystats/report", 
        `url`="https://github.com/easystats/report"), 
    `arsenal`=list(
        `type`="software", 
        `author`="Heinzen, E Sinnwell, J Atkinson, E Gunderson, T Dougherty, G", 
        `year`=2018, 
        `title`="arsenal: An Arsenal of 'R' Functions for Large-Scale Statistical Summaries", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=arsenal", 
        `url`="https://CRAN.R-project.org/package=arsenal"), 
    `tangram`=list(
        `type`="software", 
        `author`="Garbett, S.", 
        `year`=2018, 
        `title`="tangram: The Grammar of Tables", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=tangram", 
        `url`="https://CRAN.R-project.org/package=tangram"), 
    `irr`=list(
        `type`="software", 
        `author`="Matthias Gamer, Jim Lemon, Ian Fellows, Puspendra Singh", 
        `year`=2019, 
        `title`="Various Coefficients of Interrater Reliability and Agreement.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=irr", 
        `url`="https://CRAN.R-project.org/package=irr"), 
    `tableone`=list(
        `type`="software", 
        `author`="Kazuki, Y.", 
        `year`=2019, 
        `title`="tableone: Create 'Table 1' to Describe Baseline Characteristics", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=tableone", 
        `url`="https://CRAN.R-project.org/package=tableone"), 
    `janitor`=list(
        `type`="software", 
        `author`="Firke, S.", 
        `year`=2019, 
        `title`="janitor: Simple Tools for Examining and Cleaning Dirty Data.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=janitor", 
        `url`="https://CRAN.R-project.org/package=janitor"), 
    `finalfit`=list(
        `type`="software", 
        `author`="Ewen Harrison and Tom Drake and Riinu Ots", 
        `year`=2019, 
        `title`="finalfit: Quickly Create Elegant Regression Results Tables and Plots when Modelling", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=finalfit", 
        `url`="https://CRAN.R-project.org/package=finalfit"), 
    `caret`=list(
        `type`="software", 
        `author`="Max Kuhn", 
        `year`=2020, 
        `title`="caret: Classification and Regression Training", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=caret", 
        `url`="https://CRAN.R-project.org/package=caret"), 
    `psycho`=list(
        `type`="software", 
        `author`="Makowski, D.", 
        `year`=2018, 
        `title`="The Psycho Package: An Efficient and Publishing-Oriented Workflow for Psychological Science. Journal of Open Source Software, 3(22), 470.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=psycho.R", 
        `url`="https://CRAN.R-project.org/package=psycho.R"), 
    `survival`=list(
        `type`="software", 
        `author`="Terry M Therneau, Thomas Lumley", 
        `year`=2019, 
        `title`="survival: Survival Analysis", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=survival", 
        `url`="https://CRAN.R-project.org/package=survival"), 
    `survminer`=list(
        `type`="software", 
        `author`="Alboukadel Kassambara and Marcin Kosinski and Przemyslaw Biecek", 
        `year`=2019, 
        `title`="survminer: Drawing Survival Curves using 'ggplot2'", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=survminer", 
        `url`="https://CRAN.R-project.org/package=survminer"), 
    `ggalluvial`=list(
        `type`="software", 
        `author`="Jason Cory Brunson", 
        `year`=2019, 
        `title`="ggalluvial: Alluvial Plots in 'ggplot2'.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=ggalluvial", 
        `url`="https://CRAN.R-project.org/package=ggalluvial"), 
    `explore`=list(
        `type`="software", 
        `author`="Roland Krasser", 
        `year`=2020, 
        `title`="explore: Simplifies Exploratory Data Analysis.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=explore", 
        `url`="https://CRAN.R-project.org/package=explore"), 
    `FFTrees`=list(
        `type`="software", 
        `author`="Nathaniel Phillips, Hansjoerg Neth, Jan Woike and Wolfgang Gaissmaer", 
        `year`=2019, 
        `title`="FFTrees: Generate, Visualise, and Evaluate Fast-and-Frugal Decision Trees", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=FFTrees", 
        `url`="https://CRAN.R-project.org/package=FFTrees"), 
    `rpart`=list(
        `type`="software", 
        `author`="Terry Therneau and Beth Atkinson", 
        `year`=2019, 
        `title`="rpart: Recursive Partitioning and Regression Trees.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=rpart", 
        `url`="https://CRAN.R-project.org/package=rpart"), 
    `rpart.plot`=list(
        `type`="software", 
        `author`="Stephen Milborrow", 
        `year`=2019, 
        `title`="rpart.plot: Plot 'rpart' Models: An Enhanced Version of 'plot.rpart'", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=rpart.plot", 
        `url`="https://CRAN.R-project.org/package=rpart.plot"), 
    `gtsummary`=list(
        `type`="software", 
        `author`="Daniel D. Sjoberg, Margie Hannum, Karissa Whiting and Emily C. Zabor", 
        `year`=2020, 
        `title`="gtsummary: Presentation-Ready Data Summary and Analytic Result Tables", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=gtsummary", 
        `url`="https://CRAN.R-project.org/package=gtsummary"), 
    `rmngb`=list(
        `type`="software", 
        `author`="Antoine Filipovic Pierucci", 
        `year`=2014, 
        `title`="rmngb: Miscellaneous Collection of Functions for Medical Data Analysis", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=rmngb", 
        `url`="https://CRAN.R-project.org/package=rmngb"), 
    `RVAideMemoire`=list(
        `type`="software", 
        `author`="Maxime Herv\u00E9", 
        `year`=2020, 
        `title`="RVAideMemoire: Testing and Plotting Procedures for Biostatistics", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=RVAideMemoire", 
        `url`="https://CRAN.R-project.org/package=RVAideMemoire"), 
    `chisq.posthoc.test`=list(
        `type`="software", 
        `author`="Daniel Ebbert", 
        `year`=2019, 
        `title`="chisq.posthoc.test: A Post Hoc Analysis for Pearson's Chi-Squared Test for Count Data", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=chisq.posthoc.test", 
        `url`="https://CRAN.R-project.org/package=chisq.posthoc.test"), 
    `easyalluvial`=list(
        `type`="software", 
        `author`="Bjoern Koneswarakantha", 
        `year`=2019, 
        `title`="easyalluvial: Generate Alluvial Plots with a Single Line of Code.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=easyalluvial", 
        `url`="https://CRAN.R-project.org/package=easyalluvial"), 
    `parcats`=list(
        `type`="software", 
        `author`="Bjoern Koneswarakantha", 
        `year`=2019, 
        `title`="parcats: Interactive Parallel Categories Diagrams for 'easyalluvial'", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=parcats", 
        `url`="https://CRAN.R-project.org/package=parcats"), 
    `plotROC`=list(
        `type`="software", 
        `author`="Michael C. Sachs", 
        `year`=2017, 
        `title`="plotROC: A Tool for Plotting ROC Curves.Journal of Statistical Software, Code Snippets, 79(2), 1-19. doi:10.18637/jss.v079.c02", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=plotROC", 
        `url`="https://CRAN.R-project.org/package=plotROC"), 
    `RGraphGallery`=list(
        `type`="website", 
        `author`="Holtz Yan", 
        `year`=2020, 
        `title`="The R Graph Gallery", 
        `publisher`="A website that displays hundreds of R charts https://www.r-graph-gallery.com", 
        `url`="https://github.com/holtzy/R-graph-gallery"), 
    `hrbrthemes`=list(
        `type`="software", 
        `author`="Bob Rudis", 
        `year`=2020, 
        `title`="hrbrthemes: Additional Themes, Theme Components and Utilities for 'ggplot2'.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=hrbrthemes", 
        `url`="https://CRAN.R-project.org/package=hrbrthemes"), 
    `retractcheck`=list(
        `type`="software", 
        `author`="Chris Hartgerink and Frederik Aust", 
        `year`=2019, 
        `title`="retractcheck: Retraction Scanner", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=retractcheck", 
        `url`="https://CRAN.R-project.org/package=retractcheck"), 
    `RefManageR`=list(
        `type`="software", 
        `author`="McLean MW", 
        `year`=2017, 
        `title`="RefManageR: Import and Manage BibTeX and BibLaTeX References in R. The Journal of Open Source Software.", 
        `doi`="10.21105/joss.00338", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=RefManageR", 
        `url`="https://CRAN.R-project.org/package=RefManageR"), 
    `rcrossref`=list(
        `type`="software", 
        `author`="Scott Chamberlain and Hao Zhu and Najko Jahn and Carl Boettiger and Karthik Ram", 
        `year`=2020, 
        `title`="rcrossref: Client for Various 'CrossRef' 'APIs'", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=rcrossref", 
        `url`="https://CRAN.R-project.org/package=rcrossref"), 
    `epiR`=list(
        `type`="software", 
        `author`="Mark Stevenson with contributions from Telmo Nunes, Cord Heuer, Jonathon Marshall, Javier Sanchez, Ron Thornton, Jeno Reiczigel, Jim Robison-Cox, Paola Sebastiani, Peter Solymos, Kazuki Yoshida, Geoff Jones, Sarah Pirikahu, Simon Firestone, Ryan Kyle, Johann Popp, Mathew Jay and Charles Reynard.", 
        `year`=2020, 
        `title`="epiR: Tools for the Analysis of Epidemiological Data.", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=epiR", 
        `url`="https://CRAN.R-project.org/package=epiR"), 
    `KMunicate`=list(
        `type`="software", 
        `author`="Alessandro Gasparini", 
        `year`=2020, 
        `title`="KMunicate: KMunicate-Style Kaplan\u2013Meier Plots", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=KMunicate", 
        `url`="https://CRAN.R-project.org/package=KMunicate"), 
    `KMunicate2`=list(
        `type`="article", 
        `author`="Morris TP, Jarvis CI, Cragg W, et al", 
        `title`="Proposals on Kaplan\u2013Meier plots in medical research and a survey of stakeholder views: KMunicate", 
        `year`=2019, 
        `publisher`="BMJ Open 2019;9:e030215.", 
        `doi`="10.1136/bmjopen-2019-030215", 
        `url`="https://bmjopen.bmj.com/content/9/9/e030215"), 
    `Fagan`=list(
        `type`="software", 
        `author`="Adam Chekroud", 
        `title`="nomogrammer: Fagan's nomograms with ggplot2", 
        `publisher`="GitHub", 
        `year`=2020, 
        `url`="https://github.com/achekroud/nomogrammer"), 
    `Fagan2`=list(
        `type`="article", 
        `author`=NULL, 
        `title`="StATS: What is a Fagan nomogram?", 
        `publisher`="website", 
        `year`=2020, 
        `url`="http://www.pmean.com/definitions/fagan.htm"), 
    `benford.analysis`=list(
        `type`="software", 
        `author`="Carlos Cinelli", 
        `year`=2020, 
        `title`="benford.analysis: Benford Analysis for Data Validation and Forensic Analytics", 
        `publisher`="[R package]. Retrieved from http://github.com/carloscinelli/benford.analysis", 
        `url`="http://github.com/carloscinelli/benford.analysis"), 
    `benford.nedir`=list(
        `type`="website", 
        `author`="\u00DCmit I\u015Flak", 
        `year`=2021, 
        `title`="Benford (ilk basamak) kanunu nedir?", 
        `publisher`="sarkac.org", 
        `url`="https://sarkac.org/2021/09/benford-ilk-basamak-kanunu-nedir/"), 
    `vtree`=list(
        `type`="software", 
        `author`="Nick Barrowman", 
        `year`=2020, 
        `title`="vtree: Display Information About Nested Subsets of a Data Frame", 
        `publisher`="[R package]. Retrieved from https://CRAN.R-project.org/package=vtree", 
        `url`="https://CRAN.R-project.org/package=vtree"), 
    `PathologyKappa`=list(
        `type`="article", 
        `title`="Pathologists should probably forget about kappa. Percent agreement, diagnostic specificity and related metrics provide more clinically applicable measures of interobserver variability", 
        `year`=2020, 
        `author`=NULL, 
        `publisher`="Annals of Diagnostic Pathology", 
        `volume`=47, 
        `url`="https://www.sciencedirect.com/science/article/abs/pii/S1092913420301040"), 
    `DiagnosticTests`=list(
        `type`="article", 
        `title`="The Interpretation of SARS-CoV-2 Diagnostic Tests", 
        `year`=2020, 
        `author`="Stites EC, Wilen CB.", 
        `publisher`="Med (N Y).", 
        `doi`="10.1016/j.medj.2020.08.001", 
        `url`="https://www.cell.com/med/fulltext/S2666-6340(20)30016-7"), 
    `dichotomizing`=list(
        `type`="article", 
        `title`="Dichotomizing continuous predictors in multiple regression: a bad idea.", 
        `year`=2006, 
        `author`="Royston, P., Altman, D.G. and Sauerbrei, W.", 
        `publisher`="Statist. Med.", 
        `volume`=25, 
        `pages`="127-141", 
        `doi`="10.1002/sim.2331", 
        `url`="https://onlinelibrary.wiley.com/doi/abs/10.1002/sim.2331"), 
    `bbccookbook`=list(
        `type`="article", 
        `title`="BBC Visual and Data Journalism cookbook for R graphics", 
        `year`=2019, 
        `author`="BBC data team", 
        `url`="https://bbc.github.io/rcookbook/"), 
    `bbplot`=list(
        `type`="software", 
        `author`="Nassos Stylianou and Will william.dahlgreen@bbc.co.uk Dahlgreen and Robert robert.cuffe@bbc.co.uk Cuffe and Tom Calver and Ransome Mpini", 
        `year`=2020, 
        `title`="bbplot: MAKING GGPLOT GRAPHICS IN BBC NEWS STYLE", 
        `publisher`="[R package]. Retrieved from https://github.com/bbc/bbplot", 
        `url`="https://github.com/bbc/bbplot"), 
    `venn`=list(
        `type`="software", 
        `author`="Linlin Yan", 
        `year`=2020, 
        `title`="Venn Diagram by ggplot2, with really easy-to-use API", 
        `publisher`="[R package]. Retrieved from https://github.com/yanlinlin82/ggvenn", 
        `url`="https://github.com/yanlinlin82/ggvenn"), 
    `padjust`=list(
        `type`="website", 
        `year`=2020, 
        `title`="p.adjust {stats} Adjust P-values for Multiple Comparisons", 
        `publisher`="[R package]. Retrieved from https://stat.ethz.ch/R-manual/R-devel/library/stats/html/p.adjust.html", 
        `url`="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/p.adjust.html"), 
    `multivariable`=list(
        `type`="article", 
        `title`="Multivariate or Multivariable Regression?", 
        `year`=2013, 
        `author`="Hidalgo B, Goodman M.", 
        `publisher`="Am J Public Health.", 
        `volume`=103, 
        `pages`="39-40", 
        `doi`="10.2105/AJPH.2012.300897", 
        `url`="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3518362/"), 
    `ClinicoPathJamoviModule`=list(
        `type`="software", 
        `author`="Serdar Balci", 
        `year`=2022, 
        `title`="ClinicoPath jamovi Module doi:10.5281/zenodo.3997188", 
        `publisher`="[R package]. Retrieved from https://github.com/sbalci/ClinicoPathJamoviModule", 
        `doi`="10.17605/OSF.IO/9SZUD", 
        `url`="https://www.serdarbalci.com/ClinicoPathJamoviModule/"), 
    `iwillsurvive`=list(
        `type`="software", 
        `author`="Nathaniel Phillips", 
        `year`=2021, 
        `title`="iwillsurvive", 
        `publisher`="[R package]. Retrieved from https://github.com/ndphillips/iwillsurvive", 
        `url`="https://github.com/ndphillips/iwillsurvive"), 
    `sensspecwiki`=list(
        `type`="webpage", 
        `author`="Wikipedia contributors", 
        `title`="Sensitivity and specificity --- Wikipedia, The Free Encyclopedia", 
        `year`="2022", 
        `url`="https://en.wikipedia.org/w/index.php?title=Sensitivity_and_specificity&oldid=1077556477", 
        `note`="[Online; accessed 3-April-2022]"), 
    `kappaSize`=list(
        `type`="software", 
        `author`="Michael A Rotondi", 
        `year`=2022, 
        `title`="kappaSize: Sample Size Estimation Functions for Studies of Interobserver Agreement", 
        `publisher`="[R package]. Retrieved from https://cran.r-project.org/web/packages/kappaSize/", 
        `url`="https://cran.r-project.org/web/packages/kappaSize/"), 
    `gtExtras`=list(
        `type`="software", 
        `author`="Thomas Mock, Daniel D. Sjoberg", 
        `year`=2023, 
        `title`="gtExtras", 
        `publisher`="[R package]. Retrieved from https://cran.r-project.org/web/packages/gtExtras/", 
        `url`="https://cran.r-project.org/web/packages/gtExtras/"), 
    `survivaltutorial`=list(
        `type`="article", 
        `author`="Emily C. Zabor", 
        `year`=2022, 
        `title`="Survival analysis in R: A detailed tutorial on conducting survival analyses in R, including an introduction to the basics of survival analysis, landmark analyses and time-dependent covariates, competing risks, and a selection of advanced topics.", 
        `publisher`="[GitHub Repository]. Retrieved from https://github.com/zabore/tutorials", 
        `url`="https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html"), 
    `survivalrviews`=list(
        `type`="article", 
        `author`="Joseph Rickert", 
        `year`=2017, 
        `title`="Survival Analysis with R", 
        `publisher`="R Views, An R community blog edited by RStudio", 
        `url`="https://rviews.rstudio.com/2017/09/25/survival-analysis-with-r/"), 
    `appliedsurvivalanalysisR`=list(
        `type`="book", 
        `author`="Dirk F. Moore", 
        `year`=2016, 
        `title`="Applied Survival Analysis Using R", 
        `publisher`="Springer Cham", 
        `doi`="10.1007/978-3-319-31245-3", 
        `url`="https://link.springer.com/book/10.1007/978-3-319-31245-3"), 
    `survivalrwnahhas`=list(
        `type`="book chapter", 
        `author`="Ramzi W. Nahhas", 
        `year`=2023, 
        `title`="Chapter 7 Survival Analysis. Introduction to Regression Methods for Public Health Using R.", 
        `url`="https://bookdown.org/rwnahhas/RMPH/survival.html"))


File: R\jsurvival-data.R
--------------------------------------------------
Content of R\jsurvival-data.R:
#' @title histopathology
#'
#' @description Fake histopathology research data.
#' @usage data(histopathology)
#' @format A data frame
"histopathology"


File: R\jsurvival-package.R
--------------------------------------------------
Content of R\jsurvival-package.R:
#' \code{jsurvival}
#'
#' @title jsurvival: Analysis for jsurvivalological Research
#'
#' @description `jsurvival` jsurvival help researchers to generate natural
#' language summaries of their dataset, generate cross tables with statistical
#' tests, and survival analysis with survival tables, survival plots,
#' and natural language summaries.
#'
# @details The main functions are-
# \itemize{
#   \item \code{\link[tableone]{tableone}} function to produce Table One.
#  }
#'
#' For more documentation, see the
#' \href{https://sbalci.github.io/ClinicoPathJamoviModule/}{Website}.
#'
#' @docType package
#' @aliases jsurvival jsurvival-package
#' @name jsurvival-package
"_PACKAGE"


File: R\multisurvival.b.R
--------------------------------------------------
Content of R\multisurvival.b.R:
#' @title Multivariable Survival Analysis
#' @importFrom R6 R6Class
#' @import jmvcore
#'

multisurvivalClass <- if (requireNamespace('jmvcore'))
  R6::R6Class(
    "multisurvivalClass",
    inherit = multisurvivalBase,
    private = list(
      # init ----
      .init = function() {
        explanatory_len <- length(self$options$explanatory)
        contexpl_len <- length(self$options$contexpl)

        if (explanatory_len > 0 || contexpl_len > 0) {
          self$results$plot8$setSize((explanatory_len + contexpl_len) * 400,
                                     (explanatory_len + contexpl_len) * 300)
        } else {
          self$results$plot8$setVisible(FALSE)
        }




      }

      # getData ----
      ,
      .getData = function() {
        # Check if data exists and has content
        if (is.null(self$data) || nrow(self$data) == 0) {
          stop('Data contains no (complete) rows')
        }

        # Get the data
        mydata <- self$data


        # Check if data has names
        if (is.null(names(mydata))) {
          stop('Data must have column names')
        }

        # Add row names if missing
        if (is.null(rownames(mydata))) {
          mydata$row_names <- seq_len(nrow(mydata))
        } else {
          mydata$row_names <- rownames(mydata)
        }

        # Get original names
        original_names <- names(mydata)

        # Check if original names exist
        if (length(original_names) == 0) {
          stop('Data must have column names')
        }

        # Create labels vector
        labels <- stats::setNames(original_names, original_names)

        # Clean names safely
        mydata_cleaned <- try({
          janitor::clean_names(mydata)
        }, silent = TRUE)

        # mydata <- mydata %>% janitor::clean_names()


        if (inherits(mydata_cleaned, "try-error")) {
          stop('Error cleaning variable names. Please check column names.')
        }


        # Create corrected labels
        corrected_labels <- stats::setNames(original_names, names(mydata_cleaned))

        # Apply labels
        mydata_labelled <- try({
          labelled::set_variable_labels(.data = mydata_cleaned, .labels = corrected_labels)
        }, silent = TRUE)

        # mydata <- labelled::set_variable_labels(
        #     .data = mydata,
        #     .labels = corrected_labels
        # )


        if (inherits(mydata_labelled, "try-error")) {
          stop('Error setting variable labels')
        }


        # Get all labels
        all_labels <- labelled::var_label(mydata_labelled)

        # all_labels <- labelled::var_label(mydata)


        # Get variable names from labels
        mytime <- try({
          names(all_labels)[all_labels == self$options$elapsedtime]
        }, silent = TRUE)

        # mytime <-
        #     names(all_labels)[all_labels == self$options$elapsedtime]

        myoutcome <- try({
          names(all_labels)[all_labels == self$options$outcome]
        }, silent = TRUE)

        # myoutcome <-
        #     names(all_labels)[all_labels == self$options$outcome]


        mydxdate <- try({
          names(all_labels)[all_labels == self$options$dxdate]
        }, silent = TRUE)

        # mydxdate <-
        #     names(all_labels)[all_labels == self$options$dxdate]


        myfudate <- try({
          names(all_labels)[all_labels == self$options$fudate]
        }, silent = TRUE)

        # myfudate <-
        #     names(all_labels)[all_labels == self$options$fudate]



        labels_explanatory <- self$options$explanatory

        myexplanatory <-
          names(all_labels)[match(labels_explanatory, all_labels)]

        labels_contexpl <- self$options$contexpl

        mycontexpl <-
          names(all_labels)[match(labels_contexpl, all_labels)]


        # Get adjexplanatory only if it exists and ac option is TRUE
        adjexplanatory <- NULL
        if (!is.null(self$options$adjexplanatory) &&
            self$options$ac) {
          adjexplanatory <- names(all_labels)[all_labels == self$options$adjexplanatory]
        }


        mystratvar_labelled <- NULL


        if (self$options$use_stratify && !is.null(self$options$stratvar)) {
        # Add this to get stratification variables
        labels_stratvar <- self$options$stratvar
        mystratvar_labelled <- names(all_labels)[match(labels_stratvar, all_labels)]
        }


        # Check if required variables were found
        if (length(mytime) == 0 &&
            !is.null(self$options$elapsedtime)) {
          stop('Could not find elapsed time variable')
        }
        if (length(myoutcome) == 0 &&
            !is.null(self$options$outcome)) {
          stop('Could not find outcome variable')
        }

        # Return results
        return(
          list(
            "mydata_labelled" = mydata_labelled,
            "mytime_labelled" = mytime,
            "myoutcome_labelled" = myoutcome,
            "mydxdate_labelled" = mydxdate,
            "myfudate_labelled" = myfudate,
            "mycontexpl_labelled" = mycontexpl,
            "myexplanatory_labelled" = myexplanatory,
            "adjexplanatory_labelled" = adjexplanatory,
            "mystratvar_labelled" = mystratvar_labelled


          )
        )



      }

      # todo ----
      ,
      .todo = function() {
        # todo ----

        todo <- glue::glue(
          "
                    <br>Welcome to ClinicoPath
                    <br><br>
                        This tool will help you perform a multivariable survival analysis.
                    <br><br>
                        Explanatory variables can be categorical (ordinal or nominal) or continuous.
                    <br><br>
                    Select outcome level from Outcome variable.
                    <br><br>
                    Outcome Level: if patient is dead or event (recurrence) occured. You may also use advanced outcome options depending on your analysis type.
                    <br><br>
                        Survival time should be numeric, continuous, and in months. You may also use dates to calculate survival time in advanced elapsed time options.
                    <br><br>


        Stratification Variables: Use these when the proportional hazards assumption
        is violated for certain variables. The model will create separate baseline
        hazard functions for each level of the stratification variables, but won't
        estimate their direct effects.
        <br><br>
        Consider using stratification when:
        <br>- A variable fails the proportional hazards test
        <br>- You need to control for a variable's effect but don't need to
        estimate its hazard ratio
        <br>- There are natural differences in baseline risk across groups

<br><br>
                        This function uses finalfit, survival, survminer and ggstatsplot packages. Please cite jamovi and the packages as given below.
                    <br><br>
                    "
        )
        # https://finalfit.org/articles/all_tables_examples.html#cox-proportional-hazards-model-survival-time-to-event


        html <- self$results$todo
        html$setContent(todo)
        return()

      }





      # Define Survival Time ----
      ,
      .definemytime = function() {
        ## Read Labelled Data ----

        labelled_data <- private$.getData()

        mydata <- labelled_data$mydata_labelled
        mytime_labelled <- labelled_data$mytime_labelled
        mydxdate_labelled <- labelled_data$mydxdate_labelled
        myfudate_labelled <- labelled_data$myfudate_labelled

        tint <- self$options$tint


        if (!tint) {
          ### Precalculated Time ----

          mydata[["mytime"]] <-
            jmvcore::toNumeric(mydata[[mytime_labelled]])


        } else if (tint) {
          ### Time Interval ----

          dxdate <- mydxdate_labelled
          fudate <- myfudate_labelled
          timetypedata <- self$options$timetypedata


          # # Define a mapping from timetypedata to lubridate functions
          # lubridate_functions <- list(
          #     ymdhms = lubridate::ymd_hms,
          #     ymd = lubridate::ymd,
          #     ydm = lubridate::ydm,
          #     mdy = lubridate::mdy,
          #     myd = lubridate::myd,
          #     dmy = lubridate::dmy,
          #     dym = lubridate::dym
          # )
          # # Apply the appropriate lubridate function based on timetypedata
          # if (timetypedata %in% names(lubridate_functions)) {
          #     func <- lubridate_functions[[timetypedata]]
          #     mydata[["start"]] <- func(mydata[[dxdate]])
          #     mydata[["end"]] <- func(mydata[[fudate]])
          # }


          if (timetypedata == "ymdhms") {
            mydata[["start"]] <- lubridate::ymd_hms(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::ymd_hms(mydata[[fudate]])
          }
          if (timetypedata == "ymd") {
            mydata[["start"]] <- lubridate::ymd(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::ymd(mydata[[fudate]])
          }
          if (timetypedata == "ydm") {
            mydata[["start"]] <- lubridate::ydm(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::ydm(mydata[[fudate]])
          }
          if (timetypedata == "mdy") {
            mydata[["start"]] <- lubridate::mdy(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::mdy(mydata[[fudate]])
          }
          if (timetypedata == "myd") {
            mydata[["start"]] <- lubridate::myd(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::myd(mydata[[fudate]])
          }
          if (timetypedata == "dmy") {
            mydata[["start"]] <- lubridate::dmy(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::dmy(mydata[[fudate]])
          }
          if (timetypedata == "dym") {
            mydata[["start"]] <- lubridate::dym(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::dym(mydata[[fudate]])
          }


          if (sum(!is.na(mydata[["start"]])) == 0 ||
              sum(!is.na(mydata[["end"]])) == 0)  {
            stop(
              paste0(
                "Time difference cannot be calculated. Make sure that time type in variables are correct. Currently it is: ",
                self$options$timetypedata
              )
            )
          }

          timetypeoutput <-
            jmvcore::constructFormula(terms = self$options$timetypeoutput)


          mydata <- mydata %>%
            dplyr::mutate(interval = lubridate::interval(start, end))



          mydata <- mydata %>%
            dplyr::mutate(mytime = lubridate::time_length(interval, timetypeoutput))

        }


        df_time <- mydata %>% jmvcore::select(c("row_names", "mytime"))

        return(df_time)


      }

      # Define Outcome ----
      ,
      .definemyoutcome = function() {
        labelled_data <- private$.getData()

        mydata <- labelled_data$mydata_labelled
        myoutcome_labelled <- labelled_data$myoutcome_labelled


        contin <- c("integer", "numeric", "double")

        outcomeLevel <- self$options$outcomeLevel
        multievent <- self$options$multievent

        outcome1 <- mydata[[myoutcome_labelled]]

        if (!multievent) {
          if (inherits(outcome1, contin)) {
            if (!((length(unique(outcome1[!is.na(outcome1)])) == 2) &&
                  (sum(unique(outcome1[!is.na(outcome1)])) == 1))) {
              stop(
                'When using continuous variable as an outcome, it must only contain 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0.'
              )

            }

            mydata[["myoutcome"]] <- mydata[[myoutcome_labelled]]
            # mydata[[self$options$outcome]]

          } else if (inherits(outcome1, "factor")) {
            mydata[["myoutcome"]] <-
              ifelse(test = outcome1 == outcomeLevel,
                     yes = 1,
                     no = 0)

          } else {
            stop(
              'When using continuous variable as an outcome, it must only contain 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0. If you are using a factor as an outcome, please check the levels and content.'
            )

          }

        } else if (multievent) {
          analysistype <- self$options$analysistype

          dod <- self$options$dod
          dooc <- self$options$dooc
          awd <- self$options$awd
          awod <- self$options$awod

          if (analysistype == 'overall') {
            # Overall ----
            # (Alive) <=> (Dead of Disease & Dead of Other Causes)


            mydata[["myoutcome"]] <- NA_integer_

            mydata[["myoutcome"]][outcome1 == awd] <- 0
            mydata[["myoutcome"]][outcome1 == awod] <- 0
            mydata[["myoutcome"]][outcome1 == dod] <- 1
            mydata[["myoutcome"]][outcome1 == dooc] <- 1



          } else if (analysistype == 'cause') {
            # Cause Specific ----
            # (Alive & Dead of Other Causes) <=> (Dead of Disease)


            mydata[["myoutcome"]] <- NA_integer_

            mydata[["myoutcome"]][outcome1 == awd] <- 0
            mydata[["myoutcome"]][outcome1 == awod] <- 0
            mydata[["myoutcome"]][outcome1 == dod] <- 1
            mydata[["myoutcome"]][outcome1 == dooc] <- 0

          } else if (analysistype == 'compete') {
            # Competing Risks ----
            # Alive <=> Dead of Disease accounting for Dead of Other Causes

            # https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#part_3:_competing_risks


            mydata[["myoutcome"]] <- NA_integer_

            mydata[["myoutcome"]][outcome1 == awd] <- 0
            mydata[["myoutcome"]][outcome1 == awod] <- 0
            mydata[["myoutcome"]][outcome1 == dod] <- 1
            mydata[["myoutcome"]][outcome1 == dooc] <- 2

          }

        }

        df_outcome <- mydata %>% jmvcore::select(c("row_names", "myoutcome"))

        return(df_outcome)

      }


      # Define Factor ----
      ,

      .definemyfactor = function() {
        labelled_data <- private$.getData()

        mydata_labelled <- labelled_data$mydata_labelled
        myexplanatory_labelled <- labelled_data$myexplanatory_labelled
        mycontexpl_labelled <- labelled_data$mycontexpl_labelled
        adjexplanatory_labelled <- labelled_data$adjexplanatory_labelled

        mydata <- mydata_labelled

        df_factor <- mydata %>%
          jmvcore::select(unique(
            c(
              "row_names",
              myexplanatory_labelled,
              adjexplanatory_labelled,
              mycontexpl_labelled
            )
          ))

        return(df_factor)

      }

      # Clean Data ----
      ,
      .cleandata = function() {
        ## Common Definitions ----

        contin <- c("integer", "numeric", "double")

        ## Read Data ----

        labelled_data <- private$.getData()

        mydata_labelled        <- labelled_data$mydata_labelled
        mytime_labelled        <- labelled_data$mytime_labelled
        myoutcome_labelled     <- labelled_data$myoutcome_labelled
        mydxdate_labelled      <- labelled_data$mydxdate_labelled
        myfudate_labelled      <- labelled_data$myfudate_labelled
        myexplanatory_labelled <- labelled_data$myexplanatory_labelled
        mycontexpl_labelled    <- labelled_data$mycontexpl_labelled
        adjexplanatory_labelled <- labelled_data$adjexplanatory_labelled


        time <- private$.definemytime()
        outcome <- private$.definemyoutcome()
        factor <- private$.definemyfactor()

        ## Clean Data ----
        cleanData <- dplyr::left_join(time, outcome, by = "row_names") %>%
          dplyr::left_join(factor, by = "row_names")

        ## Landmark ----

        # https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#landmark_method

        if (self$options$uselandmark) {
          landmark <- jmvcore::toNumeric(self$options$landmark)

          cleanData <- cleanData %>%
            dplyr::filter(mytime >= landmark) %>%
            dplyr::mutate(mytime = mytime - landmark)
        }

        ## Names cleanData ----

        if (self$options$tint) {
          name1time <- "CalculatedTime"
        }

        if (!self$options$tint &&
            !is.null(self$options$elapsedtime)) {
          name1time <- mytime_labelled
        }

        name2outcome <- myoutcome_labelled

        if (self$options$multievent) {
          name2outcome <- "CalculatedOutcome"
        }

        name3expl <- NULL

        if (!is.null(self$options$explanatory)) {
          name3expl <- myexplanatory_labelled
        }


        name3contexpl <- NULL

        if (!is.null(self$options$contexpl)) {
          name3contexpl <- mycontexpl_labelled
        }

        # Add adjexplanatory name if present
        adjexplanatory_name <- NULL
        if (!is.null(adjexplanatory_labelled)) {
          adjexplanatory_name <- adjexplanatory_labelled
        }


        # naOmit ----

        cleanData <- jmvcore::naOmit(cleanData)




        ## Add Calculated Time to Data ----

        if (self$options$tint &&
            self$options$calculatedtime &&
            self$results$calculatedtime$isNotFilled()) {
          self$results$calculatedtime$setRowNums(cleanData$row_names)
          self$results$calculatedtime$setValues(cleanData$mytime)
        }




        ## Add Redefined Outcome to Data ----

        if (self$options$multievent  &&
            self$options$outcomeredefined &&
            self$results$outcomeredefined$isNotFilled()) {
          self$results$outcomeredefined$setRowNums(cleanData$row_names)
          self$results$outcomeredefined$setValues(cleanData$myoutcome)
        }


        # self$results$mydataview$setContent(
        #   list(
        #     "name1time" = name1time,
        #     "name2outcome" = name2outcome,
        #     "name3contexpl" = name3contexpl,
        #     "name3expl" = name3expl,
        #     "adjexplanatory_name" = adjexplanatory_name,
        #
        #     "cleanData" = cleanData,
        #     "mytime_labelled" = mytime_labelled,
        #     "myoutcome_labelled" = myoutcome_labelled,
        #     "mydxdate_labelled" = mydxdate_labelled,
        #     "myfudate_labelled" = myfudate_labelled,
        #     "myexplanatory_labelled" = myexplanatory_labelled,
        #     "mycontexpl_labelled" = mycontexpl_labelled,
        #     "adjexplanatory_labelled" = adjexplanatory_labelled
        #
        #   )
        # )



        # Return Data ----

        return(
          list(
            "name1time" = name1time,
            "name2outcome" = name2outcome,
            "name3contexpl" = name3contexpl,
            "name3expl" = name3expl,
            "adjexplanatory_name" = adjexplanatory_name,

            "cleanData" = cleanData,
            "mytime_labelled" = mytime_labelled,
            "myoutcome_labelled" = myoutcome_labelled,
            "mydxdate_labelled" = mydxdate_labelled,
            "myfudate_labelled" = myfudate_labelled,
            "myexplanatory_labelled" = myexplanatory_labelled,
            "mycontexpl_labelled" = mycontexpl_labelled,
            "adjexplanatory_labelled" = adjexplanatory_labelled

          )
        )

      }



      # run  ----
      ,
      .run = function() {
        # Errors, Warnings ----

        ## No variable todo ----

        ## Define subconditions ----

        subcondition1a <- !is.null(self$options$outcome)
        subcondition1b1 <- self$options$multievent
        subcondition1b2 <- !is.null(self$options$dod)
        subcondition1b3 <- !is.null(self$options$dooc)
        # subcondition1b4 <- !is.null(self$options$awd)
        # subcondition1b5 <- !is.null(self$options$awod)
        subcondition2a <- !is.null(self$options$elapsedtime)
        subcondition2b1 <- self$options$tint
        subcondition2b2 <- !is.null(self$options$dxdate)
        subcondition2b3 <- !is.null(self$options$fudate)
        condition3a <- !is.null(self$options$contexpl)
        condition3b <- !is.null(self$options$explanatory)

        condition1 <- subcondition1a &&
          !subcondition1b1 ||
          subcondition1b1 &&
          subcondition1b2 ||
          subcondition1b1 && subcondition1b3

        condition2 <- subcondition2b1 &&
          subcondition2b2 &&
          subcondition2b3 ||
          subcondition2a &&
          !subcondition2b1 &&
          !subcondition2b2 && !subcondition2b3


        condition3 <- condition3a || condition3b

        not_continue_analysis <- !(condition1 &&
                                     condition2 &&
                                     condition3)


        if (not_continue_analysis) {
          private$.todo()
          self$results$text$setVisible(FALSE)
          self$results$text2$setVisible(FALSE)
          self$results$plot$setVisible(FALSE)
          self$results$plot3$setVisible(FALSE)
          self$results$plot8$setVisible(FALSE)
          self$results$todo$setVisible(TRUE)
          return()
        } else {
          self$results$todo$setVisible(FALSE)
        }


        ## Stop if Empty Data ----

        if (nrow(self$data) == 0)
          stop('Data contains no (complete) rows')

        ## mydata ----

        cleaneddata <- private$.cleandata()

        name1time <- cleaneddata$name1time
        name2outcome <- cleaneddata$name2outcome
        name3contexpl <- cleaneddata$name3contexpl
        name3expl <- cleaneddata$name3expl
        adjexplanatory_name <- cleaneddata$adjexplanatory_name

        mydata <- cleanData <- cleaneddata$cleanData

        mytime_labelled <- cleaneddata$mytime_labelled
        myoutcome_labelled <- cleaneddata$myoutcome_labelled
        mydxdate_labelled <- cleaneddata$mydxdate_labelled
        myfudate_labelled <- cleaneddata$myfudate_labelled
        myexplanatory_labelled <- cleaneddata$myexplanatory_labelled
        mycontexpl_labelled <- cleaneddata$mycontexpl_labelled
        adjexplanatory_labelled <- cleaneddata$adjexplanatory_labelled



        ## run Cox function ----

        private$.final_fit()


        ## generate cox model ----

        if (self$options$ph_cox ||
            self$options$calculateRiskScore ||
            self$options$ac) {
          cox_model <- private$.cox_model()
        }

        ## run coxph ----

        if (self$options$ph_cox) {
          private$.cox_ph(cox_model)
        }


        ## Calculate Risk Score ----

        if (self$options$calculateRiskScore) {
          riskData <- private$.calculateRiskScore(cox_model, mydata)

        }


        ## Compare models ----

        # if (self$options$compare_models) {
        #   private$.compare_models()
        # }


        ## Adjusted survival ----

        # if (self$options$ac) {
        #   private$.calculateAdjustedStats()
        #   }



        ## run Cox function .fitModelWithSelection ----

        # if (self$options$use_modelSelection) {
        #   private$.final_fit2()
        # }



        # Prepare Data For Plots ----

        image <- self$results$plot
        image$setState(cleaneddata)

        image3 <- self$results$plot3
        image3$setState(cleaneddata)


        # image4 <- self$results$plot4
        # image4$setState(cleaneddata)

        imageKM <- self$results$plotKM
        imageKM$setState(cleaneddata)

        # image7 <- self$results$plot7
        # image7$setState(cleaneddata)


        image_plot_adj <- self$results$plot_adj
        image_plot_adj$setState(cleaneddata)




        if (self$options$calculateRiskScore) {
          image_riskGroupPlot <- self$results$riskGroupPlot
          image_riskGroupPlot$setState(riskData)

        }

        # View plot data ----
        #         if (self$options$ac) {
        # self$results$mydataview_plot_adj$setContent(
        #   list(
        #     cox_model = cox_model,
        #     mydata = mydata,
        #     adjexplanatory_name = adjexplanatory_labelled
        #   ))
        #         }




      }



      # finalfit  ----
      ,
      .final_fit = function() {
        cleaneddata <- private$.cleandata()

        name1time <- cleaneddata$name1time
        name2outcome <- cleaneddata$name2outcome
        name3contexpl <- cleaneddata$name3contexpl
        name3expl <- cleaneddata$name3expl
        adjexplanatory_name <- cleaneddata$adjexplanatory_name

        mydata <- cleanData <- cleaneddata$cleanData

        mytime_labelled <- cleaneddata$mytime_labelled
        myoutcome_labelled <- cleaneddata$myoutcome_labelled
        mydxdate_labelled <- cleaneddata$mydxdate_labelled
        myfudate_labelled <- cleaneddata$myfudate_labelled
        myexplanatory_labelled <- cleaneddata$myexplanatory_labelled
        mycontexpl_labelled <- cleaneddata$mycontexpl_labelled
        adjexplanatory_labelled <- cleaneddata$adjexplanatory_labelled


        ## prepare formula ----

        myexplanatory <- NULL

        if (!is.null(self$options$explanatory)) {
          myexplanatory <- as.vector(myexplanatory_labelled)
        }

        mycontexpl <- NULL
        if (!is.null(self$options$contexpl)) {
          mycontexpl <- as.vector(mycontexpl_labelled)
        }


        formula2 <- c(myexplanatory, mycontexpl)

        myformula <-
          paste("Surv( mytime, myoutcome ) ~ ", paste(formula2, collapse = " + "))

        myformula <- as.formula(myformula)

        # self$results$mydataview$setContent(
        #     list(
        #         mydata = head(mydata, n = 30),
        #         myformula = myformula,
        #         myexplanatory = myexplanatory,
        #         mycontexpl = mycontexpl,
        #         formula2 = formula2
        #     )
        # )




        ## finalfit Multivariable table ----

        finalfit::finalfit(.data = mydata,
                           formula = myformula,
                           # dependent = myformula,
                           # explanatory = formula2,

                           metrics = TRUE) -> tMultivariable


        text2 <- glue::glue("
                                    <br>
                                    <b>Model Metrics:</b>
                                    ",
                            unlist(tMultivariable[[2]]),
                            "
                                    <br>
                                    ")

        if (self$options$uselandmark) {
          landmark <- jmvcore::toNumeric(self$options$landmark)

          text2 <- glue::glue(text2,
                              "Landmark time used as: ",
                              landmark,
                              " ",
                              self$options$timetypeoutput,
                              ".")
        }

        self$results$text2$setContent(text2)



        results1 <- knitr::kable(
          tMultivariable[[1]],
          row.names = FALSE,
          align = c('l', 'l', 'r', 'r', 'r', 'r'),
          format = "html"
        )

        self$results$text$setContent(results1)

      }

      # cox model  ----
      ,
      .cox_model = function() {
        cleaneddata <- private$.cleandata()

        name1time <- cleaneddata$name1time
        name2outcome <- cleaneddata$name2outcome
        name3contexpl <- cleaneddata$name3contexpl
        name3expl <- cleaneddata$name3expl
        adjexplanatory_name <- cleaneddata$adjexplanatory_name

        mydata <- cleanData <- cleaneddata$cleanData

        mytime_labelled <- cleaneddata$mytime_labelled
        myoutcome_labelled <- cleaneddata$myoutcome_labelled
        mydxdate_labelled <- cleaneddata$mydxdate_labelled
        myfudate_labelled <- cleaneddata$myfudate_labelled
        myexplanatory_labelled <- cleaneddata$myexplanatory_labelled
        mycontexpl_labelled <- cleaneddata$mycontexpl_labelled
        adjexplanatory_labelled <- cleaneddata$adjexplanatory_labelled



        # Add stratification variables
        mystratvar <- NULL

        if (self$options$use_stratify && !is.null(self$options$stratvar)) {
          mystratvar <- as.vector(cleaneddata$mystratvar_labelled)
          # Create strata terms
          mystratvar <- paste0("strata(", mystratvar, ")")
        }



        myexplanatory <- NULL
        if (!is.null(self$options$explanatory)) {
          myexplanatory <- as.vector(myexplanatory_labelled)
        }

        mycontexpl <- NULL
        if (!is.null(self$options$contexpl)) {
          mycontexpl <- as.vector(mycontexpl_labelled)
        }


        formula2 <- c(myexplanatory, mycontexpl, mystratvar)



        LHT <- "survival::Surv(mytime, myoutcome)"

        RHT <- formula2

        RHT <- paste(RHT, collapse = " + ")

        coxformula <- paste0(LHT, " ~ ", RHT)

        coxformula <- as.formula(coxformula)

        cox_model <- survival::coxph(coxformula, data = mydata)


        return(cox_model)

      }


      # coxph Proportional Hazards Assumption  ----
      ,
      .cox_ph = function(cox_model) {
        # cleaneddata <- private$.cleandata()
        #
        # name1time <- cleaneddata$name1time
        # name2outcome <- cleaneddata$name2outcome
        # name3contexpl <- cleaneddata$name3contexpl
        # name3expl <- cleaneddata$name3expl
        # adjexplanatory_name <- cleaneddata$adjexplanatory_name
        #
        # mydata <- cleanData <- cleaneddata$cleanData
        #
        # mytime_labelled <- cleaneddata$mytime_labelled
        # myoutcome_labelled <- cleaneddata$myoutcome_labelled
        # mydxdate_labelled <- cleaneddata$mydxdate_labelled
        # myfudate_labelled <- cleaneddata$myfudate_labelled
        # myexplanatory_labelled <- cleaneddata$myexplanatory_labelled
        # mycontexpl_labelled <- cleaneddata$mycontexpl_labelled
        # adjexplanatory_labelled <- cleaneddata$adjexplanatory_labelled
        #
        #
        # cox_model <- private$.cox_model()

        zph <- survival::cox.zph(cox_model)




        # Add suggestions for stratification
        significant_violations <- which(zph$table[,"p"] < 0.05)
        if (length(significant_violations) > 0) {
          violation_vars <- rownames(zph$table)[significant_violations]
          suggestion <- glue::glue(
            "<br><br>Note: The proportional hazards assumption appears to be
            violated for: {paste(violation_vars, collapse=', ')}.
            Consider using these as stratification variables instead of
            covariates."
          )

          self$results$cox_ph$setContent(
            paste(print(zph), suggestion)
          )
        }



        # Display test results
        self$results$cox_ph$setContent(print(zph))






        # Only create plots if there are variables to plot
        if (!is.null(zph$y)) {
          # Pass zph object to plot function
          image8 <- self$results$plot8
          image8$setState(zph)
        } else {
          # If no variables to plot, hide the plot
          self$results$plot8$setVisible(FALSE)
        }

      }




      # hr_plot ----
      ,
      .plot = function(image, ggtheme, theme, ...) {
        if (!self$options$hr) {
          return()
        }

        if (!(self$options$sty == "t1")) {
          return()
        }

        plotData <- image$state

        if (is.null(plotData)) {
          return()
        }

        name1time <- plotData$name1time
        name2outcome <- plotData$name2outcome
        name3contexpl <- plotData$name3contexpl
        name3expl <- plotData$name3expl

        mydata <- cleanData <- plotData$cleanData

        mytime_labelled <- plotData$mytime_labelled
        myoutcome_labelled <- plotData$myoutcome_labelled
        mydxdate_labelled <- plotData$mydxdate_labelled
        myfudate_labelled <- plotData$myfudate_labelled
        myexplanatory_labelled <- plotData$myexplanatory_labelled
        mycontexpl_labelled <- plotData$mycontexpl_labelled


        ### prepare formula ----

        myexplanatory <- NULL
        if (!is.null(self$options$explanatory)) {
          myexplanatory <- as.vector(myexplanatory_labelled)
        }

        mycontexpl <- NULL
        if (!is.null(self$options$contexpl)) {
          mycontexpl <- as.vector(mycontexpl_labelled)
        }

        formula2 <- c(myexplanatory, mycontexpl)

        myformula <-
          paste0('Surv( mytime, myoutcome )')


        # hr_plot ----
        # https://finalfit.org/reference/hr_plot.html

        plot <-
          finalfit::hr_plot(
            .data = mydata,
            dependent = myformula,
            explanatory = formula2,
            dependent_label = "Survival",
            table_text_size = 4,
            title_text_size = 14,
            plot_opts = list(
              ggplot2::xlab("HR, 95% CI"),
              ggplot2::theme(axis.title =
                               ggplot2::element_text(size = 12))
            )
          )


        # print plot ----

        print(plot)
        TRUE

      }






      # Forest plot ----
      ,
      .plot3 = function(image3, ggtheme, theme, ...) {
        if (!self$options$hr) {
          return()
        }

        if (!(self$options$sty == "t3")) {
          return()
        }

        plotData <- image3$state

        if (is.null(plotData)) {
          return()
        }

        name1time <- plotData$name1time
        name2outcome <- plotData$name2outcome
        name3contexpl <- plotData$name3contexpl
        name3expl <- plotData$name3expl

        mydata <- cleanData <- plotData$cleanData

        mytime_labelled <- plotData$mytime_labelled
        myoutcome_labelled <- plotData$myoutcome_labelled
        mydxdate_labelled <- plotData$mydxdate_labelled
        myfudate_labelled <- plotData$myfudate_labelled
        myexplanatory_labelled <- plotData$myexplanatory_labelled
        mycontexpl_labelled <- plotData$mycontexpl_labelled


        ### prepare formula ----

        myexplanatory <- NULL
        if (!is.null(self$options$explanatory)) {
          myexplanatory <- as.vector(myexplanatory_labelled)
        }

        mycontexpl <- NULL
        if (!is.null(self$options$contexpl)) {
          mycontexpl <- as.vector(mycontexpl_labelled)
        }

        formula2 <- c(myexplanatory, mycontexpl)

        myformula <-
          paste("survival::Surv(mytime, myoutcome) ~ ",
                paste(formula2, collapse = " + "))



        myformula <- as.formula(myformula)

        mod <-
          survival::coxph(formula = myformula, data = mydata)


        # ggforest ----

        plot3 <- survminer::ggforest(model = mod, data = mydata)


        # print plot ----

        print(plot3)
        TRUE

      }


      # cox.zph plot8 ----
      ,
      .plot8 = function(image8, ggtheme, theme, ...) {
        if (!self$options$ph_cox)
          return()

        zph <- image8$state

        if (is.null(zph)) {
          return()
        }

        # Check if there are variables to plot
        if (is.null(zph$y)) {
          return()
        }

        # Create plot using survminer
        plot8 <- survminer::ggcoxzph(zph)

        print(plot8)
        TRUE

      }


      # Kaplan-Meier ----
      ,


      .plotKM = function(imageKM, ggtheme, theme, ...) {
        # Check conditions and show message if not met
        if (length(self$options$explanatory) > 2) {
          text_warning <- "Kaplan-Meier plot requires 2 categorical explanatory variables. You have selected more than 2 variables."
          grid::grid.newpage()
          grid::grid.text(text_warning, 0.5, 0.5)
          return(TRUE)
        }

        if (!is.null(self$options$contexpl)) {
          text_warning <- "Kaplan-Meier plot cannot be created with continuous explanatory variables. Please select only categorical variables."
          grid::grid.newpage()
          grid::grid.text(text_warning, 0.5, 0.5)
          return(TRUE)
        }

        if (length(self$options$explanatory) < 2) {
          text_warning <- "Please select 2 categorical explanatory variables to create the Kaplan-Meier plot."
          grid::grid.newpage()
          grid::grid.text(text_warning, 0.5, 0.5)
          return(TRUE)
        }


        # if (length(self$options$explanatory) > 2)
        #     stop("Kaplan-Meier function allows maximum of 2 explanatory variables")
        #
        # if (!is.null(self$options$contexpl))
        #     stop("Kaplan-Meier function does not use continuous explanatory variables.")





        plotData <- imageKM$state

        if (is.null(plotData)) {
          return()
        }

        name1time <- plotData$name1time
        name2outcome <- plotData$name2outcome
        name3contexpl <- plotData$name3contexpl
        name3expl <- plotData$name3expl

        mydata <- cleanData <- plotData$cleanData

        mytime_labelled <- plotData$mytime_labelled
        myoutcome_labelled <- plotData$myoutcome_labelled
        mydxdate_labelled <- plotData$mydxdate_labelled
        myfudate_labelled <- plotData$myfudate_labelled
        myexplanatory_labelled <- plotData$myexplanatory_labelled
        mycontexpl_labelled <- plotData$mycontexpl_labelled


        ### prepare formula ----

        myexplanatory <- NULL
        if (!is.null(self$options$explanatory)) {
          myexplanatory <- as.vector(myexplanatory_labelled)
        }


        # myformula <-
        #     paste("survival::Surv(mytime, myoutcome) ~ ",
        #           paste(myexplanatory, collapse = " + "))
        #
        #
        # myformula <- as.formula(myformula)
        #


        thefactor <- jmvcore::constructFormula(terms = myexplanatory)


        title2 <- as.character(thefactor)

        plotKM <- mydata %>%
          finalfit::surv_plot(
            .data = .,
            dependent = 'survival::Surv(mytime, myoutcome)',
            explanatory = thefactor,
            xlab = paste0('Time (', self$options$timetypeoutput, ')'),
            pval = self$options$pplot,
            pval.method	= self$options$pplot,
            legend = 'none',
            break.time.by = self$options$byplot,
            xlim = c(0, self$options$endplot),
            title = paste0("Survival curves for ", title2),
            subtitle = "Based on Kaplan-Meier estimates",
            risk.table = self$options$risktable,
            conf.int = self$options$ci95,
            censor = self$options$censored,
            surv.median.line = self$options$medianline

          )

        # plot <- plot + ggtheme

        print(plotKM)
        TRUE



      }












      ,
      # Risk Score Methods ----

      ## Calculate Risk Score ----

      .calculateRiskScore = function(cox_model, mydata) {
        # Calculate risk scores
        risk_scores <- predict(cox_model, type = "risk")

        # Add risk scores to data
        mydata$risk_score <- risk_scores

        # Create risk groups using quantiles
        mydata$risk_group <- cut(
          mydata$risk_score,
          breaks = quantile(mydata$risk_score, probs = seq(0, 1, by = 0.25)),
          labels = c(
            "Low Risk",
            "Intermediate-Low Risk",
            "Intermediate-High Risk",
            "High Risk"
          ),
          include.lowest = TRUE
        )


        ### Add risk scores to output if requested ----
        if (self$options$addRiskScore &&
            self$results$addRiskScore$isNotFilled()) {
          self$results$addRiskScore$setRowNums(mydata$row_names)
          self$results$addRiskScore$setValues(mydata$risk_score)
        }


        ### Add risk group to output if requested ----
        if (self$options$addRiskGroup &&
            self$results$addRiskGroup$isNotFilled()) {
          self$results$addRiskGroup$setRowNums(mydata$row_names)
          self$results$addRiskGroup$setValues(mydata$risk_group)
        }






        # Calculate summary statistics
        risk_summary <- data.frame(
          group = levels(mydata$risk_group),
          n_patients = as.numeric(table(mydata$risk_group)),
          events = tapply(mydata$myoutcome, mydata$risk_group, sum),
          median_score = tapply(mydata$risk_score, mydata$risk_group, median)
        )

        risk_summary$percent <- (risk_summary$n_patients / sum(risk_summary$n_patients)) * 100

        # Fill risk score table
        riskScoreTable <- self$results$riskScoreTable

        for (i in seq_len(nrow(risk_summary))) {
          riskScoreTable$addRow(
            rowKey = i,
            values = list(
              group = risk_summary$group[i],
              n_patients = risk_summary$n_patients[i],
              percent = risk_summary$percent[i],
              median_score = risk_summary$median_score[i],
              events = risk_summary$events[i]
            )
          )
        }

        # Create metrics summary
        c_index <- survival::concordance(cox_model)$concordance

        metrics_html <- glue::glue(
          "
        <br>
        <b>Risk Score Model Performance:</b><br>
        Harrell's C-index: {format(c_index, digits=3)}<br>
        <br>
        Number of patients in risk groups:<br>
        Low Risk: {risk_summary$n_patients[1]} ({format(risk_summary$percent[1], digits=1)}%)<br>
        Intermediate-Low: {risk_summary$n_patients[2]} ({format(risk_summary$percent[2], digits=1)}%)<br>
        Intermediate-High: {risk_summary$n_patients[3]} ({format(risk_summary$percent[3], digits=1)}%)<br>
        High Risk: {risk_summary$n_patients[4]} ({format(risk_summary$percent[4], digits=1)}%)<br>
    "
        )

        self$results$riskScoreMetrics$setContent(metrics_html)

        return(mydata)
      }

      ## Plot Risk Groups ----
      ,
      .plotRiskGroups = function(image_riskGroupPlot, ggtheme, theme, ...) {
        # Check if risk score calculation is enabled
        if (!self$options$calculateRiskScore ||
            !self$options$plotRiskGroups) {
          return()
        }

        # Get data from image state
        riskData <- image_riskGroupPlot$state
        if (is.null(riskData)) {
          return()
        }

        # Keep only needed columns
        plotData <- data.frame(
          time = riskData$mytime,
          status = riskData$myoutcome,
          group = riskData$risk_group
        )

        # Create survival object and fit
        fit <- survival::survfit(survival::Surv(time, status) ~ group, data = plotData)

        # Create plot
        plot <- survminer::ggsurvplot(
          fit = fit,
          data = plotData,
          risk.table.height = 0.3,
          risk.table.y.text.col = TRUE,
          risk.table.y.text = FALSE,
          ncensor.plot = TRUE,
          ncensor.plot.height = 0.25,
          xlab = paste0("Time (", self$options$timetypeoutput, ")"),
          ylab = "Survival probability",

          pval = self$options$pplot,
          pval.method	= self$options$pplot,
          break.time.by = self$options$byplot,
          xlim = c(0, self$options$endplot),
          risk.table = self$options$risktable,
          conf.int = self$options$ci95,
          censor = self$options$censored,




          title = "Survival by Risk Group",
          subtitle = "Based on Cox model risk score quartiles",
          legend.title = "Risk Group",
          palette = "Set2",
          ggtheme = ggplot2::theme_bw() +
            ggplot2::theme(
              plot.title = ggplot2::element_text(size = 14, face = "bold"),
              plot.subtitle = ggplot2::element_text(size = 12),
              axis.title = ggplot2::element_text(size = 12),
              axis.text = ggplot2::element_text(size = 10),
              legend.text = ggplot2::element_text(size = 10)
            )
        )

        print(plot)
        TRUE
      }






      # ,
      # Compare Models ----
    #   .compare_models = function() {
    #     # Get clean data
    #     cleaneddata <- private$.cleandata()
    #     mydata <- cleaneddata$cleanData
    #
    #     # Get full model variables
    #     full_explanatory <- NULL
    #     if (!is.null(self$options$explanatory)) {
    #       full_explanatory <- as.vector(cleaneddata$myexplanatory_labelled)
    #     }
    #
    #     full_contexpl <- NULL
    #     if (!is.null(self$options$contexpl)) {
    #       full_contexpl <- as.vector(cleaneddata$mycontexpl_labelled)
    #     }
    #
    #     # Get reduced model variables
    #     reduced_explanatory <- NULL
    #     if (!is.null(self$options$reduced_explanatory)) {
    #       reduced_explanatory <- names(labelled::var_label(mydata))[match(self$options$reduced_explanatory,
    #                                                                       labelled::var_label(mydata))]
    #     }
    #
    #     # Create formulas
    #     full_formula <- c(full_explanatory, full_contexpl)
    #
    #     # Run finalfit with model comparison
    #     comparison <- finalfit::finalfit(
    #       .data = mydata,
    #       dependent = 'survival::Surv(mytime, myoutcome)',
    #       explanatory = full_formula,
    #       explanatory_multi = reduced_explanatory,
    #       keep_models = TRUE
    #     )
    #
    #     # Create comparison table
    #     html_comparison <- knitr::kable(comparison[[1]], format = 'html', caption = "Full vs Reduced Model Comparison")
    #
    #     # Add metrics
    #     metrics_html <- glue::glue(
    #       "
    #     <br>
    #     <b>Model Comparison Metrics:</b><br>
    #     Full model AIC: {comparison[[2]]$AIC.full}<br>
    #     Reduced model AIC: {comparison[[2]]$AIC.reduced}<br>
    #     Likelihood ratio test p-value: {comparison[[2]]$lrtest.pvalue}
    # "
    #     )
    #
    #     # Set results
    #     self$results$model_comparison$setContent(html_comparison)
    #     self$results$reduced_model_metrics$setContent(metrics_html)
    #   }



      # Adjusted ----


      ,
    ## calculate Adjusted Stats ----
    .calculateAdjustedStats = function() {
      # Skip if adjusted curves not requested
      if (!self$options$ac) return(NULL)

      # Get cleaned data and check requirements
      cleaneddata <- private$.cleandata()
      if (is.null(cleaneddata)) return(NULL)

      data <- cleaneddata$cleanData
      adj_var <- cleaneddata$adjexplanatory_name

      # if (is.null(adj_var)) {
      #   stop('Please select a variable for adjusted curves')
      # }

      todo <- 'Please select a variable for adjusted curves'

      html <- self$results$todo
      html$setContent(todo)
      return()


      # Get baseline Cox model
      cox_model <- private$.cox_model()

      # Get unique levels and validate
      levels <- sort(unique(data[[adj_var]]))
      # if (length(levels) < 2) {
      #   stop("Adjustment variable must have at least 2 levels")
      # }
      todo <- 'Adjustment variable must have at least 2 levels'

      html <- self$results$todo
      html$setContent(todo)
      return()

      # Get timepoints for summaries
      timepoints <- if (self$options$ac_summary) {
        tryCatch({
          pts <- as.numeric(trimws(unlist(strsplit(self$options$ac_timepoints, ","))))
          pts <- sort(unique(pts[!is.na(pts)]))
          if (length(pts) == 0) c(12, 36, 60) else pts
        }, error = function(e) c(12, 36, 60))
      } else {
        NULL
      }

      # Calculate adjusted curves for each level
      results <- list()
      summary_rows <- list()

      for (level in levels) {
        tryCatch({
          # Create prediction data with mean/mode values for covariates
          pred_df <- data.frame(
            mytime = sort(unique(c(timepoints, data$mytime)))
          )

          # Add averaged covariates
          for (var in names(data)) {
            if (var != "mytime" && var != adj_var && var != "row_names") {
              if (is.numeric(data[[var]])) {
                pred_df[[var]] <- mean(data[[var]], na.rm = TRUE)
              } else if (is.factor(data[[var]])) {
                pred_df[[var]] <- names(which.max(table(data[[var]])))
              }
            }
          }
          pred_df[[adj_var]] <- level

          # Calculate adjusted survival
          pred_surv <- survival::survfit(cox_model, newdata = pred_df)

          # Store curve data
          if (!is.null(pred_surv)) {
            level_stats <- data.frame(
              time = pred_surv$time,
              survival = pred_surv$surv,
              std.err = pred_surv$std.err,
              lower = pred_surv$lower,
              upper = pred_surv$upper,
              n.risk = pred_surv$n.risk
            )

            results[[as.character(level)]] <- list(
              full_curve = level_stats
            )

            # Calculate summary statistics at specified timepoints
            if (!is.null(timepoints)) {
              for (t in timepoints) {
                idx <- which.min(abs(level_stats$time - t))
                if (length(idx) > 0) {
                  summary_row <- list(
                    Level = as.character(level),
                    Timepoint = t,
                    Survival = level_stats$survival[idx],
                    SE = level_stats$std.err[idx],
                    CI_Lower = level_stats$lower[idx],
                    CI_Upper = level_stats$upper[idx],
                    N_at_Risk = level_stats$n.risk[idx]
                  )
                  if (!any(sapply(summary_row, is.null)) &&
                      !any(sapply(summary_row, is.na))) {
                    summary_rows[[length(summary_rows) + 1]] <- summary_row
                  }
                }
              }
            }
          }
        }, error = function(e) {
          warning(paste("Error processing level", level, ":", e$message))
        })
      }

      # Add metadata
      attr(results, "timepoints") <- timepoints
      attr(results, "levels") <- levels
      attr(results, "variable") <- adj_var
      attr(results, "method") <- self$options$ac_method

      # Generate summary table
      if (length(summary_rows) > 0) {
        # Sort by level and timepoint
        sorted_indices <- order(
          sapply(summary_rows, function(x) x$Level),
          sapply(summary_rows, function(x) x$Timepoint)
        )
        summary_rows <- summary_rows[sorted_indices]

        # Add rows to table
        for (i in seq_along(summary_rows)) {
          row <- summary_rows[[i]]
          self$results$adjustedSummaryTable$addRow(
            rowKey = i,
            values = list(
              Level = row$Level,
              Timepoint = row$Timepoint,
              Survival = round(row$Survival, 3),
              SE = round(row$SE, 3),
              CI_Lower = round(row$CI_Lower, 3),
              CI_Upper = round(row$CI_Upper, 3)
            )
          )
        }
      }

      # Run additional analyses
      if (self$options$ac_summary) {
        private$.adjustedSurvTable(results, cox_model)
        private$.adjustedMedianSurv(results, cox_model)
        private$.adjustedCox(results, cox_model)
      }

      if (self$options$ac_compare) {
        private$.adjustedPairwise(results, cox_model)
      }

      return(results)
    }



      ,
    ## Adjusted Survival Table ----
    .adjustedSurvTable = function(results, cox_model) {
      # Get data components
      mytime <- results$name1time
      myoutcome <- results$name2outcome
      adj_var <- results$adjexplanatory_name
      mydata <- results$cleanData

      # Input validation
      if (is.null(mydata) || is.null(cox_model)) {
        return(NULL)
      }

      # Get timepoints
      timepoints <- tryCatch({
        pts <- as.numeric(trimws(unlist(strsplit(self$options$cutp, ","))))
        pts <- sort(unique(pts[!is.na(pts)]))
        if (length(pts) == 0) c(12, 36, 60) else pts
      }, error = function(e) c(12, 36, 60))

      # Get levels
      levels <- sort(unique(mydata[[adj_var]]))

      # Create base prediction data
      pred_base <- list()
      for (var in names(mydata)) {
        if (var != "mytime" && var != adj_var && var != "row_names" && var != myoutcome) {
          if (is.numeric(mydata[[var]])) {
            pred_base[[var]] <- mean(mydata[[var]], na.rm = TRUE)
          } else if (is.factor(mydata[[var]])) {
            pred_base[[var]] <- names(which.max(table(mydata[[var]])))
          }
        }
      }

      # Calculate survival for each level
      all_results <- list()

      for (level in levels) {
        # Create prediction data
        n_times <- length(timepoints)
        pred_data <- data.frame(
          mytime = timepoints
        )

        # Add mean covariates
        for (var in names(pred_base)) {
          pred_data[[var]] <- rep(pred_base[[var]], n_times)
        }

        # Add level
        pred_data[[adj_var]] <- rep(level, n_times)

        # Calculate survival
        surv_fit <- survival::survfit(cox_model, newdata = pred_data)
        surv_summ <- summary(surv_fit, times = timepoints)

        # Store results
        for (i in seq_along(timepoints)) {
          if (i <= length(surv_summ$time)) {
            all_results[[length(all_results) + 1]] <- list(
              Level = level,
              Time = timepoints[i],
              "Number at Risk" = surv_summ$n.risk[i],
              Events = surv_summ$n.event[i],
              "Adjusted Survival" = scales::percent(surv_summ$surv[i], accuracy = 0.1),
              "95% CI Lower" = scales::percent(surv_summ$lower[i], accuracy = 0.1),
              "95% CI Upper" = scales::percent(surv_summ$upper[i], accuracy = 0.1)
            )
          }
        }
      }

      # Add results to table
      if (length(all_results) > 0) {
        # Clear existing rows
        self$results$adjustedSurvTable$setRows(NULL)

        # Add new rows
        for (i in seq_along(all_results)) {
          row <- all_results[[i]]
          self$results$adjustedSurvTable$addRow(
            rowKey = i,
            values = row
          )
        }

        # Generate natural language interpretations
        summaries <- sapply(all_results, function(row) {
          glue::glue(
            "For {row$Level} at {row$Time} months, adjusted survival is {row$`Adjusted Survival`} ",
            "[{row$`95% CI Lower`}-{row$`95% CI Upper`}, 95% CI]. ",
            "At this timepoint, {row$`Number at Risk`} subjects were at risk ",
            "and {row$Events} events had occurred. ",
            "These estimates account for the average values of covariates."
          )
        })

        self$results$adjustedSurvTableSummary$setContent(summaries)
      }

      return(all_results)
    }



      #
      # .calculateAdjustedStats = function() {
      #   if (!self$options$ac) return(NULL)
      #
      #   # Get data and fit model
      #   cleaneddata <- private$.cleandata()
      #   if (is.null(cleaneddata)) return(NULL)
      #
      #   adj_var <- cleaneddata$adjexplanatory_name
      #   if (is.null(adj_var)) {
      #     stop('Please select a variable for adjusted curves')
      #   }
      #
      #   # Fit Cox model
      #   cox_model <- private$.fitCoxModel(cleaneddata)
      #
      #   # Calculate survival tables and summaries
      #   surv_results <- private$.adjustedSurvTable(cleaneddata, cox_model)
      #   median_results <- private$.adjustedMedianSurv(cleaneddata, cox_model)
      #   cox_results <- private$.adjustedCox(cleaneddata, cox_model)
      #
      #   if (self$options$ac_compare) {
      #     pairwise_results <- private$.adjustedPairwise(cleaneddata, cox_model)
      #   }
      #
      #   return(list(
      #     surv = surv_results,
      #     median = median_results,
      #     cox = cox_results
      #   ))
      # }
      #






      # mydataview_calculateAdjustedStats <- self$results$mydataview_calculateAdjustedStats
      # mydataview_calculateAdjustedStats$setContent(
      #   list(
      #     results = results,
      #     summary_rows = summary_rows
      #   )
      # )

      ,
    ## Adjusted Survival Plot ----
      .plot_adj = function(image_plot_adj, ggtheme, theme, ...) {

        if (!self$options$ac) return()

        plotData <- image_plot_adj$state

        if (is.null(plotData)) {
          return()
        }

        name1time <- plotData$name1time
        name2outcome <- plotData$name2outcome
        name3contexpl <- plotData$name3contexpl
        name3expl <- plotData$name3expl
        adjexplanatory_name <- plotData$adjexplanatory_name

        mydata <- cleanData <- plotData$cleanData

        mytime_labelled <- plotData$mytime_labelled
        myoutcome_labelled <- plotData$myoutcome_labelled
        mydxdate_labelled <- plotData$mydxdate_labelled
        myfudate_labelled <- plotData$myfudate_labelled
        myexplanatory_labelled <- plotData$myexplanatory_labelled
        mycontexpl_labelled <- plotData$mycontexpl_labelled
        adjexplanatory_labelled <- plotData$adjexplanatory_labelled


        if (is.null(plotData$adjexplanatory_name)) {
          text_warning <- "Please select a variable for adjusted curves."
          grid::grid.newpage()
          grid::grid.text(text_warning, 0.5, 0.5)
          return(TRUE)
        }








        ### prepare formula ----

        myexplanatory <- NULL
        if (!is.null(self$options$explanatory)) {
          myexplanatory <- as.vector(myexplanatory_labelled)
        }

        mycontexpl <- NULL
        if (!is.null(self$options$contexpl)) {
          mycontexpl <- as.vector(mycontexpl_labelled)
        }

        formula2 <- c(myexplanatory, mycontexpl)

        myformula <-
          paste("survival::Surv(mytime, myoutcome) ~ ",
                paste(formula2, collapse = " + "))

        myformula <- as.formula(myformula)

        # Fit model
        cox_model <- survival::coxph(myformula, data = mydata)

        # Validate method and try fallback if needed
        method <- self$options$ac_method

        # Try to create plot with specified method
        plot <- tryCatch({
          survminer::ggadjustedcurves(
            fit = cox_model,
            data = mydata,
            variable = adjexplanatory_name,
            method = method,
            conf.int = self$options$ci95,
            risk.table = self$options$risktable,
            xlab = paste0('Time (', self$options$timetypeoutput, ')'),
            title = paste0("Adjusted Survival Curves for ", self$options$adjexplanatory,
                           " (", method, " adjustment)"),
            pval = self$options$pplot,
            pval.method = self$options$pplot,
            legend = "none",
            break.time.by = self$options$byplot,
            xlim = c(0, self$options$endplot),
            censor = self$options$censored,
            surv.median.line = self$options$medianline



          )
        }, error = function(e) {
          # If marginal method fails, try average method instead
          if (method == "marginal") {
            warning("Marginal method failed, falling back to average method")
            survminer::ggadjustedcurves(
              fit = cox_model,
              data = mydata,
              variable = adjexplanatory_name,
              method = "average",  # Fallback to average method
              conf.int = self$options$ci95,
              risk.table = self$options$risktable,
              xlab = paste0('Time (', self$options$timetypeoutput, ')'),
              title = paste0("Adjusted Survival Curves for ",
                             self$options$adjexplanatory,
                             " (average adjustment - marginal failed)"),
              pval = self$options$pplot,
              pval.method = self$options$pplot,
              legend = "none",
              break.time.by = self$options$byplot,
              xlim = c(0, self$options$endplot),
              censor = self$options$censored,
              surv.median.line = self$options$medianline
            )
          } else {
            stop(paste("Error creating adjusted curves:", e$message))
          }
        })




        # # Prepare plot parameters
        # plot_params <- list(
        #   fit = cox_model,
        #   data = mydata,
        #   variable = adjexplanatory_name,
        #   method = self$options$ac_method,
        #   conf.int = self$options$ci95,
        #   risk.table = self$options$risktable,
        #   xlab = paste0('Time (', self$options$timetypeoutput, ')'),
        #   title = paste0("Adjusted Survival Curves for ",
        #                  self$options$adjexplanatory,
        #                  " (", self$options$ac_method, " adjustment)"),
        #   pval = self$options$pplot,
        #   pval.method = self$options$pplot,
        #   legend = "none",
        #   break.time.by = self$options$byplot,
        #   xlim = c(0, self$options$endplot),
        #   censor = self$options$censored,
        #   surv.median.line = self$options$medianline,
        #   risk.table.height = 0.25,  # Added for better risk table sizing
        #   risk.table.y.text.col = TRUE,  # Color code risk table text
        #   ncensor.plot = FALSE,  # Turn off censor plot by default
        #   fontsize = 3.5  # Adjust font size
        # )
        # # Try to create plot with specified method
        # plot <- tryCatch({
        #   do.call(survminer::ggadjustedcurves, plot_params)
        # }, error = function(e) {
        #   # If marginal method fails, try average method instead
        #   if (self$options$ac_method == "marginal") {
        #     warning("Marginal method failed, falling back to average method")
        #     plot_params$method <- "average"
        #     plot_params$title <- paste0("Adjusted Survival Curves for ",
        #                                 self$options$adjexplanatory,
        #                                 " (average adjustment - marginal failed)")
        #     do.call(survminer::ggadjustedcurves, plot_params)
        #   } else {
        #     stop(paste("Error creating adjusted curves:", e$message))
        #   }
        # })
        # # Add additional theme elements if needed
        # plot <- plot +
        #   ggplot2::theme(
        #     plot.title = ggplot2::element_text(size = 14, face = "bold"),
        #     plot.subtitle = ggplot2::element_text(size = 12),
        #     axis.title = ggplot2::element_text(size = 12),
        #     axis.text = ggplot2::element_text(size = 10),
        #     legend.text = ggplot2::element_text(size = 10)
        #   )












        print(plot)
        TRUE
      }



      # ,
      # .adjustedSurvTable = function(results, cox_model) {
      #   # Get data components
      #   mytime <- results$name1time
      #   myoutcome <- results$name2outcome
      #   adj_var <- results$adjexplanatory_name
      #   mydata <- results$cleanData
      #
      #   # Verify we have valid data and model
      #   if (is.null(mydata) || is.null(cox_model)) {
      #     return(NULL)
      #   }
      #
      #   # Get timepoints
      #   timepoints <- tryCatch({
      #     pts <- as.numeric(trimws(unlist(strsplit(self$options$ac_timepoints, ","))))
      #     pts <- sort(unique(pts[!is.na(pts)]))
      #     if (length(pts) == 0) c(12, 36, 60) else pts
      #   }, error = function(e) c(12, 36, 60))
      #
      #   # Get levels of adjustment variable
      #   levels <- sort(unique(mydata[[adj_var]]))
      #   if (length(levels) < 1) {
      #     warning("No levels found in adjustment variable")
      #     return(NULL)
      #   }
      #
      #   # Create base prediction dataset
      #   pred_base <- list()
      #   for (var in names(mydata)) {
      #     if (var != "mytime" && var != adj_var && var != "row_names") {
      #       if (is.numeric(mydata[[var]])) {
      #         pred_base[[var]] <- mean(mydata[[var]], na.rm = TRUE)
      #       } else if (is.factor(mydata[[var]])) {
      #         pred_base[[var]] <- levels(mydata[[var]])[which.max(table(mydata[[var]]))]
      #       }
      #     }
      #   }
      #
      #   # Initialize storage for results
      #   all_results <- list()
      #   row_counter <- 1
      #
      #   # Calculate survival for each level and timepoint
      #   for (level in levels) {
      #     # Create prediction data for this level
      #     pred_data <- data.frame(
      #       mytime = timepoints
      #     )
      #
      #     # Add averaged covariates
      #     for (var in names(pred_base)) {
      #       pred_data[[var]] <- pred_base[[var]]
      #     }
      #     pred_data[[adj_var]] <- level
      #
      #     tryCatch({
      #       # Get predicted survival
      #       surv_fit <- survival::survfit(cox_model, newdata = pred_data)
      #       surv_summary <- summary(surv_fit, times = timepoints)
      #
      #       # Extract results for each timepoint
      #       for (i in seq_along(timepoints)) {
      #         if (i <= length(surv_summary$time)) {
      #           all_results[[row_counter]] <- list(
      #             strata = level,
      #             time = timepoints[i],
      #             n.risk = surv_summary$n.risk[i],
      #             n.event = surv_summary$n.event[i],
      #             surv = surv_summary$surv[i],
      #             lower = surv_summary$lower[i],
      #             upper = surv_summary$upper[i]
      #           )
      #           row_counter <- row_counter + 1
      #         }
      #       }
      #     }, error = function(e) {
      #       warning(paste("Error processing level", level, ":", e$message))
      #     })
      #   }
      #
      #   # Convert results to data frame if we have any
      #   if (length(all_results) > 0) {
      #     results_df <- do.call(rbind, lapply(all_results, as.data.frame))
      #
      #     # Add to results table
      #     survTable <- self$results$adjustedSurvTable
      #     survTable$setRows(NULL) # Clear existing rows
      #
      #     for (i in seq_len(nrow(results_df))) {
      #       survTable$addRow(
      #         rowKey = i,
      #         values = list(
      #           strata = results_df$strata[i],
      #           time = results_df$time[i],
      #           n.risk = results_df$n.risk[i],
      #           n.event = results_df$n.event[i],
      #           surv = scales::percent(results_df$surv[i], accuracy = 0.1),
      #           lower = scales::percent(results_df$lower[i], accuracy = 0.1),
      #           upper = scales::percent(results_df$upper[i], accuracy = 0.1)
      #         )
      #       )
      #     }
      #
      #     # Generate summary text
      #     survTableSummary <- sapply(seq_len(nrow(results_df)), function(i) {
      #       glue::glue(
      #         "For {results_df$strata[i]} at {results_df$time[i]} months, ",
      #         "the adjusted survival probability is {scales::percent(results_df$surv[i], accuracy=0.1)} ",
      #         "[{scales::percent(results_df$lower[i], accuracy=0.1)}-",
      #         "{scales::percent(results_df$upper[i], accuracy=0.1)}, 95% CI]. ",
      #         "These estimates account for the average values of all covariates in the model."
      #       )
      #     })
      #
      #     self$results$adjustedSurvTableSummary$setContent(survTableSummary)
      #
      #     return(results_df)
      #   }
      #
      #   return(NULL)
      # }





      ,
    ## Adjusted Pariwise ----
    .adjustedPairwise = function(results, cox_model) {
      # Get components
      mytime <- results$name1time
      myoutcome <- results$name2outcome
      adj_var <- results$adjexplanatory_name
      mydata <- results$cleanData

      # Error checking
      if (is.null(mydata) || is.null(cox_model)) {
        warning("Missing data or model for pairwise comparisons")
        return(NULL)
      }

      # Get levels
      levels <- sort(unique(mydata[[adj_var]]))
      if (length(levels) < 2) {
        warning("Need at least 2 levels for pairwise comparisons")
        return(NULL)
      }

      # Create prediction dataset with average values
      pred_base <- data.frame(mytime = max(mydata[[mytime]]))
      for (var in names(mydata)) {
        if (var != "mytime" && var != adj_var && var != "row_names") {
          if (is.numeric(mydata[[var]])) {
            pred_base[[var]] <- mean(mydata[[var]], na.rm = TRUE)
          } else if (is.factor(mydata[[var]])) {
            pred_base[[var]] <- names(which.max(table(mydata[[var]])))
          }
        }
      }

      # Initialize p-value matrix
      n_levels <- length(levels)
      p_values <- matrix(NA, n_levels, n_levels)
      rownames(p_values) <- levels
      colnames(p_values) <- levels

      # Calculate pairwise comparisons
      for (i in 1:(n_levels-1)) {
        for (j in (i+1):n_levels) {
          tryCatch({
            # Create test dataset
            test_data <- rbind(pred_base, pred_base)
            test_data[[adj_var]] <- factor(c(levels[i], levels[j]))

            # Calculate survival difference
            test_fit <- survival::survfit(cox_model, newdata = test_data)
            surv_diff <- survival::survdiff(Surv(mytime, myoutcome) ~ factor(test_data[[adj_var]]))
            p_val <- 1 - pchisq(surv_diff$chisq, df = 1)

            p_values[i,j] <- p_val
            p_values[j,i] <- p_val
          }, error = function(e) {
            warning(paste("Error comparing levels", levels[i], "and", levels[j], ":", e$message))
          })
        }
      }

      # Adjust p-values
      padjustmethod <- self$options$padjustmethod
      adj_p <- p.adjust(p_values[upper.tri(p_values)], method = padjustmethod)
      p_values[upper.tri(p_values)] <- adj_p
      p_values[lower.tri(p_values)] <- t(p_values)[lower.tri(p_values)]

      # Convert to long format
      comparisons <- list()
      counter <- 1
      for (i in 1:(n_levels-1)) {
        for (j in (i+1):n_levels) {
          if (!is.na(p_values[i,j])) {
            comparisons[[counter]] <- list(
              rowname = levels[i],
              name = levels[j],
              value = p_values[i,j]
            )
            counter <- counter + 1
          }
        }
      }

      # Add results to table
      if (length(comparisons) > 0) {
        # Clear existing rows
        self$results$adjustedPairwiseTable$setRows(NULL)

        # Add new rows
        for (i in seq_along(comparisons)) {
          comp <- comparisons[[i]]
          self$results$adjustedPairwiseTable$addRow(
            rowKey = i,
            values = list(
              rowname = comp$rowname,
              name = comp$name,
              value = format.pval(comp$value, digits = 3)
            )
          )
        }

        # Create natural language summaries
        summaries <- lapply(comparisons, function(comp) {
          glue::glue(
            "The adjusted survival difference between {comp$rowname} and {comp$name} groups ",
            "has a p-value of {format.pval(comp$value, digits=3, eps=0.001)}. ",
            "This comparison accounts for covariates set at their average values. ",
            "{if(comp$value < 0.05) 'This difference is statistically significant' else 'This difference is not statistically significant'} ",
            "after {padjustmethod} adjustment for multiple comparisons."
          )
        })

        self$results$adjustedPairwiseSummary$setContent(unlist(summaries))
      }

      return(comparisons)
    }




      ,
    ## Adjusted Median Survival ----
    .adjustedMedianSurv = function(results, cox_model) {
      # Get required data
      mytime <- results$name1time
      myoutcome <- results$name2outcome
      adj_var <- results$adjexplanatory_name
      mydata <- results$cleanData

      # Get levels of adjustment variable
      levels <- sort(unique(mydata[[adj_var]]))

      # Create prediction data with average covariate values
      pred_data <- data.frame(
        mytime = sort(unique(mydata[[mytime]]))
      )

      # Add mean/mode values for covariates
      for (var in names(mydata)) {
        if (var != "mytime" && var != adj_var && var != "row_names") {
          if (is.numeric(mydata[[var]])) {
            pred_data[[var]] <- mean(mydata[[var]], na.rm = TRUE)
          } else if (is.factor(mydata[[var]])) {
            pred_data[[var]] <- names(which.max(table(mydata[[var]])))
          }
        }
      }

      # Calculate adjusted survival for each level
      results_list <- list()

      for (level in levels) {
        level_data <- pred_data
        level_data[[adj_var]] <- level

        # Calculate adjusted survival
        adj_surv <- survival::survfit(cox_model, newdata = level_data)

        # Get summary stats
        surv_summary <- summary(adj_surv)

        # Extract median and CI
        median_time <- surv_summary$table["median"]
        lcl <- surv_summary$table["0.95LCL"]
        ucl <- surv_summary$table["0.95UCL"]

        results_list[[level]] <- list(
          factor = level,
          median = median_time,
          x0_95lcl = lcl,
          x0_95ucl = ucl,
          records = sum(!is.na(mydata[[mytime]][mydata[[adj_var]] == level])),
          events = sum(mydata[[myoutcome]][mydata[[adj_var]] == level] == 1, na.rm = TRUE)
        )
      }

      # Convert to data frame
      results_df <- do.call(rbind, lapply(results_list, as.data.frame))
      results_df <- as.data.frame(results_df)

      # Add to results table
      medianTable <- self$results$adjustedMedianTable
      for (i in seq_len(nrow(results_df))) {
        medianTable$addRow(
          rowKey = i,
          values = list(
            factor = results_df$factor[i],
            records = results_df$records[i],
            events = results_df$events[i],
            median = round(results_df$median[i], 1),
            x0_95lcl = round(results_df$x0_95lcl[i], 1),
            x0_95ucl = round(results_df$x0_95ucl[i], 1)
          )
        )
      }

      # Create natural language summaries
      summaries <- lapply(levels, function(level) {
        result <- results_df[results_df$factor == level,]

        description <- glue::glue(
          "For {adj_var} = {level}, adjusted median survival is {round(result$median, 1)} ",
          "[{round(result$x0_95lcl, 1)} - {round(result$x0_95ucl, 1)}, 95% CI] ",
          self$options$timetypeoutput, "."
        )

        if (is.na(result$median)) {
          description <- paste0(
            description,
            "\nNote: The adjusted survival curve for this group does not drop below 1/2 during ",
            "the observation period, thus the median survival is undefined."
          )
        }

        return(description)
      })

      # Add general interpretation
      medianSummary <- c(
        unlist(summaries),
        "The median survival time is when 50% of subjects have experienced the event.",
        "These estimates account for the average values of all other covariates in the model."
      )

      self$results$adjustedMedianSummary$setContent(medianSummary)
    }


      ,
    ## Adjusted Cox ----
    .adjustedCox = function(results, cox_model) {
      mydata <- results$cleanData
      adj_var <- results$adjexplanatory_name

      # Get Cox model summary
      cox_summary <- summary(cox_model)

      # Create metrics summary
      tCoxtext2 <- glue::glue("
        <br>
        <b>Model Metrics:</b><br>
        Concordance: {round(cox_summary$concordance[1], 3)} (SE = {round(cox_summary$concordance[2], 3)})<br>
        Likelihood ratio test = {round(cox_summary$logtest[1], 2)}, df = {cox_summary$logtest[2]}, p = {format.pval(cox_summary$logtest[3], digits=3)}<br>
        Wald test = {round(cox_summary$waldtest[1], 2)}, df = {cox_summary$waldtest[2]}, p = {format.pval(cox_summary$waldtest[3], digits=3)}<br>
        Score test = {round(cox_summary$sctest[1], 2)}, df = {cox_summary$sctest[2]}, p = {format.pval(cox_summary$sctest[3], digits=3)}<br>
    ")

      if (self$options$uselandmark) {
        landmark <- jmvcore::toNumeric(self$options$landmark)
        tCoxtext2 <- glue::glue(
          tCoxtext2,
          "Landmark time used as: ", landmark, " ", self$options$timetypeoutput, "."
        )
      }

      self$results$adjustedCoxText$setContent(tCoxtext2)

      # Extract hazard ratios and CIs
      coef_matrix <- cbind(
        exp(cox_summary$coefficients[, 1]),  # HR
        exp(cox_summary$coefficients[, 1] - 1.96 * cox_summary$coefficients[, 3]),  # Lower CI
        exp(cox_summary$coefficients[, 1] + 1.96 * cox_summary$coefficients[, 3]),  # Upper CI
        cox_summary$coefficients[, 5]  # p-value
      )

      # Create Cox table
      coxTable <- self$results$adjustedCoxTable
      rownames <- row.names(cox_summary$coefficients)

      for (i in seq_len(nrow(coef_matrix))) {
        coxTable$addRow(
          rowKey = i,
          values = list(
            Variable = rownames[i],
            HR = sprintf("%.2f (%.2f-%.2f)",
                         coef_matrix[i,1], coef_matrix[i,2], coef_matrix[i,3]),
            Pvalue = format.pval(coef_matrix[i,4], digits=3)
          )
        )
      }

      # Create interpretive summary
      coxSummary <- sapply(seq_len(nrow(coef_matrix)), function(i) {
        hr <- coef_matrix[i,1]
        var_name <- rownames[i]

        glue::glue(
          "For {var_name}, the adjusted hazard ratio is {round(hr,2)} ",
          "({round(coef_matrix[i,2],2)}-{round(coef_matrix[i,3],2)}, 95% CI). ",
          "This means that, after adjusting for other covariates, ",
          "{ifelse(hr > 1,
                paste('there is a', round((hr-1)*100,1), '% increase in hazard'),
                paste('there is a', round((1-hr)*100,1), '% decrease in hazard'))} ",
          "for each unit increase in {var_name}."
        )
      })

      coxSummary <- c(
        unlist(coxSummary),
        "A hazard ratio greater than 1 indicates increased risk, while less than 1 indicates decreased risk.",
        "All estimates are adjusted for other variables in the model."
      )

      self$results$adjustedCoxSummary$setContent(coxSummary)

      # Proportional hazards check if requested
      if (self$options$ph_cox) {
        zph <- survival::cox.zph(cox_model)
        self$results$adjustedCoxPH$setContent(print(zph))

        # Set state for plot
        image8 <- self$results$adjustedCoxPHPlot
        image8$setState(zph)
      }
    }




      # ,
      # .calculateAdjustedCurves = function(cox_model, mydata, adjexplanatory_name, fallback = TRUE) {
      #
      #   method <- self$options$ac_method
      #
      #   # Try to calculate adjusted curves with specified method
      #   adj_curves <-  tryCatch({
      #       survminer::ggadjustedcurves(
      #         fit = cox_model,
      #         data = mydata,
      #         variable = adjexplanatory_name,
      #         method = method,
      #         conf.int = self$options$ci95,
      #         risk.table = self$options$risktable,
      #         xlab = paste0('Time (', self$options$timetypeoutput, ')'),
      #         title = paste0(
      #           "Adjusted Survival Curves for ",
      #           self$options$adjexplanatory,
      #           " (", method, " adjustment)"
      #         ),
      #         pval = self$options$pplot,
      #         pval.method = self$options$pplot,
      #         legend = "none",
      #         break.time.by = self$options$byplot,
      #         xlim = c(0, self$options$endplot),
      #         censored = self$options$censored
      #       )
      #     }, error = function(e) {
      #       # If marginal method fails, try average method instead
      #       if (method == "marginal") {
      #         warning("Marginal method failed, falling back to average method")
      #         survminer::ggadjustedcurves(
      #           fit = cox_model,
      #           data = mydata,
      #           variable = adjexplanatory_name,
      #           method = "average",  # Fallback to average method
      #           conf.int = self$options$ci95,
      #           risk.table = self$options$risktable,
      #           xlab = paste0('Time (', self$options$timetypeoutput, ')'),
      #           title = paste0(
      #             "Adjusted Survival Curves for ",
      #             self$options$adjexplanatory,
      #             " (average adjustment - marginal failed)"
      #           ),
      #           pval = self$options$pplot,
      #           pval.method = self$options$pplot,
      #           legend = "none",
      #           break.time.by = self$options$byplot,
      #           xlim = c(0, self$options$endplot),
      #           censored = self$options$censored
      #         )
      #       } else {
      #         stop(paste("Error creating adjusted curves:", e$message))
      #       }
      #     }
      #       )
      #
      #
      #   # image_plot_adj <- self$results$plot_adj
      #   # image_plot_adj$setState(adj_curves)
      #
      #
      #   # Extract and structure the data
      #   # curve_data <- list(
      #   #   curves = adj_curves,
      #   #   model = cox_model,
      #   #   data = mydata,
      #   #   variable = adjexplanatory_name,
      #   #   method = method
      #   # )
      #
      #   # class(curve_data) <- "adjusted_curves"
      #
      #
      #   # View curve_data ----
      #   self$results$mydataview_curve_data$setContent(
      #     list(
      #       # curves = adj_curves,
      #       model = cox_model,
      #       data = mydata,
      #       variable = adjexplanatory_name,
      #       method = method
      #     )
      #   )
      #
      #
      #   # return(curve_data)
      # }



      # ,
      # .plot_adj = function(image_plot_adj, ggtheme, theme, ...) {
      #   if (!self$options$ac) {
      #     return()
      #   }
      #   if (is.null(curve_data)) {
      #     return()
      #   }
      #
      #   plot <- image_plot_adj$state
      #
      #
      #   # plot <- survminer::ggadjustedcurves(plot)
      #
      #
      #   print(plot)
      #   TRUE
      #
      #
      # }




      # ,
      # .plot_adj = function(image_plot_adj, ggtheme, theme, ...) {
      #   if (!self$options$ac) {
      #     return()
      #   }
      #
      #   if (!self$options$ac_curve) {
      #     return()
      #   }
      #
      #
      #   # mydata <- image_plot_adj$state$mydata
      #   # cox_model <- image_plot_adj$state$cox_model
      #   # adjexplanatory_name <- image_plot_adj$state$adjexplanatory_name
      #
      #
      #
      #   cleaneddata <- private$.cleandata()
      #
      #   name1time <- cleaneddata$name1time
      #   name2outcome <- cleaneddata$name2outcome
      #   name3contexpl <- cleaneddata$name3contexpl
      #   name3expl <- cleaneddata$name3expl
      #   adjexplanatory_name <- cleaneddata$adjexplanatory_name
      #
      #   mydata <- cleanData <- cleaneddata$cleanData
      #
      #   mytime_labelled <- cleaneddata$mytime_labelled
      #   myoutcome_labelled <- cleaneddata$myoutcome_labelled
      #   mydxdate_labelled <- cleaneddata$mydxdate_labelled
      #   myfudate_labelled <- cleaneddata$myfudate_labelled
      #   myexplanatory_labelled <- cleaneddata$myexplanatory_labelled
      #   mycontexpl_labelled <- cleaneddata$mycontexpl_labelled
      #   adjexplanatory_labelled <- cleaneddata$adjexplanatory_labelled
      #
      #
      #
      #   # Add stratification variables
      #   mystratvar <- NULL
      #   if (self$options$use_stratify && !is.null(self$options$stratvar)) {
      #     mystratvar <- as.vector(cleaneddata$mystratvar_labelled)
      #     # Create strata terms
      #     mystratvar <- paste0("strata(", mystratvar, ")")
      #   }
      #
      #
      #
      #   myexplanatory <- NULL
      #   if (!is.null(self$options$explanatory)) {
      #     myexplanatory <- as.vector(myexplanatory_labelled)
      #   }
      #
      #   mycontexpl <- NULL
      #   if (!is.null(self$options$contexpl)) {
      #     mycontexpl <- as.vector(mycontexpl_labelled)
      #   }
      #
      #
      #   formula2 <- c(myexplanatory, mycontexpl, mystratvar)
      #
      #
      #
      #   LHT <- "survival::Surv(mytime, myoutcome)"
      #
      #   RHT <- formula2
      #
      #   RHT <- paste(RHT, collapse = " + ")
      #
      #   coxformula <- paste0(LHT, " ~ ", RHT)
      #
      #   coxformula <- as.formula(coxformula)
      #
      #   cox_model <- survival::coxph(coxformula, data = mydata)
      #
      #
      #
      #   fallback <- TRUE
      #   method <- self$options$ac_method
      #
      #   # Try to calculate adjusted curves with specified method
      #   adj_curves <-  tryCatch({
      #     survminer::ggadjustedcurves(
      #       fit = cox_model,
      #       data = mydata,
      #       variable = adjexplanatory_name,
      #       method = method,
      #       conf.int = self$options$ci95,
      #       risk.table = self$options$risktable,
      #       xlab = paste0('Time (', self$options$timetypeoutput, ')'),
      #       title = paste0(
      #         "Adjusted Survival Curves for ",
      #         self$options$adjexplanatory,
      #         " (", method, " adjustment)"
      #       ),
      #       pval = self$options$pplot,
      #       pval.method = self$options$pplot,
      #       legend = "none",
      #       break.time.by = self$options$byplot,
      #       xlim = c(0, self$options$endplot),
      #       censored = self$options$censored
      #     )
      #   }, error = function(e) {
      #     # If marginal method fails, try average method instead
      #     if (method == "marginal") {
      #       warning("Marginal method failed, falling back to average method")
      #       survminer::ggadjustedcurves(
      #         fit = cox_model,
      #         data = mydata,
      #         variable = adjexplanatory_name,
      #         method = "average",  # Fallback to average method
      #         conf.int = self$options$ci95,
      #         risk.table = self$options$risktable,
      #         xlab = paste0('Time (', self$options$timetypeoutput, ')'),
      #         title = paste0(
      #           "Adjusted Survival Curves for ",
      #           self$options$adjexplanatory,
      #           " (average adjustment - marginal failed)"
      #         ),
      #         pval = self$options$pplot,
      #         pval.method = self$options$pplot,
      #         legend = "none",
      #         break.time.by = self$options$byplot,
      #         xlim = c(0, self$options$endplot),
      #         censored = self$options$censored
      #       )
      #     } else {
      #       stop(paste("Error creating adjusted curves:", e$message))
      #     }
      #   }
      #   )
      #
      #
      #
      #
      #   print(adj_curves)
      #   TRUE
      #
      #
      # }















      ,
      # fitModelWithSelection ----
      .fitModelWithSelection = function(formula, data) {
        modelSelection <- self$options$modelSelection
        selectionCriteria <- self$options$selectionCriteria
        pEntry <- self$options$pEntry
        pRemoval <- self$options$pRemoval


        if (self$options$pEntry >= self$options$pRemoval) {
          stop("Entry significance must be less than removal significance")
        }

        if (self$options$modelSelection != "enter" &&
            length(c(self$options$explanatory, self$options$contexpl)) < 2) {
          stop("Variable selection requires at least 2 predictor variables")
        }


        # Create full and null models
        full_model <- survival::coxph(formula, data = data)
        null_model <- survival::coxph(update(formula, . ~ 1), data = data)

        # If no selection requested, return full model
        if (modelSelection == "enter") {
          return(full_model)
        }

        # Set up step parameters
        step_params <- list(
          scope = list(
            lower = formula(null_model),
            upper = formula(full_model)
          ),
          direction = modelSelection,
          k = if (selectionCriteria == "aic")
            2
          else
            0,
          # k=2 for AIC
          test = if (selectionCriteria == "lrt")
            "LRT"
          else
            "Chisq"
        )

        # Add custom test function for likelihood ratio
        if (selectionCriteria == "lrt") {
          step_params$test.statistic <- "LRT"
          step_params$alpha.to.enter <- pEntry
          step_params$alpha.to.remove <- pRemoval
        }

        # Perform stepwise selection
        if (modelSelection == "forward") {
          final_model <- do.call("step", c(list(object = null_model), step_params))
        } else if (modelSelection == "backward") {
          final_model <- do.call("step", c(list(object = full_model), step_params))
        } else {
          # both
          final_model <- do.call("step", c(list(object = null_model), step_params))
        }

        return(final_model)
      }


      # finalfit 2 ----
      ,
      .final_fit2 = function() {
        cleaneddata <- private$.cleandata()

        name1time <- cleaneddata$name1time
        name2outcome <- cleaneddata$name2outcome
        name3contexpl <- cleaneddata$name3contexpl
        name3expl <- cleaneddata$name3expl
        adjexplanatory_name <- cleaneddata$adjexplanatory_name

        mydata <- cleanData <- cleaneddata$cleanData

        mytime_labelled <- cleaneddata$mytime_labelled
        myoutcome_labelled <- cleaneddata$myoutcome_labelled
        mydxdate_labelled <- cleaneddata$mydxdate_labelled
        myfudate_labelled <- cleaneddata$myfudate_labelled
        myexplanatory_labelled <- cleaneddata$myexplanatory_labelled
        mycontexpl_labelled <- cleaneddata$mycontexpl_labelled
        adjexplanatory_labelled <- cleaneddata$adjexplanatory_labelled


        ## prepare formula ----

        myexplanatory <- NULL

        if (!is.null(self$options$explanatory)) {
          myexplanatory <- as.vector(myexplanatory_labelled)
        }

        mycontexpl <- NULL
        if (!is.null(self$options$contexpl)) {
          mycontexpl <- as.vector(mycontexpl_labelled)
        }


        formula2 <- c(myexplanatory, mycontexpl)

        myformula <-
          paste("survival::Surv( mytime, myoutcome ) ~ ", paste(formula2, collapse = " + "))

        myformula <- as.formula(myformula)

        # self$results$mydataview$setContent(
        #     list(
        #         mydata = head(mydata, n = 30),
        #         myformula = myformula,
        #         myexplanatory = myexplanatory,
        #         mycontexpl = mycontexpl,
        #         formula2 = formula2
        #     )
        # )




        ## finalfit Multivariable table ----


        model <- private$.fitModelWithSelection(myformula, mydata)


        # finalfit::finalfit(.data = mydata,
        #                    formula = myformula,
        #                    # dependent = myformula,
        #                    # explanatory = formula2,
        #
        #                    metrics = TRUE) -> tMultivariable


        text2_model_selection <- glue::glue("
                                    <br>
                                    <b>Model Metrics:</b>
                                    ",
                                            unlist(model[[2]]),
                                            "
                                    <br>
                                    ")

        # Add selection results to the output
        if (self$options$modelSelection != "enter") {
          text2_model_selection <- paste0(
            text2_model_selection,
            "\n<br><b>Model Selection Results:</b><br>",
            "Selection method: ",
            self$options$modelSelection,
            "<br>Selection criteria: ",
            self$options$selectionCriteria,
            "<br>Variables in final model: ",
            paste(names(model$coefficients), collapse = ", ")
          )
        }




        if (self$options$uselandmark) {
          landmark <- jmvcore::toNumeric(self$options$landmark)

          text2_model_selection <- glue::glue(
            text2_model_selection,
            "Landmark time used as: ",
            landmark,
            " ",
            self$options$timetypeoutput,
            "."
          )
        }

        if (self$options$modelSelection != "enter") {
          text2_model_selection <- glue::glue(
            text2_model_selection,
            "Note: Stepwise selection methods should be used with caution. They may not always select the most theoretically meaningful model and can lead to overfitting."
          )

        }



        self$results$text2_model_selection$setContent(text2_model_selection)



        text_model_selection <- knitr::kable(
          model[[1]],
          row.names = FALSE,
          align = c('l', 'l', 'r', 'r', 'r', 'r'),
          format = "html"
        )

        self$results$text_model_selection$setContent(text_model_selection)

      }



    )
  )


File: R\multisurvival.h.R
--------------------------------------------------
Content of R\multisurvival.h.R:

# This file is automatically generated, you probably don't want to edit this

multisurvivalOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "multisurvivalOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            elapsedtime = NULL,
            tint = FALSE,
            dxdate = NULL,
            fudate = NULL,
            timetypedata = "ymd",
            timetypeoutput = "months",
            uselandmark = FALSE,
            landmark = 3,
            outcome = NULL,
            outcomeLevel = NULL,
            dod = NULL,
            dooc = NULL,
            awd = NULL,
            awod = NULL,
            analysistype = "overall",
            explanatory = NULL,
            contexpl = NULL,
            multievent = FALSE,
            hr = FALSE,
            sty = "t1",
            ph_cox = FALSE,
            km = FALSE,
            endplot = 60,
            byplot = 12,
            ci95 = FALSE,
            risktable = FALSE,
            censored = FALSE,
            medianline = "none",
            pplot = TRUE,
            calculateRiskScore = FALSE,
            plotRiskGroups = FALSE,
            ac = FALSE,
            adjexplanatory = NULL,
            ac_method = "average",
            use_stratify = FALSE, ...) {

            super$initialize(
                package="jsurvival",
                name="multisurvival",
                requiresData=TRUE,
                ...)

            private$..elapsedtime <- jmvcore::OptionVariable$new(
                "elapsedtime",
                elapsedtime,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..tint <- jmvcore::OptionBool$new(
                "tint",
                tint,
                default=FALSE)
            private$..dxdate <- jmvcore::OptionVariable$new(
                "dxdate",
                dxdate)
            private$..fudate <- jmvcore::OptionVariable$new(
                "fudate",
                fudate)
            private$..timetypedata <- jmvcore::OptionList$new(
                "timetypedata",
                timetypedata,
                options=list(
                    "ymdhms",
                    "ymd",
                    "ydm",
                    "mdy",
                    "myd",
                    "dmy",
                    "dym"),
                default="ymd")
            private$..timetypeoutput <- jmvcore::OptionList$new(
                "timetypeoutput",
                timetypeoutput,
                options=list(
                    "days",
                    "weeks",
                    "months",
                    "years"),
                default="months")
            private$..uselandmark <- jmvcore::OptionBool$new(
                "uselandmark",
                uselandmark,
                default=FALSE)
            private$..landmark <- jmvcore::OptionInteger$new(
                "landmark",
                landmark,
                default=3)
            private$..calculatedtime <- jmvcore::OptionOutput$new(
                "calculatedtime")
            private$..outcome <- jmvcore::OptionVariable$new(
                "outcome",
                outcome,
                suggested=list(
                    "ordinal",
                    "nominal",
                    "continuous"),
                permitted=list(
                    "factor",
                    "numeric"))
            private$..outcomeLevel <- jmvcore::OptionLevel$new(
                "outcomeLevel",
                outcomeLevel,
                variable="(outcome)")
            private$..dod <- jmvcore::OptionLevel$new(
                "dod",
                dod,
                variable="(outcome)",
                allowNone=TRUE)
            private$..dooc <- jmvcore::OptionLevel$new(
                "dooc",
                dooc,
                variable="(outcome)",
                allowNone=TRUE)
            private$..awd <- jmvcore::OptionLevel$new(
                "awd",
                awd,
                variable="(outcome)",
                allowNone=TRUE)
            private$..awod <- jmvcore::OptionLevel$new(
                "awod",
                awod,
                variable="(outcome)",
                allowNone=TRUE)
            private$..analysistype <- jmvcore::OptionList$new(
                "analysistype",
                analysistype,
                options=list(
                    "overall",
                    "cause",
                    "compete"),
                default="overall")
            private$..outcomeredefined <- jmvcore::OptionOutput$new(
                "outcomeredefined")
            private$..explanatory <- jmvcore::OptionVariables$new(
                "explanatory",
                explanatory,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..contexpl <- jmvcore::OptionVariables$new(
                "contexpl",
                contexpl,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..multievent <- jmvcore::OptionBool$new(
                "multievent",
                multievent,
                default=FALSE)
            private$..hr <- jmvcore::OptionBool$new(
                "hr",
                hr,
                default=FALSE)
            private$..sty <- jmvcore::OptionList$new(
                "sty",
                sty,
                options=list(
                    "t1",
                    "t3"),
                default="t1")
            private$..ph_cox <- jmvcore::OptionBool$new(
                "ph_cox",
                ph_cox,
                default=FALSE)
            private$..km <- jmvcore::OptionBool$new(
                "km",
                km,
                default=FALSE)
            private$..endplot <- jmvcore::OptionInteger$new(
                "endplot",
                endplot,
                default=60)
            private$..byplot <- jmvcore::OptionInteger$new(
                "byplot",
                byplot,
                default=12)
            private$..ci95 <- jmvcore::OptionBool$new(
                "ci95",
                ci95,
                default=FALSE)
            private$..risktable <- jmvcore::OptionBool$new(
                "risktable",
                risktable,
                default=FALSE)
            private$..censored <- jmvcore::OptionBool$new(
                "censored",
                censored,
                default=FALSE)
            private$..medianline <- jmvcore::OptionList$new(
                "medianline",
                medianline,
                options=list(
                    "none",
                    "h",
                    "v",
                    "hv"),
                default="none")
            private$..pplot <- jmvcore::OptionBool$new(
                "pplot",
                pplot,
                default=TRUE)
            private$..calculateRiskScore <- jmvcore::OptionBool$new(
                "calculateRiskScore",
                calculateRiskScore,
                default=FALSE)
            private$..plotRiskGroups <- jmvcore::OptionBool$new(
                "plotRiskGroups",
                plotRiskGroups,
                default=FALSE)
            private$..addRiskScore <- jmvcore::OptionOutput$new(
                "addRiskScore")
            private$..addRiskGroup <- jmvcore::OptionOutput$new(
                "addRiskGroup")
            private$..ac <- jmvcore::OptionBool$new(
                "ac",
                ac,
                default=FALSE)
            private$..adjexplanatory <- jmvcore::OptionVariable$new(
                "adjexplanatory",
                adjexplanatory,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..ac_method <- jmvcore::OptionList$new(
                "ac_method",
                ac_method,
                options=list(
                    "average",
                    "conditional",
                    "single",
                    "marginal"),
                default="average")
            private$..use_stratify <- jmvcore::OptionBool$new(
                "use_stratify",
                use_stratify,
                default=FALSE)

            self$.addOption(private$..elapsedtime)
            self$.addOption(private$..tint)
            self$.addOption(private$..dxdate)
            self$.addOption(private$..fudate)
            self$.addOption(private$..timetypedata)
            self$.addOption(private$..timetypeoutput)
            self$.addOption(private$..uselandmark)
            self$.addOption(private$..landmark)
            self$.addOption(private$..calculatedtime)
            self$.addOption(private$..outcome)
            self$.addOption(private$..outcomeLevel)
            self$.addOption(private$..dod)
            self$.addOption(private$..dooc)
            self$.addOption(private$..awd)
            self$.addOption(private$..awod)
            self$.addOption(private$..analysistype)
            self$.addOption(private$..outcomeredefined)
            self$.addOption(private$..explanatory)
            self$.addOption(private$..contexpl)
            self$.addOption(private$..multievent)
            self$.addOption(private$..hr)
            self$.addOption(private$..sty)
            self$.addOption(private$..ph_cox)
            self$.addOption(private$..km)
            self$.addOption(private$..endplot)
            self$.addOption(private$..byplot)
            self$.addOption(private$..ci95)
            self$.addOption(private$..risktable)
            self$.addOption(private$..censored)
            self$.addOption(private$..medianline)
            self$.addOption(private$..pplot)
            self$.addOption(private$..calculateRiskScore)
            self$.addOption(private$..plotRiskGroups)
            self$.addOption(private$..addRiskScore)
            self$.addOption(private$..addRiskGroup)
            self$.addOption(private$..ac)
            self$.addOption(private$..adjexplanatory)
            self$.addOption(private$..ac_method)
            self$.addOption(private$..use_stratify)
        }),
    active = list(
        elapsedtime = function() private$..elapsedtime$value,
        tint = function() private$..tint$value,
        dxdate = function() private$..dxdate$value,
        fudate = function() private$..fudate$value,
        timetypedata = function() private$..timetypedata$value,
        timetypeoutput = function() private$..timetypeoutput$value,
        uselandmark = function() private$..uselandmark$value,
        landmark = function() private$..landmark$value,
        calculatedtime = function() private$..calculatedtime$value,
        outcome = function() private$..outcome$value,
        outcomeLevel = function() private$..outcomeLevel$value,
        dod = function() private$..dod$value,
        dooc = function() private$..dooc$value,
        awd = function() private$..awd$value,
        awod = function() private$..awod$value,
        analysistype = function() private$..analysistype$value,
        outcomeredefined = function() private$..outcomeredefined$value,
        explanatory = function() private$..explanatory$value,
        contexpl = function() private$..contexpl$value,
        multievent = function() private$..multievent$value,
        hr = function() private$..hr$value,
        sty = function() private$..sty$value,
        ph_cox = function() private$..ph_cox$value,
        km = function() private$..km$value,
        endplot = function() private$..endplot$value,
        byplot = function() private$..byplot$value,
        ci95 = function() private$..ci95$value,
        risktable = function() private$..risktable$value,
        censored = function() private$..censored$value,
        medianline = function() private$..medianline$value,
        pplot = function() private$..pplot$value,
        calculateRiskScore = function() private$..calculateRiskScore$value,
        plotRiskGroups = function() private$..plotRiskGroups$value,
        addRiskScore = function() private$..addRiskScore$value,
        addRiskGroup = function() private$..addRiskGroup$value,
        ac = function() private$..ac$value,
        adjexplanatory = function() private$..adjexplanatory$value,
        ac_method = function() private$..ac_method$value,
        use_stratify = function() private$..use_stratify$value),
    private = list(
        ..elapsedtime = NA,
        ..tint = NA,
        ..dxdate = NA,
        ..fudate = NA,
        ..timetypedata = NA,
        ..timetypeoutput = NA,
        ..uselandmark = NA,
        ..landmark = NA,
        ..calculatedtime = NA,
        ..outcome = NA,
        ..outcomeLevel = NA,
        ..dod = NA,
        ..dooc = NA,
        ..awd = NA,
        ..awod = NA,
        ..analysistype = NA,
        ..outcomeredefined = NA,
        ..explanatory = NA,
        ..contexpl = NA,
        ..multievent = NA,
        ..hr = NA,
        ..sty = NA,
        ..ph_cox = NA,
        ..km = NA,
        ..endplot = NA,
        ..byplot = NA,
        ..ci95 = NA,
        ..risktable = NA,
        ..censored = NA,
        ..medianline = NA,
        ..pplot = NA,
        ..calculateRiskScore = NA,
        ..plotRiskGroups = NA,
        ..addRiskScore = NA,
        ..addRiskGroup = NA,
        ..ac = NA,
        ..adjexplanatory = NA,
        ..ac_method = NA,
        ..use_stratify = NA)
)

multisurvivalResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "multisurvivalResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        text = function() private$.items[["text"]],
        text2 = function() private$.items[["text2"]],
        plot = function() private$.items[["plot"]],
        plot3 = function() private$.items[["plot3"]],
        cox_ph = function() private$.items[["cox_ph"]],
        plot8 = function() private$.items[["plot8"]],
        plotKM = function() private$.items[["plotKM"]],
        riskScoreTable = function() private$.items[["riskScoreTable"]],
        riskScoreMetrics = function() private$.items[["riskScoreMetrics"]],
        riskGroupPlot = function() private$.items[["riskGroupPlot"]],
        calculatedtime = function() private$.items[["calculatedtime"]],
        outcomeredefined = function() private$.items[["outcomeredefined"]],
        addRiskScore = function() private$.items[["addRiskScore"]],
        addRiskGroup = function() private$.items[["addRiskGroup"]],
        plot_adj = function() private$.items[["plot_adj"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Multivariable Survival Analysis",
                refs=list(
                    "multivariable",
                    "survivaltutorial",
                    "survivalrwnahhas",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do",
                clearWith=list(
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "explanatory",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Html$new(
                options=options,
                name="text",
                title="Multivariable Survival",
                refs="finalfit",
                clearWith=list(
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "explanatory",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Html$new(
                options=options,
                name="text2",
                title="",
                refs="finalfit",
                clearWith=list(
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "explanatory",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot",
                title="Hazards Regression Plot",
                width=600,
                height=450,
                renderFun=".plot",
                requiresData=TRUE,
                visible="(hr && sty:t1)",
                refs="finalfit",
                clearWith=list(
                    "hr",
                    "sty",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "explanatory",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot3",
                title="Hazards Regression Plot",
                width=800,
                height=600,
                renderFun=".plot3",
                requiresData=TRUE,
                visible="(hr && sty:t3)",
                refs="survminer",
                clearWith=list(
                    "hr",
                    "sty",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "explanatory",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="cox_ph",
                title="Proportional Hazards Assumption",
                visible="(ph_cox)",
                clearWith=list(
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent",
                    "contexpl")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot8",
                title="Proportional Hazards Assumption",
                width=600,
                height=450,
                renderFun=".plot8",
                visible="(ph_cox)",
                requiresData=TRUE,
                clearWith=list(
                    "ph_cox",
                    "endplot",
                    "byplot",
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent",
                    "contexpl")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plotKM",
                title="Kaplan-Meier",
                width=600,
                height=450,
                renderFun=".plotKM",
                requiresData=TRUE,
                visible="(km)",
                refs="finalfit",
                clearWith=list(
                    "km",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "explanatory",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent",
                    "adjexplanatory",
                    "pplot",
                    "censored",
                    "medianline")))
            self$add(jmvcore::Table$new(
                options=options,
                name="riskScoreTable",
                title="Risk Score Summary",
                visible="(calculateRiskScore)",
                rows=0,
                columns=list(
                    list(
                        `name`="group", 
                        `title`="Risk Group", 
                        `type`="text"),
                    list(
                        `name`="n_patients", 
                        `title`="N", 
                        `type`="integer"),
                    list(
                        `name`="percent", 
                        `title`="Percent", 
                        `type`="number"),
                    list(
                        `name`="median_score", 
                        `title`="Median Score", 
                        `type`="number"),
                    list(
                        `name`="events", 
                        `title`="Events", 
                        `type`="integer")),
                clearWith=list(
                    "calculateRiskScore",
                    "outcome",
                    "outcomeLevel",
                    "explanatory",
                    "contexpl")))
            self$add(jmvcore::Html$new(
                options=options,
                name="riskScoreMetrics",
                title="Risk Score Model Metrics",
                visible="(calculateRiskScore)",
                clearWith=list(
                    "calculateRiskScore",
                    "outcome",
                    "outcomeLevel",
                    "explanatory",
                    "contexpl")))
            self$add(jmvcore::Image$new(
                options=options,
                name="riskGroupPlot",
                title="Risk Group Survival Plot",
                width=600,
                height=450,
                renderFun=".plotRiskGroups",
                requiresData=TRUE,
                visible="(plotRiskGroups)"))
            self$add(jmvcore::Output$new(
                options=options,
                name="calculatedtime",
                title="Add Calculated Time to Data",
                varTitle="`Calculated Time in Multivariable Survival Function - from ${ dxdate } to { fudate }`",
                varDescription="Calculated Time from given Dates in Multivariable Survival Analysis",
                clearWith=list(
                    "tint",
                    "dxdate",
                    "fudate")))
            self$add(jmvcore::Output$new(
                options=options,
                name="outcomeredefined",
                title="Add Redefined Outcome to Data",
                varTitle="`Redefined Outcome in Multivariable Survival Function - from ${ outcome } for analysis { analysistype }`",
                varDescription="Redefined Outcome from Outcome based on Analysis Type in Multivariable Survival Analysis",
                clearWith=list(
                    "outcome",
                    "analysistype",
                    "multievent")))
            self$add(jmvcore::Output$new(
                options=options,
                name="addRiskScore",
                title="Add Calculated Risk Score to Data",
                varTitle="`Calculated Risk Score in Multivariable Survival Function`",
                varDescription="Calculated Risk Score Based on Model",
                clearWith=list(
                    "addRiskScore",
                    "calculateRiskScore",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "explanatory",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent",
                    "addRiskGroup")))
            self$add(jmvcore::Output$new(
                options=options,
                name="addRiskGroup",
                title="Add Calculated Risk Group to Data",
                varTitle="`Calculated Risk Group in Multivariable Survival Function`",
                varDescription="Calculated Risk Group Based on Model",
                clearWith=list(
                    "addRiskScore",
                    "calculateRiskScore",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "explanatory",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent",
                    "addRiskGroup")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot_adj",
                title="Adjusted Survival Plot",
                width=600,
                height=450,
                renderFun=".plot_adj",
                visible="(ac)",
                refs="survminer",
                clearWith=list(
                    "ac",
                    "adjexplanatory",
                    "ci95",
                    "risktable",
                    "ac_method",
                    "endplot",
                    "byplot",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "explanatory",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent",
                    "adjexplanatory",
                    "pplot",
                    "censored",
                    "medianline")))}))

multisurvivalBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "multisurvivalBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "jsurvival",
                name = "multisurvival",
                version = c(1,0,0),
                options = options,
                results = multisurvivalResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'none')
        }))

#' Multivariable Survival Analysis
#'
#' Function for Multivariable Survival Analysis using Cox-regression.
#'
#' @examples
#' \donttest{
#' # example will be added
#'}
#' @param data The dataset to be analyzed, provided as a data frame. Must
#'   contain the variables specified in the options below.
#' @param elapsedtime The numeric variable representing follow-up time until
#'   the event or last observation. If \code{tint} = false, this should be a
#'   pre-calculated numeric time variable. If \code{tint} = true, \code{dxdate}
#'   and \code{fudate} will be used to calculate this time.
#' @param tint If true, survival time will be calculated from \code{dxdate}
#'   and \code{fudate}. If false, \code{elapsedtime} should be provided as a
#'   pre-calculated numeric variable.
#' @param dxdate Date of diagnosis. Required if \code{tint} = true. Must match
#'   the format specified in \code{timetypedata}.
#' @param fudate Follow-up date or date of last observation. Required if
#'   \code{tint} = true. Must match the format specified in \code{timetypedata}.
#' @param timetypedata Specifies the format of the date variables in the input
#'   data. This is critical if \code{tint = true}, as \code{dxdate} and
#'   \code{fudate} will be parsed according to this format to calculate survival
#'   time. For example, if your data files record dates as "YYYY-MM-DD", select
#'   \code{ymd}.
#' @param timetypeoutput The units in which survival time is reported in the
#'   output. Choose from days, weeks, months, or years.
#' @param uselandmark If true, applies a landmark analysis starting at a
#'   specified time point.
#' @param landmark The time point (in the units defined by
#'   \code{timetypeoutput}) at which to start landmark analyses. Only used if
#'   \code{uselandmark} = true.
#' @param outcome The outcome variable. Typically indicates event status
#'   (e.g., death, recurrence). For survival analysis, this may be a factor or
#'   numeric event indicator.
#' @param outcomeLevel The level of \code{outcome} considered as the event.
#'   For example, if \code{outcome} is a factor, specify which level indicates
#'   the event occurrence.
#' @param dod The level of \code{outcome} corresponding to death due to
#'   disease, if applicable.
#' @param dooc The level of \code{outcome} corresponding to death due to other
#'   causes, if applicable.
#' @param awd The level of \code{outcome} corresponding to alive with disease,
#'   if applicable.
#' @param awod The level of \code{outcome} corresponding to alive without
#'   disease, if applicable.
#' @param analysistype Type of survival analysis: - overall: All-cause
#'   survival - cause: Cause-specific survival - compete: Competing risks
#'   analysis
#' @param explanatory Categorical explanatory (predictor) variables included
#'   in the Cox model.
#' @param contexpl Continuous explanatory (predictor) variables included in
#'   the Cox model.
#' @param multievent If true, multiple event levels will be considered for
#'   competing risks analysis. Requires specifying \code{dod}, \code{dooc}, etc.
#' @param hr If true, generates a plot of hazard ratios for each explanatory
#'   variable in the Cox model.
#' @param sty The style of the hazard ratio (forest) plot. "finalfit" or
#'   "survminer forestplot".
#' @param ph_cox If true, tests the proportional hazards assumption for the
#'   Cox model. Use if you suspect violations of the PH assumption.
#' @param km If true, produces a Kaplan-Meier survival plot. Useful for
#'   visualization of survival functions without covariate adjustment.
#' @param endplot The maximum follow-up time (in units defined by
#'   \code{timetypeoutput}) to display on survival plots.
#' @param byplot The interval (in units defined by \code{timetypeoutput}) at
#'   which time points or labels are shown on plots.
#' @param ci95 If true, displays 95\% confidence intervals around the survival
#'   estimates on plots.
#' @param risktable If true, displays the number of subjects at risk at each
#'   time point below the survival plot.
#' @param censored If true, marks censored observations (e.g., using tick
#'   marks) on the survival plot.
#' @param medianline If true, displays a line indicating the median survival
#'   time on the survival plot.
#' @param pplot If true, displays the p-value from the survival comparison
#'   test on the survival plot.
#' @param calculateRiskScore If true, calculates a risk score from the Cox
#'   model coefficients for each individual.
#' @param plotRiskGroups If true, stratifies individuals into risk groups
#'   based on their calculated risk scores and plots their survival curves.
#' @param ac .
#' @param adjexplanatory .
#' @param ac_method Method for computing adjusted survival curves
#' @param use_stratify .
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$text} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$text2} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$plot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plot3} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$cox_ph} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$plot8} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plotKM} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$riskScoreTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$riskScoreMetrics} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$riskGroupPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$calculatedtime} \tab \tab \tab \tab \tab an output \cr
#'   \code{results$outcomeredefined} \tab \tab \tab \tab \tab an output \cr
#'   \code{results$addRiskScore} \tab \tab \tab \tab \tab an output \cr
#'   \code{results$addRiskGroup} \tab \tab \tab \tab \tab an output \cr
#'   \code{results$plot_adj} \tab \tab \tab \tab \tab an image \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$riskScoreTable$asDF}
#'
#' \code{as.data.frame(results$riskScoreTable)}
#'
#' @export
multisurvival <- function(
    data,
    elapsedtime,
    tint = FALSE,
    dxdate,
    fudate,
    timetypedata = "ymd",
    timetypeoutput = "months",
    uselandmark = FALSE,
    landmark = 3,
    outcome,
    outcomeLevel,
    dod,
    dooc,
    awd,
    awod,
    analysistype = "overall",
    explanatory,
    contexpl,
    multievent = FALSE,
    hr = FALSE,
    sty = "t1",
    ph_cox = FALSE,
    km = FALSE,
    endplot = 60,
    byplot = 12,
    ci95 = FALSE,
    risktable = FALSE,
    censored = FALSE,
    medianline = "none",
    pplot = TRUE,
    calculateRiskScore = FALSE,
    plotRiskGroups = FALSE,
    ac = FALSE,
    adjexplanatory,
    ac_method = "average",
    use_stratify = FALSE) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("multisurvival requires jmvcore to be installed (restart may be required)")

    if ( ! missing(elapsedtime)) elapsedtime <- jmvcore::resolveQuo(jmvcore::enquo(elapsedtime))
    if ( ! missing(dxdate)) dxdate <- jmvcore::resolveQuo(jmvcore::enquo(dxdate))
    if ( ! missing(fudate)) fudate <- jmvcore::resolveQuo(jmvcore::enquo(fudate))
    if ( ! missing(outcome)) outcome <- jmvcore::resolveQuo(jmvcore::enquo(outcome))
    if ( ! missing(explanatory)) explanatory <- jmvcore::resolveQuo(jmvcore::enquo(explanatory))
    if ( ! missing(contexpl)) contexpl <- jmvcore::resolveQuo(jmvcore::enquo(contexpl))
    if ( ! missing(adjexplanatory)) adjexplanatory <- jmvcore::resolveQuo(jmvcore::enquo(adjexplanatory))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(elapsedtime), elapsedtime, NULL),
            `if`( ! missing(dxdate), dxdate, NULL),
            `if`( ! missing(fudate), fudate, NULL),
            `if`( ! missing(outcome), outcome, NULL),
            `if`( ! missing(explanatory), explanatory, NULL),
            `if`( ! missing(contexpl), contexpl, NULL),
            `if`( ! missing(adjexplanatory), adjexplanatory, NULL))

    for (v in explanatory) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])
    for (v in adjexplanatory) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- multisurvivalOptions$new(
        elapsedtime = elapsedtime,
        tint = tint,
        dxdate = dxdate,
        fudate = fudate,
        timetypedata = timetypedata,
        timetypeoutput = timetypeoutput,
        uselandmark = uselandmark,
        landmark = landmark,
        outcome = outcome,
        outcomeLevel = outcomeLevel,
        dod = dod,
        dooc = dooc,
        awd = awd,
        awod = awod,
        analysistype = analysistype,
        explanatory = explanatory,
        contexpl = contexpl,
        multievent = multievent,
        hr = hr,
        sty = sty,
        ph_cox = ph_cox,
        km = km,
        endplot = endplot,
        byplot = byplot,
        ci95 = ci95,
        risktable = risktable,
        censored = censored,
        medianline = medianline,
        pplot = pplot,
        calculateRiskScore = calculateRiskScore,
        plotRiskGroups = plotRiskGroups,
        ac = ac,
        adjexplanatory = adjexplanatory,
        ac_method = ac_method,
        use_stratify = use_stratify)

    analysis <- multisurvivalClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\oddsratio.b.R
--------------------------------------------------
Content of R\oddsratio.b.R:
#' @title Odds Ratio Table and Plot
#' @importFrom R6 R6Class
#' @import jmvcore
#'

oddsratioClass <- if (requireNamespace('jmvcore')) R6::R6Class(
    "oddsratioClass",
    inherit = oddsratioBase,
    private = list(
        .run = function() {


            # # Error Message ----
            #
            # if (nrow(self$data) == 0) stop("Data contains no (complete) rows")
            #
            # if ( (is.null(self$options$vars) || is.null(self$options$facs)) && is.null(self$options$target) ) {
            #     # ToDo Message ----
            #     todo <- "
            #         <br>Welcome to ClinicoPath
            #                   <br><br>
            #                   This tool will help you form an Alluvial Plots.
            #                   "
            #     html <- self$results$todo
            #     html$setContent(todo)
            #
            # } else {
            #     todo <- ""
            #     html <- self$results$todo
            #     html$setContent(todo)
            #
            #
            #
            # }







            # If no variable selected Initial Message ----

            if (is.null(self$options$explanatory) || is.null(self$options$outcome))
            {

                # TODO ----

                todo <- glue::glue("
                    <br>Welcome to ClinicoPath
                    <br><br>
                        This tool will help you produce an odds ratio table and plot.
                    <br><br>
                        Explanatory variables can be categorical (ordinal or nominal) or continuous.
                    <br><br>
                        Outcome variable should be coded binary, defining whether the patient is dead or event (recurrence) occured
                    or censored (patient is alive or free of disease) at the last visit.
                    <br><br>
                        Variable names with empty spaces or special characters may not work properly. Consider renaming them.
                    <br><br>
                        This function uses finalfit package. Please cite jamovi and the packages as given below.
                    <br><br>
                    ")

                # https://finalfit.org/articles/all_tables_examples.html#default-1

                html <- self$results$todo
                html$setContent(todo)
                self$results$text$setVisible(FALSE)
                self$results$text2$setVisible(FALSE)
                self$results$plot$setVisible(FALSE)
                return()

            } else {

                # Empty message when all variables selected

                todo <- ""

                # glue::glue("Analysis based on:
                # <br>
                # glm(depdendent ~ explanatory, family='binomial')
                # <br>
                #     ")

                html <- self$results$todo
                html$setContent(todo)


                if (nrow(self$data) == 0)
                    stop('Data contains no (complete) rows')

                mydata <- self$data

                mydata <- jmvcore::naOmit(mydata)


                # histopathology <- jmvReadWrite::read_omv("~/Downloads/histopathology including analysis.omv")

                original_names <- names(mydata)

                # Save original names as a named vector where the names are the original names,
                # and the values are the labels you want to set, which are also the original names.
                labels <- setNames(original_names, original_names)

                # Clean variable names
                mydata <- mydata %>% janitor::clean_names()

                # Now apply the labels to the cleaned names.
                # Since the variable names have been cleaned, you must match the labels to the cleaned names.
                # The labels vector should have names that are the cleaned names and values that are the original names.
                corrected_labels <- setNames(original_names, names(mydata))

                # Apply the corrected labels
                mydata <- labelled::set_variable_labels(
                    .data = mydata,
                    .labels = corrected_labels)

                # Retrieve all variable labels
                all_labels <- labelled::var_label(mydata)

                # Retrieve the variable name from the label
                dependent_variable_name_from_label <- names(all_labels)[all_labels == self$options$outcome]

                # Retrieve the variable names vector from the label vector
                labels <- self$options$explanatory

                explanatory_variable_names <- names(all_labels)[match(labels, all_labels)]


                formulaDependent <- jmvcore::constructFormula(
                    terms = dependent_variable_name_from_label)

                formulaExplanatory <- jmvcore::composeTerms(
                    listOfComponents = explanatory_variable_names
                )

                # formulaExplanatory <- paste0(formulaExplanatory, collapse = " + ")

                # myformula <- paste0(formulaDependent, " ~ ", formulaExplanatory)

                # myformula <- jmvcore::composeFormula(lht = formulaDependent,
                #                                      rht = formulaExplanatory)

                # myformula <- as.formula(myformula)


                finalfit::finalfit(.data = mydata,
                                   dependent = formulaDependent,
                                   explanatory = formulaExplanatory,
                                   # formula = myformula,
                                   metrics = TRUE
                                   ) -> tOdds







                # outcomeLevel <- self$options$outcomeLevel
                # outcome_name <- self$options$outcome

                # outcome1 <- self$data[[outcome_name]]

                # mydata[["outcome2"]] <-
                #     ifelse(
                #         test = outcome1 == outcomeLevel,
                #         yes = "Event",
                #         no = "NoEvent"
                #     )


                # mydata[[outcome_name]] <-
                #     ifelse(
                #         test = outcome1 == outcomeLevel,
                #         yes = "Event",
                #         no = "NoEvent"
                #     )





                # self$results$textmydata$setContent(
                #     list(
                #         outcomeLevel,
                #         outcome_name,
                #         outcome1,
                #         head(mydata)
                #         )
                # )



                # Check if outcome variable is suitable or stop ----
                # myoutcome2 <- self$options$outcome
                # myoutcome2 <- self$data[[myoutcome2]]
                # myoutcome2 <- na.omit(myoutcome2)

                # if (class(myoutcome2) == "factor")
                #     stop("Please use a continuous variable for outcome.")
                #
                # if (any(myoutcome2 != 0 & myoutcome2 != 1))
                #     stop('Outcome variable must only contains 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0.')


                # formula2 <- as.vector(self$options$explanatory)

                # formulaR <- jmvcore::constructFormula(terms =
                #                                           # outcome_name
                #                                       self$options$outcome
                #                                       )

                # formulaR2 <- jmvcore::composeTerm(components = outcome_name)

                # formulaR3 <- as.vector(self$options$outcome)

                # formulaL <- jmvcore::composeTerms(listOfComponents =
                #                                       self$options$explanatory)

                # formulaL <- as.vector(formulaL)


                # formula2 <- jmvcore::constructFormula(terms = formulaL)

                # formulaL2 <- jmvcore::constructFormula(terms =
                #                                       self$options$explanatory)

                # formulaR <- jmvcore::toNumeric(formulaR)


                # glm(depdendent ~ explanatory, family="binomial")

                # finalfit::finalfit(.data = mydata,
                #                    dependent = formulaR,
                #                    explanatory = formula2,
                #                    metrics = TRUE
                #                    ) -> tOdds


                # self$results$textmydata$setContent(
                #     list(
                #         head = head(mydata),
                #         names_data = names(mydata),
                #         all_labels = all_labels,
                #         explanatory_variable_names = explanatory_variable_names,
                #         dependent_variable_name_from_label = dependent_variable_name_from_label,
                #         formulaDependent = formulaDependent,
                #         formulaExplanatory = formulaExplanatory
                #         # formula2 = formula2,
                #         # formulaR = formulaR,
                #         # formulaL = formulaL,
                #         # formulaL2 = formulaL2,
                #         # formulaR3,
                #         ,
                #         tOdds
                #     )
                # )


                text2 <- glue::glue("
                                <br>
                                <b>Model Metrics:</b>
                                  ",
                                unlist(
                                    tOdds[[2]]
                                ),
                                "
                                <br>
                                ")


                self$results$text2$setContent(text2)


                results1 <-  knitr::kable(tOdds[[1]],
                             row.names = FALSE,
                             align = c("l", "l", "r", "r", "r", "r"),
                             format = "html")
                self$results$text$setContent(results1)




                plotData <- list(
                    "plotData" = mydata,
                    "formulaDependent" = formulaDependent,
                    "formulaExplanatory" = formulaExplanatory
                )

                image <- self$results$plot
                image$setState(plotData)
















            }

        }

        ,
                .plot = function(image, ggtheme, theme, ...) {
          # -- the plot function ----
                    # plotData <- image$state
                    if (is.null(self$options$explanatory) || is.null(self$options$outcome))
                return()
                    if (nrow(self$data) == 0)
                stop('Data contains no (complete) rows')
            # Check if outcome variable is suitable or stop ----
            # myoutcome2 <- self$options$outcome
            # myoutcome2 <- self$data[[myoutcome2]]
            # myoutcome2 <- na.omit(myoutcome2)
                    # if (class(myoutcome2) == "factor")
            #     stop("Please use a continuous variable for outcome.")
            #
            #
            # if (any(myoutcome2 != 0 & myoutcome2 != 1))
            #     stop('Outcome variable must only contains 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0.')
                    # mydata <- self$data
                    # formula2 <- jmvcore::constructFormula(terms = self$options$explanatory)
                    # formulaR <- jmvcore::constructFormula(terms = self$options$outcome)
                    # formulaR <- jmvcore::toNumeric(formulaR)
                    # https://finalfit.org/reference/or_plot.html

                    plotList <- image$state

                    mydata <- plotList$plotData
                    formulaDependent <- plotList$formulaDependent
                    formulaExplanatory <- plotList$formulaExplanatory

                    plot <-
                        # finalfit::or_plot(
                        finalfit::ff_plot(
                            .data = mydata,
                            dependent = formulaDependent,
                            explanatory = formulaExplanatory,
                            remove_ref = FALSE,
                            table_text_size = 4,
                            title_text_size = 14,
                            random_effect = NULL,
                            factorlist = NULL,
                            glmfit = NULL,
                            confint_type = NULL,
                            breaks = NULL,
                            column_space = c(-0.5, 0, 0.5),
                            dependent_label = self$options$outcome,
                            prefix = "",
                            suffix = ": OR (95% CI, p-value)",
                            table_opts = NULL,
                            plot_opts = list(
                                ggplot2::xlab("OR, 95% CI"),
                                ggplot2::theme(
                                    axis.title = ggplot2::element_text(size = 12)
                                )
                            )
                        )


                    print(plot)
            TRUE
        }



#         ,
#
#         .plot2 = function(image, ggtheme, theme, ...) {  # <-- the plot function ----
#
#             # plotData <- image$state
#
#             if (nrow(self$data) == 0)
#                 stop('Data contains no (complete) rows')
#
#             if (is.null(self$options$explanatory) || is.null(self$options$outcome))
#                 return()
#
#             # Check if outcome variable is suitable or stop ----
#             myoutcome2 <- self$options$outcome
#             myoutcome2 <- self$data[[myoutcome2]]
#             myoutcome2 <- na.omit(myoutcome2)
#
#             if (class(myoutcome2) == "factor")
#                 stop("Please use a continuous variable for outcome.")
#
#             if (any(myoutcome2 != 0 & myoutcome2 != 1))
#                 stop('Outcome variable must only contains 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0.')
#
#
#
#
#             mydata <- self$data
#
#             formula2 <- jmvcore::constructFormula(terms = self$options$explanatory)
#
#             formulaR <- jmvcore::constructFormula(terms = self$options$outcome)
#
#             formulaR <- jmvcore::toNumeric(formulaR)
#
#             formula <- paste0(formula2, ' ~ ', formulaR)
#
#             formula <- as.formula(formula)
#
#             # https://indrajeetpatil.github.io/ggstatsplot/articles/web_only/ggcoefstats.html#generalized-linear-model-glm-
#
#
#         # model
#         mod <-
#             stats::glm(
#                 formula = formula,
#                 data = mydata,
#                 # weights = df$Freq,
#                 family = stats::binomial(link = "logit")
#             )
#
#         # plot
#         plot <- ggstatsplot::ggcoefstats(
#             x = mod,
#             ggtheme = ggthemes::theme_economist_white(),
#             ggstatsplot.layer = FALSE,
#             title = "generalized linear model (glm)",
#             vline.args = list(color = "red", linetype = "solid"),
#             stats.label.color = c("orangered", "dodgerblue")
#         )
#
#         print(plot)
#         TRUE
#
# }
#
#






        )
)


File: R\oddsratio.h.R
--------------------------------------------------
Content of R\oddsratio.h.R:

# This file is automatically generated, you probably don't want to edit this

oddsratioOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "oddsratioOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            explanatory = NULL,
            outcome = NULL, ...) {

            super$initialize(
                package="jsurvival",
                name="oddsratio",
                requiresData=TRUE,
                ...)

            private$..explanatory <- jmvcore::OptionVariables$new(
                "explanatory",
                explanatory,
                suggested=list(
                    "nominal",
                    "continuous"),
                permitted=list(
                    "factor",
                    "numeric"))
            private$..outcome <- jmvcore::OptionVariable$new(
                "outcome",
                outcome,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))

            self$.addOption(private$..explanatory)
            self$.addOption(private$..outcome)
        }),
    active = list(
        explanatory = function() private$..explanatory$value,
        outcome = function() private$..outcome$value),
    private = list(
        ..explanatory = NA,
        ..outcome = NA)
)

oddsratioResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "oddsratioResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        text = function() private$.items[["text"]],
        text2 = function() private$.items[["text2"]],
        plot = function() private$.items[["plot"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Odds Ratio Table and Plot",
                refs=list(
                    "finalfit",
                    "survivaltutorial",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do",
                clearWith=list(
                    "explanatory",
                    "outcome")))
            self$add(jmvcore::Html$new(
                options=options,
                name="text",
                title="Odds Ratio Table",
                clearWith=list(
                    "explanatory",
                    "outcome")))
            self$add(jmvcore::Html$new(
                options=options,
                name="text2",
                title=""))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot",
                title="Odds Ratio Plot",
                width=600,
                height=450,
                renderFun=".plot",
                requiresData=TRUE,
                clearWith=list(
                    "explanatory",
                    "outcome")))}))

oddsratioBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "oddsratioBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "jsurvival",
                name = "oddsratio",
                version = c(1,0,0),
                options = options,
                results = oddsratioResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Odds Ratio Table and Plot
#'
#' Function for Odds Ratio Table and Plot.
#'
#' @examples
#' \donttest{
#' # example will be added
#'}
#' @param data The data as a data frame.
#' @param explanatory The explanatory variables to be used in the analysis.
#' @param outcome The outcome variable to be used in the analysis.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$text} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$text2} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$plot} \tab \tab \tab \tab \tab an image \cr
#' }
#'
#' @export
oddsratio <- function(
    data,
    explanatory,
    outcome) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("oddsratio requires jmvcore to be installed (restart may be required)")

    if ( ! missing(explanatory)) explanatory <- jmvcore::resolveQuo(jmvcore::enquo(explanatory))
    if ( ! missing(outcome)) outcome <- jmvcore::resolveQuo(jmvcore::enquo(outcome))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(explanatory), explanatory, NULL),
            `if`( ! missing(outcome), outcome, NULL))

    for (v in outcome) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- oddsratioOptions$new(
        explanatory = explanatory,
        outcome = outcome)

    analysis <- oddsratioClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\singlearm.b.R
--------------------------------------------------
Content of R\singlearm.b.R:
#' @title Single Arm Survival
#' @importFrom R6 R6Class
#' @import jmvcore
#' @import magrittr
#'
#' @description
#' This function prepares and cleans data for single-arm survival analysis by
#' calculating survival time, filtering based on landmark time, and merging
#' survival outcomes with other factors.
#'
#' @return A list containing cleaned data and metadata for plotting and analysis.
#' @note Ensure the input data contains the required variables (elapsed time,
#' outcome) and meets specified formatting criteria.


singlearmClass <- if (requireNamespace('jmvcore', quietly=TRUE)) R6::R6Class(
    "singlearmClass",
    inherit = singlearmBase,
    private = list(


      # get and label Data ----
      .getData = function() {

        mydata <- self$data

        mydata$row_names <- rownames(mydata)

        original_names <- names(mydata)

        labels <- setNames(original_names, original_names)

        mydata <- mydata %>% janitor::clean_names()

        corrected_labels <-
          setNames(original_names, names(mydata))

        mydata <- labelled::set_variable_labels(.data = mydata,
                                                .labels = corrected_labels)

        all_labels <- labelled::var_label(mydata)


        mytime <-
          names(all_labels)[all_labels == self$options$elapsedtime]

        myoutcome <-
          names(all_labels)[all_labels == self$options$outcome]

        mydxdate <-
          names(all_labels)[all_labels == self$options$dxdate]

        myfudate <-
          names(all_labels)[all_labels == self$options$fudate]

        return(list(
          "mydata_labelled" = mydata
          , "mytime_labelled" = mytime
          , "myoutcome_labelled" = myoutcome
          , "mydxdate_labelled" = mydxdate
          , "myfudate_labelled" = myfudate
        ))


      }

      # todo ----
      ,
      .todo = function() {

        todo <- glue::glue(
          "
                <br>Welcome to ClinicoPath
                <br><br>
                This tool will help you calculate median survivals and 1,3,5-yr survivals for your whole population.
                <br><br>
                Select outcome level from Outcome variable.
                <br><br>
                Outcome Level: if patient is dead or event (recurrence) occured. You may also use advanced outcome options depending on your analysis type.
                <br><br>
                Survival time should be numeric and continuous. You may also use dates to calculate survival time in advanced elapsed time options.
                <br><br>
                This function uses survival, survminer, and finalfit packages. Please cite jamovi and the packages as given below.
                <br><hr>
                <br>
                See details for survival <a href = 'https://cran.r-project.org/web/packages/survival/vignettes/survival.pdf'>here</a>.",


            "<b>Welcome to Single-Arm Survival Analysis!</b><br><br>
            This tool calculates <b>median survival</b> and <b>1-, 3-, 5-year survival rates</b>
            for a single group.<br>
            <ul>
            <li><b>Median Survival:</b> The time by which 50% of subjects have experienced the event.</li>
            <li><b>1-, 3-, 5-Year Survival:</b> Proportion of subjects surviving at these milestones.</li>
            </ul>
            <br><b>Key Features:</b><br>
            <ul>
            <li>Use dates or elapsed time to calculate survival.</li>
            <li>Adjust results with landmark times.</li>
            <li>Generate survival and cumulative hazard plots.</li>
            </ul>
            <br>Please cite jamovi and relevant packages (survival, survminer) in your publications.<br>
            "


        )

        html <- self$results$todo
        html$setContent(todo)

      }


      # Define Survival Time ----
      ,
      .definemytime = function() {

        ## Read Labelled Data ----

        labelled_data <- private$.getData()

        mydata <- labelled_data$mydata_labelled
        mytime_labelled <- labelled_data$mytime_labelled
        mydxdate_labelled <- labelled_data$mydxdate_labelled
        myfudate_labelled <- labelled_data$myfudate_labelled

        tint <- self$options$tint


        if (!tint) {
          ## Precalculated Time ----

          mydata[["mytime"]] <-
            jmvcore::toNumeric(mydata[[mytime_labelled]])


        } else if (tint) {
          ## Time Interval ----

          dxdate <- mydxdate_labelled # self$options$dxdate
          fudate <- myfudate_labelled #self$options$fudate
          timetypedata <- self$options$timetypedata


          # # Define a mapping from timetypedata to lubridate functions
          # lubridate_functions <- list(
          #     ymdhms = lubridate::ymd_hms,
          #     ymd = lubridate::ymd,
          #     ydm = lubridate::ydm,
          #     mdy = lubridate::mdy,
          #     myd = lubridate::myd,
          #     dmy = lubridate::dmy,
          #     dym = lubridate::dym
          # )
          # # Apply the appropriate lubridate function based on timetypedata
          # if (timetypedata %in% names(lubridate_functions)) {
          #     func <- lubridate_functions[[timetypedata]]
          #     mydata[["start"]] <- func(mydata[[dxdate]])
          #     mydata[["end"]] <- func(mydata[[fudate]])
          # }


          if (timetypedata == "ymdhms") {
            mydata[["start"]] <- lubridate::ymd_hms(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::ymd_hms(mydata[[fudate]])
          }
          if (timetypedata == "ymd") {
            mydata[["start"]] <- lubridate::ymd(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::ymd(mydata[[fudate]])
          }
          if (timetypedata == "ydm") {
            mydata[["start"]] <- lubridate::ydm(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::ydm(mydata[[fudate]])
          }
          if (timetypedata == "mdy") {
            mydata[["start"]] <- lubridate::mdy(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::mdy(mydata[[fudate]])
          }
          if (timetypedata == "myd") {
            mydata[["start"]] <- lubridate::myd(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::myd(mydata[[fudate]])
          }
          if (timetypedata == "dmy") {
            mydata[["start"]] <- lubridate::dmy(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::dmy(mydata[[fudate]])
          }
          if (timetypedata == "dym") {
            mydata[["start"]] <- lubridate::dym(mydata[[dxdate]])
            mydata[["end"]] <-
              lubridate::dym(mydata[[fudate]])
          }



          if ( sum(!is.na(mydata[["start"]])) == 0 || sum(!is.na(mydata[["end"]])) == 0)  {
            stop(paste0("Time difference cannot be calculated. Make sure that time type in variables are correct. Currently it is: ", self$options$timetypedata)
            )
          }


          timetypeoutput <-
            jmvcore::constructFormula(terms = self$options$timetypeoutput)


          mydata <- mydata %>%
            dplyr::mutate(interval = lubridate::interval(start, end))


          # self$results$mydataview$setContent(
          #     list(
          #       "mydata" = head(mydata),
          #       "start" = sum(!is.na(mydata[["start"]])),
          #       "end" = sum(!is.na(mydata[["end"]]))
          #     )
          # )

          mydata <- mydata %>%
            dplyr::mutate(mytime = lubridate::time_length(interval, timetypeoutput))


        }


        df_time <- mydata %>% jmvcore::select(c("row_names", "mytime"))



        return(df_time)


      }

      # Define Outcome ----
      ,
      .definemyoutcome = function() {


        labelled_data <- private$.getData()

        mydata <- labelled_data$mydata_labelled
        myoutcome_labelled <- labelled_data$myoutcome_labelled


        contin <- c("integer", "numeric", "double")

        outcomeLevel <- self$options$outcomeLevel
        multievent <- self$options$multievent

        outcome1 <- mydata[[myoutcome_labelled]]

        if (!multievent) {
          if (inherits(outcome1, contin)) {
            if (!((length(unique(
              outcome1[!is.na(outcome1)]
            )) == 2) && (sum(unique(
              outcome1[!is.na(outcome1)]
            )) == 1))) {
              stop(
                'When using continuous variable as an outcome, it must only contain 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0.'
              )

            }

            mydata[["myoutcome"]] <- mydata[[myoutcome_labelled]]
            # mydata[[self$options$outcome]]

          } else if (inherits(outcome1, "factor")) {
            mydata[["myoutcome"]] <-
              ifelse(
                test = outcome1 == outcomeLevel,
                yes = 1,
                no = 0
              )

          } else {
            stop(
              'When using continuous variable as an outcome, it must only contain 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0. If you are using a factor as an outcome, please check the levels and content.'
            )

          }

        } else if (multievent) {
          analysistype <- self$options$analysistype

          dod <- self$options$dod
          dooc <- self$options$dooc
          awd <- self$options$awd
          awod <- self$options$awod

          if (analysistype == 'overall') {
            # Overall ----
            # (Alive) <=> (Dead of Disease & Dead of Other Causes)


            mydata[["myoutcome"]] <- NA_integer_

            mydata[["myoutcome"]][outcome1 == awd] <- 0
            mydata[["myoutcome"]][outcome1 == awod] <- 0
            mydata[["myoutcome"]][outcome1 == dod] <- 1
            mydata[["myoutcome"]][outcome1 == dooc] <- 1



          } else if (analysistype == 'cause') {
            # Cause Specific ----
            # (Alive & Dead of Other Causes) <=> (Dead of Disease)


            mydata[["myoutcome"]] <- NA_integer_

            mydata[["myoutcome"]][outcome1 == awd] <- 0
            mydata[["myoutcome"]][outcome1 == awod] <- 0
            mydata[["myoutcome"]][outcome1 == dod] <- 1
            mydata[["myoutcome"]][outcome1 == dooc] <- 0

          } else if (analysistype == 'compete') {
            # Competing Risks ----
            # Alive <=> Dead of Disease accounting for Dead of Other Causes

            # https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#part_3:_competing_risks


            mydata[["myoutcome"]] <- NA_integer_

            mydata[["myoutcome"]][outcome1 == awd] <- 0
            mydata[["myoutcome"]][outcome1 == awod] <- 0
            mydata[["myoutcome"]][outcome1 == dod] <- 1
            mydata[["myoutcome"]][outcome1 == dooc] <- 2

          }

        }

        df_outcome <- mydata %>% jmvcore::select(c("row_names", "myoutcome"))

        return(df_outcome)

      }


      # Define Factor ----
      ,
      .definemyfactor = function() {


        labelled_data <- private$.getData()

        mydata_labelled <- labelled_data$mydata_labelled

        mydata <- mydata_labelled

        mydata[["myfactor"]] <- "1"


        df_factor <- mydata %>% jmvcore::select(c("row_names","myfactor"))

        return(df_factor)

      }


      # Clean Data For Analysis ----
      ,
      .cleandata = function() {

        labelled_data <- private$.getData()

        mydata_labelled        <- labelled_data$mydata_labelled
        mytime_labelled        <- labelled_data$mytime_labelled
        myoutcome_labelled     <- labelled_data$myoutcome_labelled
        mydxdate_labelled      <- labelled_data$mydxdate_labelled
        myfudate_labelled      <- labelled_data$myfudate_labelled

        time <- private$.definemytime()
        outcome <- private$.definemyoutcome()
        factor <- private$.definemyfactor()

        cleanData <- dplyr::left_join(time, outcome, by = "row_names") %>%
          dplyr::left_join(factor, by = "row_names")

        # Landmark ----
        # https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#landmark_method
        if (self$options$uselandmark) {

          landmark <- jmvcore::toNumeric(self$options$landmark)

          cleanData <- cleanData %>%
            dplyr::filter(mytime >= landmark) %>%
            dplyr::mutate(mytime = mytime - landmark)
        }

        # Time Dependent Covariate ----
        # https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#time-dependent_covariate




        # Names cleanData ----

        if (self$options$tint) {
          name1time <- "CalculatedTime"
        }

        if (!self$options$tint &&
            !is.null(self$options$elapsedtime)) {
          name1time <- mytime_labelled
        }

        name2outcome <- myoutcome_labelled

        if (self$options$multievent) {
          name2outcome <- "CalculatedOutcome"
        }


        name3explanatory <- "SingleArm"

        cleanData <- cleanData %>%
          dplyr::rename(
            !!name1time := mytime,
            !!name2outcome := myoutcome,
            !!name3explanatory := myfactor
          )

        # naOmit ----

        cleanData <- jmvcore::naOmit(cleanData)


        # Prepare Data For Plots ----

        plotData <- list(
          "name1time" = name1time,
          "name2outcome" = name2outcome,
          "name3explanatory" = name3explanatory,
          "cleanData" = cleanData
        )

        image <- self$results$plot
        image$setState(plotData)

        image2 <- self$results$plot2
        image2$setState(plotData)

        image3 <- self$results$plot3
        image3$setState(plotData)

        image6 <- self$results$plot6
        image6$setState(plotData)

        # Return Data ----

        return(
          list(
            "name1time" = name1time,
            "name2outcome" = name2outcome,
            "name3explanatory" = name3explanatory,
            "cleanData" = cleanData,
            "mytime_labelled" = mytime_labelled,
            "myoutcome_labelled" = myoutcome_labelled,
            "mydxdate_labelled" = mydxdate_labelled,
            "myfudate_labelled" = myfudate_labelled
          )
        )

      }


      # Run Analysis ----
      ,
      .run = function() {

        # Errors, Warnings ----

        ## No variable todo ----

        ### Define subconditions ----

        subcondition1a <- !is.null(self$options$outcome)
        subcondition1b1 <- self$options$multievent
        subcondition1b2 <- !is.null(self$options$dod)
        subcondition1b3 <- !is.null(self$options$dooc)
        # subcondition1b4 <- !is.null(self$options$awd)
        # subcondition1b5 <- !is.null(self$options$awod)
        subcondition2a <- !is.null(self$options$elapsedtime)
        subcondition2b1 <- self$options$tint
        subcondition2b2 <- !is.null(self$options$dxdate)
        subcondition2b3 <- !is.null(self$options$fudate)

        condition1 <- subcondition1a && !subcondition1b1 || subcondition1b1 && subcondition1b2 || subcondition1b1 && subcondition1b3

        condition2 <- subcondition2b1 && subcondition2b2 && subcondition2b3 || subcondition2a && !subcondition2b1 && !subcondition2b2 && !subcondition2b3


        not_continue_analysis <- !(condition1 && condition2)

        if (not_continue_analysis) {
          private$.todo()
          self$results$medianSummary$setVisible(FALSE)
          self$results$medianTable$setVisible(FALSE)
          self$results$survTableSummary$setVisible(FALSE)
          self$results$survTable$setVisible(FALSE)
          self$results$plot$setVisible(FALSE)
          self$results$plot2$setVisible(FALSE)
          self$results$plot3$setVisible(FALSE)
          self$results$plot6$setVisible(FALSE)
          self$results$todo$setVisible(TRUE)
          return()
        } else {
          self$results$todo$setVisible(FALSE)
        }

        ## Empty data ----

        if (nrow(self$data) == 0)
          stop('Data contains no (complete) rows')

        ## Get Clean Data ----
        results <- private$.cleandata()

        ## Run Analysis ----

        ### Median Survival ----
        private$.medianSurv(results)


        ### Survival Table ----
        private$.survTable(results)

        ## Add Calculated Time to Data ----

        # self$results$mydataview$setContent(
        #     list(
        #         head(results$cleanData)
        #     )
        # )


        if ( self$options$tint && self$options$calculatedtime && self$results$calculatedtime$isNotFilled()) {
          self$results$calculatedtime$setRowNums(results$cleanData$row_names)
          self$results$calculatedtime$setValues(results$cleanData$CalculatedTime)
        }


        ## Add Redefined Outcome to Data ----

        if (self$options$multievent  && self$options$outcomeredefined && self$results$outcomeredefined$isNotFilled()) {
          self$results$outcomeredefined$setRowNums(results$cleanData$row_names)
          self$results$outcomeredefined$setValues(results$cleanData$CalculatedOutcome)
        }
      }

      # Median Survival Function ----
      ,
      .medianSurv = function(results) {
        mytime <- results$name1time
        myoutcome <- results$name2outcome
        myfactor <- results$name3explanatory

        mydata <- results$cleanData

        mydata[[mytime]] <-
          jmvcore::toNumeric(mydata[[mytime]])

        ## Median Survival Table ----

        formula <-
          paste('survival::Surv(',
                mytime,
                ',',
                myoutcome,
                ') ~ ',
                myfactor)

        formula <- as.formula(formula)

        km_fit <- survival::survfit(formula, data = mydata)

        km_fit_median_df <- summary(km_fit)


        # medianSummary2 <-
        #   as.data.frame(km_fit_median_df$table)
        # self$results$medianSummary2$setContent(medianSummary2)



        results1html <-
          as.data.frame(km_fit_median_df$table) %>%
          t() %>%
          as.data.frame() %>%
          janitor::clean_names(dat = ., case = "snake")

        results1table <- results1html


        medianTable <- self$results$medianTable
        data_frame <- results1table
        data_frame <- data_frame %>%
          dplyr::mutate(mean_time = round(rmean, 2),
                        mean_ci = glue::glue("{round(lower, 2)} - {round(upper, 2)}"))
        for (i in seq_along(data_frame[, 1, drop = T])) {
          medianTable$addRow(rowKey = i, values = c(data_frame[i,]))
        }


        ## Median Survival Summary ----

        results1table %>%
          dplyr::mutate(
            description =
              glue::glue(
                "Median survival is {round(median, digits = 1)} [{round(x0_95lcl, digits = 1)} - {round(x0_95ucl, digits = 1)}, 95% CI] ",
                self$options$timetypeoutput,
                ".",
                "The median survival is {round(median, 2)} months [95% CI: {round(lower, 2)} - {round(upper, 2)}].
       At 1 year, survival is approximately {scales::percent(surv_12)},
       and at 5 years, it is {scales::percent(surv_60)}."
              )
          ) %>%
          # dplyr::mutate(
          #   description = dplyr::case_when(
          #     is.na(median) ~ paste0(
          #       glue::glue("{description} \n Note that when {factor}, the survival curve does not drop below 1/2 during \n the observation period, thus the median survival is undefined.")),
          #     TRUE ~ paste0(description)
          #   )
          # ) %>%
          # dplyr::mutate(description = gsub(
          #   pattern = "=",
          #   replacement = " is ",
          #   x = description
          # )) %>%
          # dplyr::mutate(description = gsub(
          #   pattern = myexplanatory_labelled,
          #   replacement = self$options$explanatory,
          #   x = description
          # )) %>%
          dplyr::select(description) %>%
          dplyr::pull(.) -> km_fit_median_definition


        medianSummary <- c(km_fit_median_definition,
                           "The median survival time is when 50% of subjects have experienced the event.",
                           "This means that 50% of subjects in this group survived longer than this time period."
        )


        self$results$medianSummary$setContent(medianSummary)


      }


      # Survival Table Function ----
      ,
      .survTable = function(results) {
        mytime <- results$name1time
        myoutcome <- results$name2outcome
        myfactor <- results$name3explanatory

        mydata <- results$cleanData

        mydata[[mytime]] <-
          jmvcore::toNumeric(mydata[[mytime]])

        ## Median Survival Table ----

        formula <-
          paste('survival::Surv(',
                mytime,
                ',',
                myoutcome,
                ') ~ ',
                myfactor)

        formula <- as.formula(formula)

        km_fit <- survival::survfit(formula, data = mydata)

        utimes <- self$options$cutp

        utimes <- strsplit(utimes, ",")
        utimes <- purrr::reduce(utimes, as.vector)
        utimes <- as.numeric(utimes)

        if (length(utimes) == 0) {
          utimes <- c(12, 36, 60)
        }

        km_fit_summary <- summary(km_fit, times = utimes, extend = TRUE)

        km_fit_df <-
          as.data.frame(km_fit_summary[c(
            #"strata",
                                         "time",
                                         "n.risk",
                                         "n.event",
                                         "surv",
                                         "std.err",
                                         "lower",
                                         "upper")])

        # self$results$tableview$setContent(km_fit_df)


        # km_fit_df[, 1] <- gsub(
        #   pattern = "thefactor=",
        #   replacement = paste0(self$options$explanatory, " "),
        #   x = km_fit_df[, 1]
        # )


        # km_fit_df2 <- km_fit_df

        # km_fit_df[, 1] <- gsub(
        #   pattern = paste0(myexplanatory_labelled,"="),
        #   replacement = paste0(self$options$explanatory, " "),
        #   x = km_fit_df[, 1]
        # )

        survTable <- self$results$survTable

        data_frame <- km_fit_df
        for (i in seq_along(data_frame[, 1, drop = T])) {
          survTable$addRow(rowKey = i, values = c(data_frame[i,]))
        }


        ## survTableSummary 1,3,5-yr survival summary ----

        # km_fit_df2[, 1] <- gsub(
        #   pattern = paste0(myexplanatory_labelled,"="),
        #   replacement = paste0(self$options$explanatory, " is "),
        #   x = km_fit_df2[, 1]
        # )

        ## survTableSummary 1,3,5-yr survival summary ----

        km_fit_df %>%
          dplyr::mutate(
            description =
              glue::glue(
                "{time} month survival is {scales::percent(surv)} [{scales::percent(lower)}-{scales::percent(upper)}, 95% CI]. \n The estimated probability of surviving beyond {time} months was {scales::percent(surv)} [{scales::percent(lower)}-{scales::percent(upper)}, 95% CI]. \n At this time point, there were {n.risk} subjects still at risk and {n.event} events had occurred in this group."
              )
          ) %>%
          dplyr::select(description) %>%
          dplyr::pull(.) -> survTableSummary



        self$results$survTableSummary$setContent(survTableSummary)


      }


      # Survival Curve ----
      ,
      .plot = function(image, ggtheme, theme, ...) {
        sc <- self$options$sc

        if (!sc)
          return()

        results <- image$state

        if (is.null(results)) {
          return()
        }

        mytime <- results$name1time
        mytime <- jmvcore::constructFormula(terms = mytime)

        myoutcome <- results$name2outcome
        myoutcome <-
          jmvcore::constructFormula(terms = myoutcome)


        myfactor <- results$name3explanatory
        myfactor <-
        jmvcore::constructFormula(terms = myfactor)

        plotData <- results$cleanData

        plotData[[mytime]] <-
          jmvcore::toNumeric(plotData[[mytime]])

        myformula <-
          paste("survival::Surv(", mytime, ",", myoutcome, ")")



        plot <- plotData %>%
          finalfit::surv_plot(
            .data = .,
            dependent = myformula,
            explanatory = myfactor,
            xlab = paste0('Time (', self$options$timetypeoutput, ')'),
            # pval = TRUE,
            # pval.method	= TRUE,
            legend = 'none',
            break.time.by = self$options$byplot,
            xlim = c(0, self$options$endplot),
            ylim = c(
              self$options$ybegin_plot,
              self$options$yend_plot),
            title = "Survival of the Whole Group",
            subtitle = "Based on Kaplan-Meier estimates",
            risk.table = self$options$risktable,
            conf.int = self$options$ci95,
            censor = self$options$censored,
            surv.median.line = self$options$medianline

          )

        # plot <- plot + ggtheme

        print(plot)
        TRUE

      }



      # Cumulative Events ----
      # https://rpkgs.datanovia.com/survminer/survminer_cheatsheet.pdf
      ,
      .plot2 = function(image2, ggtheme, theme, ...) {
        ce <- self$options$ce

        if (!ce)
          return()

        results <- image2$state

        if (is.null(results)) {
          return()
        }

        mytime <- results$name1time
        mytime <- jmvcore::constructFormula(terms = mytime)

        myoutcome <- results$name2outcome
        myoutcome <-
          jmvcore::constructFormula(terms = myoutcome)


        myfactor <- results$name3explanatory
        myfactor <-
        jmvcore::constructFormula(terms = myfactor)

        plotData <- results$cleanData

        plotData[[mytime]] <-
          jmvcore::toNumeric(plotData[[mytime]])

        myformula <-
          paste("survival::Surv(", mytime, ",", myoutcome, ")")


        plot2 <- plotData %>%
          finalfit::surv_plot(
            .data = .,
            dependent = myformula,
            explanatory = myfactor,
            xlab = paste0('Time (', self$options$timetypeoutput, ')'),
            # pval = self$options$pplot,
            # pval.method	= self$options$pplot,
            legend = 'none',
            break.time.by = self$options$byplot,
            xlim = c(0, self$options$endplot),
            ylim = c(
              self$options$ybegin_plot,
              self$options$yend_plot),
            title = "Cumulative Events of the Whole Group",
            fun = "event",
            risk.table = self$options$risktable,
            conf.int = self$options$ci95,
            censor = self$options$censored,
            surv.median.line = self$options$medianline
          )

        print(plot2)
        TRUE

      }



      # Cumulative Hazard ----
      ,
      .plot3 = function(image3, ggtheme, theme, ...) {
        ch <- self$options$ch

        if (!ch)
          return()

        results <- image3$state

        if (is.null(results)) {
          return()
        }

        mytime <- results$name1time
        mytime <- jmvcore::constructFormula(terms = mytime)

        myoutcome <- results$name2outcome
        myoutcome <-
          jmvcore::constructFormula(terms = myoutcome)


        myfactor <- results$name3explanatory
        myfactor <-
        jmvcore::constructFormula(terms = myfactor)

        plotData <- results$cleanData

        plotData[[mytime]] <-
          jmvcore::toNumeric(plotData[[mytime]])

        myformula <-
          paste("survival::Surv(", mytime, ",", myoutcome, ")")


        plot3 <- plotData %>%
          finalfit::surv_plot(
            .data = .,
            dependent = myformula,
            explanatory = myfactor,
            xlab = paste0('Time (', self$options$timetypeoutput, ')'),
            # pval = self$options$pplot,
            # pval.method	= self$options$pplot,
            legend = 'none',
            break.time.by = self$options$byplot,
            xlim = c(0, self$options$endplot),
            ylim = c(
              self$options$ybegin_plot,
              self$options$yend_plot),
            title = "Cumulative Hazard of the Whole Group",
            fun = "cumhaz",
            risk.table = self$options$risktable,
            conf.int = self$options$ci95,
            censor = self$options$censored,
            surv.median.line = self$options$medianline
          )


        print(plot3)
        TRUE
      }


      # KMunicate Style ----
      ,
      .plot6 = function(image6, ggtheme, theme, ...) {
        kmunicate <- self$options$kmunicate

        if (!kmunicate)
          return()

        results <- image6$state

        if (is.null(results)) {
          return()
        }

        mytime <- results$name1time
        mytime <- jmvcore::constructFormula(terms = mytime)

        myoutcome <- results$name2outcome
        myoutcome <-
          jmvcore::constructFormula(terms = myoutcome)


        myfactor <- results$name3explanatory
        myfactor <-
          jmvcore::constructFormula(terms = myfactor)

        plotData <- results$cleanData

        plotData[[mytime]] <-
          jmvcore::toNumeric(plotData[[mytime]])


        title2 <- "Single Arm Survival"


        myformula <-
          paste('survival::Surv(',
                mytime,
                ',',
                myoutcome,
                ') ~ ',
                myfactor)

        myformula <- as.formula(myformula)

        km_fit <-
          survival::survfit(myformula, data = plotData)

        time_scale <-
          seq(0, self$options$endplot, by = self$options$byplot)


        plot6 <-
          KMunicate::KMunicate(
            fit = km_fit,
            time_scale = time_scale,
            .xlab = paste0('Time in ', self$options$timetypeoutput)
          )


        print(plot6)
        TRUE

      }


    )
  )


File: R\singlearm.h.R
--------------------------------------------------
Content of R\singlearm.h.R:

# This file is automatically generated, you probably don't want to edit this

singlearmOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "singlearmOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            elapsedtime = NULL,
            tint = FALSE,
            dxdate = NULL,
            fudate = NULL,
            outcome = NULL,
            outcomeLevel = NULL,
            dod = NULL,
            dooc = NULL,
            awd = NULL,
            awod = NULL,
            analysistype = "overall",
            cutp = "12, 36, 60",
            timetypedata = "ymd",
            timetypeoutput = "months",
            uselandmark = FALSE,
            landmark = 3,
            sc = FALSE,
            kmunicate = FALSE,
            ce = FALSE,
            ch = FALSE,
            endplot = 60,
            ybegin_plot = 0,
            yend_plot = 1,
            byplot = 12,
            multievent = FALSE,
            ci95 = FALSE,
            risktable = FALSE,
            censored = FALSE,
            medianline = "none", ...) {

            super$initialize(
                package="jsurvival",
                name="singlearm",
                requiresData=TRUE,
                ...)

            private$..elapsedtime <- jmvcore::OptionVariable$new(
                "elapsedtime",
                elapsedtime,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..tint <- jmvcore::OptionBool$new(
                "tint",
                tint,
                default=FALSE)
            private$..dxdate <- jmvcore::OptionVariable$new(
                "dxdate",
                dxdate)
            private$..fudate <- jmvcore::OptionVariable$new(
                "fudate",
                fudate)
            private$..calculatedtime <- jmvcore::OptionOutput$new(
                "calculatedtime")
            private$..outcome <- jmvcore::OptionVariable$new(
                "outcome",
                outcome,
                suggested=list(
                    "ordinal",
                    "nominal",
                    "continuous"),
                permitted=list(
                    "factor",
                    "numeric"))
            private$..outcomeLevel <- jmvcore::OptionLevel$new(
                "outcomeLevel",
                outcomeLevel,
                variable="(outcome)")
            private$..dod <- jmvcore::OptionLevel$new(
                "dod",
                dod,
                variable="(outcome)",
                allowNone=TRUE)
            private$..dooc <- jmvcore::OptionLevel$new(
                "dooc",
                dooc,
                variable="(outcome)",
                allowNone=TRUE)
            private$..awd <- jmvcore::OptionLevel$new(
                "awd",
                awd,
                variable="(outcome)",
                allowNone=TRUE)
            private$..awod <- jmvcore::OptionLevel$new(
                "awod",
                awod,
                variable="(outcome)",
                allowNone=TRUE)
            private$..analysistype <- jmvcore::OptionList$new(
                "analysistype",
                analysistype,
                options=list(
                    "overall",
                    "cause",
                    "compete"),
                default="overall")
            private$..outcomeredefined <- jmvcore::OptionOutput$new(
                "outcomeredefined")
            private$..cutp <- jmvcore::OptionString$new(
                "cutp",
                cutp,
                default="12, 36, 60")
            private$..timetypedata <- jmvcore::OptionList$new(
                "timetypedata",
                timetypedata,
                options=list(
                    "ymdhms",
                    "ymd",
                    "ydm",
                    "mdy",
                    "myd",
                    "dmy",
                    "dym"),
                default="ymd")
            private$..timetypeoutput <- jmvcore::OptionList$new(
                "timetypeoutput",
                timetypeoutput,
                options=list(
                    "days",
                    "weeks",
                    "months",
                    "years"),
                default="months")
            private$..uselandmark <- jmvcore::OptionBool$new(
                "uselandmark",
                uselandmark,
                default=FALSE)
            private$..landmark <- jmvcore::OptionInteger$new(
                "landmark",
                landmark,
                default=3)
            private$..sc <- jmvcore::OptionBool$new(
                "sc",
                sc,
                default=FALSE)
            private$..kmunicate <- jmvcore::OptionBool$new(
                "kmunicate",
                kmunicate,
                default=FALSE)
            private$..ce <- jmvcore::OptionBool$new(
                "ce",
                ce,
                default=FALSE)
            private$..ch <- jmvcore::OptionBool$new(
                "ch",
                ch,
                default=FALSE)
            private$..endplot <- jmvcore::OptionInteger$new(
                "endplot",
                endplot,
                default=60)
            private$..ybegin_plot <- jmvcore::OptionNumber$new(
                "ybegin_plot",
                ybegin_plot,
                default=0)
            private$..yend_plot <- jmvcore::OptionNumber$new(
                "yend_plot",
                yend_plot,
                default=1)
            private$..byplot <- jmvcore::OptionInteger$new(
                "byplot",
                byplot,
                default=12)
            private$..multievent <- jmvcore::OptionBool$new(
                "multievent",
                multievent,
                default=FALSE)
            private$..ci95 <- jmvcore::OptionBool$new(
                "ci95",
                ci95,
                default=FALSE)
            private$..risktable <- jmvcore::OptionBool$new(
                "risktable",
                risktable,
                default=FALSE)
            private$..censored <- jmvcore::OptionBool$new(
                "censored",
                censored,
                default=FALSE)
            private$..medianline <- jmvcore::OptionList$new(
                "medianline",
                medianline,
                options=list(
                    "none",
                    "h",
                    "v",
                    "hv"),
                default="none")

            self$.addOption(private$..elapsedtime)
            self$.addOption(private$..tint)
            self$.addOption(private$..dxdate)
            self$.addOption(private$..fudate)
            self$.addOption(private$..calculatedtime)
            self$.addOption(private$..outcome)
            self$.addOption(private$..outcomeLevel)
            self$.addOption(private$..dod)
            self$.addOption(private$..dooc)
            self$.addOption(private$..awd)
            self$.addOption(private$..awod)
            self$.addOption(private$..analysistype)
            self$.addOption(private$..outcomeredefined)
            self$.addOption(private$..cutp)
            self$.addOption(private$..timetypedata)
            self$.addOption(private$..timetypeoutput)
            self$.addOption(private$..uselandmark)
            self$.addOption(private$..landmark)
            self$.addOption(private$..sc)
            self$.addOption(private$..kmunicate)
            self$.addOption(private$..ce)
            self$.addOption(private$..ch)
            self$.addOption(private$..endplot)
            self$.addOption(private$..ybegin_plot)
            self$.addOption(private$..yend_plot)
            self$.addOption(private$..byplot)
            self$.addOption(private$..multievent)
            self$.addOption(private$..ci95)
            self$.addOption(private$..risktable)
            self$.addOption(private$..censored)
            self$.addOption(private$..medianline)
        }),
    active = list(
        elapsedtime = function() private$..elapsedtime$value,
        tint = function() private$..tint$value,
        dxdate = function() private$..dxdate$value,
        fudate = function() private$..fudate$value,
        calculatedtime = function() private$..calculatedtime$value,
        outcome = function() private$..outcome$value,
        outcomeLevel = function() private$..outcomeLevel$value,
        dod = function() private$..dod$value,
        dooc = function() private$..dooc$value,
        awd = function() private$..awd$value,
        awod = function() private$..awod$value,
        analysistype = function() private$..analysistype$value,
        outcomeredefined = function() private$..outcomeredefined$value,
        cutp = function() private$..cutp$value,
        timetypedata = function() private$..timetypedata$value,
        timetypeoutput = function() private$..timetypeoutput$value,
        uselandmark = function() private$..uselandmark$value,
        landmark = function() private$..landmark$value,
        sc = function() private$..sc$value,
        kmunicate = function() private$..kmunicate$value,
        ce = function() private$..ce$value,
        ch = function() private$..ch$value,
        endplot = function() private$..endplot$value,
        ybegin_plot = function() private$..ybegin_plot$value,
        yend_plot = function() private$..yend_plot$value,
        byplot = function() private$..byplot$value,
        multievent = function() private$..multievent$value,
        ci95 = function() private$..ci95$value,
        risktable = function() private$..risktable$value,
        censored = function() private$..censored$value,
        medianline = function() private$..medianline$value),
    private = list(
        ..elapsedtime = NA,
        ..tint = NA,
        ..dxdate = NA,
        ..fudate = NA,
        ..calculatedtime = NA,
        ..outcome = NA,
        ..outcomeLevel = NA,
        ..dod = NA,
        ..dooc = NA,
        ..awd = NA,
        ..awod = NA,
        ..analysistype = NA,
        ..outcomeredefined = NA,
        ..cutp = NA,
        ..timetypedata = NA,
        ..timetypeoutput = NA,
        ..uselandmark = NA,
        ..landmark = NA,
        ..sc = NA,
        ..kmunicate = NA,
        ..ce = NA,
        ..ch = NA,
        ..endplot = NA,
        ..ybegin_plot = NA,
        ..yend_plot = NA,
        ..byplot = NA,
        ..multievent = NA,
        ..ci95 = NA,
        ..risktable = NA,
        ..censored = NA,
        ..medianline = NA)
)

singlearmResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "singlearmResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        medianSummary = function() private$.items[["medianSummary"]],
        medianTable = function() private$.items[["medianTable"]],
        survTableSummary = function() private$.items[["survTableSummary"]],
        survTable = function() private$.items[["survTable"]],
        plot = function() private$.items[["plot"]],
        plot2 = function() private$.items[["plot2"]],
        plot3 = function() private$.items[["plot3"]],
        plot6 = function() private$.items[["plot6"]],
        calculatedtime = function() private$.items[["calculatedtime"]],
        outcomeredefined = function() private$.items[["outcomeredefined"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Single Arm Survival",
                refs=list(
                    "finalfit",
                    "survival",
                    "survminer",
                    "ClinicoPathJamoviModule",
                    "survivaltutorial",
                    "survivalrwnahhas"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do",
                clearWith=list(
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="medianSummary",
                title="Median Survival Summary and Table",
                clearWith=list(
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Table$new(
                options=options,
                name="medianTable",
                title="Median Survival Table",
                rows=0,
                columns=list(
                    list(
                        `name`="records", 
                        `title`="Records", 
                        `type`="integer"),
                    list(
                        `name`="events", 
                        `title`="Events", 
                        `type`="integer"),
                    list(
                        `name`="rmean", 
                        `title`="rmean", 
                        `type`="number"),
                    list(
                        `name`="se_rmean", 
                        `title`="se_rmean", 
                        `type`="number"),
                    list(
                        `name`="median", 
                        `title`="Median", 
                        `type`="number"),
                    list(
                        `name`="x0_95lcl", 
                        `title`="Lower", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number"),
                    list(
                        `name`="x0_95ucl", 
                        `title`="Upper", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number")),
                clearWith=list(
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="survTableSummary",
                title="1, 3, 5-yr Survival Summary and Table",
                clearWith=list(
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Table$new(
                options=options,
                name="survTable",
                title="1, 3, 5 year Survival",
                rows=0,
                columns=list(
                    list(
                        `name`="time", 
                        `title`="time", 
                        `type`="integer"),
                    list(
                        `name`="n.risk", 
                        `title`="Number at Risk", 
                        `type`="integer"),
                    list(
                        `name`="n.event", 
                        `title`="Number of Events", 
                        `type`="integer"),
                    list(
                        `name`="surv", 
                        `title`="Survival", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="lower", 
                        `title`="Lower", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="upper", 
                        `title`="Upper", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number", 
                        `format`="pc")),
                clearWith=list(
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot",
                title="Survival Plot",
                width=600,
                height=450,
                renderFun=".plot",
                visible="(sc)",
                requiresData=TRUE,
                clearWith=list(
                    "sc",
                    "endplot",
                    "byplot",
                    "sas",
                    "ci95",
                    "risktable",
                    "censored",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot2",
                title="Cumulative Events",
                width=600,
                height=450,
                renderFun=".plot2",
                visible="(ce)",
                requiresData=TRUE,
                clearWith=list(
                    "ce",
                    "endplot",
                    "byplot",
                    "sas",
                    "ci95",
                    "risktable",
                    "censored",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot3",
                title="Cumulative Hazard",
                width=600,
                height=450,
                renderFun=".plot3",
                visible="(ch)",
                requiresData=TRUE,
                clearWith=list(
                    "ch",
                    "endplot",
                    "byplot",
                    "sas",
                    "ci95",
                    "risktable",
                    "censored",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot6",
                title="KMunicate-Style Plot",
                width=600,
                height=450,
                renderFun=".plot6",
                visible="(kmunicate)",
                requiresData=TRUE,
                clearWith=list(
                    "kmunicate",
                    "endplot",
                    "byplot",
                    "sas",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent"),
                refs=list(
                    "KMunicate",
                    "KMunicate2")))
            self$add(jmvcore::Output$new(
                options=options,
                name="calculatedtime",
                title="Add Calculated Time to Data",
                varTitle="Calculated Time Single Arm",
                varDescription="`Calculated Time from given Dates in Single Arm Analysis - from ${ dxdate } to { fudate }`",
                clearWith=list(
                    "tint",
                    "dxdate",
                    "fudate")))
            self$add(jmvcore::Output$new(
                options=options,
                name="outcomeredefined",
                title="Add Redefined Outcome to Data",
                varTitle="Redefined Outcome Single Arm",
                varDescription="`Redefined Outcome - from ${ outcome } for analysis { analysistype } in Single Arm Analysis`",
                clearWith=list(
                    "outcome",
                    "analysistype",
                    "multievent",
                    "outcomeLevel")))}))

singlearmBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "singlearmBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "jsurvival",
                name = "singlearm",
                version = c(1,0,0),
                options = options,
                results = singlearmResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'none')
        }))

#' Single Arm Survival
#'
#' Performs survival analysis for a single cohort of patients without group 
#' comparisons. Use this when you want to analyze overall survival 
#' characteristics of your entire study population - for example, to determine 
#' median survival time or 1/3/5-year survival rates for all patients 
#' collectively. This differs from regular survival analysis which compares 
#' survival between groups.
#'
#' @examples
#' \donttest{
#' # Example analyzing overall survival for a patient cohort:
#' # singlearm(
#' #   data = patient_data,
#' #   time = "months_survival",
#' #   outcome = "death_status",
#' #   outcome_level = "Dead"
#' # )
#'}
#' @param data The data as a data frame.
#' @param elapsedtime The time-to-event or follow-up duration for each
#'   patient. Should be numeric and continuous, measured in consistent units
#'   (e.g., months or years). Can be calculated automatically from dates if
#'   using the date options below.
#' @param tint Enable this option if you want to calculate survival time from
#'   dates in your data. This is useful when you have separate columns for
#'   diagnosis date and follow-up date and want to calculate the time elapsed
#'   between them.
#' @param dxdate The date of diagnosis or study entry for each patient. Should
#'   be in a consistent date format (e.g., YYYY-MM-DD).
#' @param fudate The date of last follow-up or event for each patient. Should
#'   be in a consistent date format (e.g., YYYY-MM-DD).
#' @param outcome The outcome or event of interest for each patient. Should be
#'   a factor or numeric variable indicating whether the patient experienced the
#'   event (e.g., death) or censoring (e.g., end of follow-up).
#' @param outcomeLevel Select the level of the outcome variable that
#'   represents the event of interest. For example, if the outcome variable is
#'   "death_status" with levels "Alive" and "Dead", select "Dead" as the event
#'   level.
#' @param dod Select the level of the outcome variable that represents death
#'   due to disease. This is useful for competing risk analysis when there are
#'   multiple event types.
#' @param dooc Select the level of the outcome variable that represents death
#'   due to other causes. This is useful for competing risk analysis when there
#'   are multiple event types.
#' @param awd Select the level of the outcome variable that represents being
#'   alive with disease. This is useful for competing risk analysis when there
#'   are multiple event types.
#' @param awod Select the level of the outcome variable that represents being
#'   alive without disease. This is useful for competing risk analysis when
#'   there are multiple event types.
#' @param analysistype Select the type of survival analysis to perform.
#'   "Overall" analyzes the survival of all patients regardless of event type.
#'   "Cause Specific" analyzes the survival for a specific event type (e.g.,
#'   death due to disease). "Competing Risk" analyzes the survival for multiple
#'   event types simultaneously.
#' @param cutp Specify the time points at which to calculate survival
#'   probabilities. Enter a comma-separated list of time points in consistent
#'   units (e.g., months or years). For example, "12, 36, 60" calculates
#'   survival probabilities at 1, 3, and 5 years.
#' @param timetypedata select the time type in data (e.g., YYYY-MM-DD)
#' @param timetypeoutput select the time type in output (default is months)
#' @param uselandmark Enables landmark analysis, which addresses immortal time
#'   bias by analyzing survival only for patients who survive to a specified
#'   timepoint (the landmark). Use this when you want to eliminate the effect of
#'   early deaths or when comparing treatments that can only be given to
#'   patients who survive long enough to receive them.
#' @param landmark Enables landmark analysis, which addresses immortal time
#'   bias by analyzing survival only for patients who survive to a specified
#'   timepoint (the landmark). Use this when you want to eliminate the effect of
#'   early deaths or when comparing treatments that can only be given to
#'   patients who survive long enough to receive them.
#' @param sc Enable this option to generate a Kaplan-Meier survival plot with
#'   confidence intervals. This plot shows the estimated survival probability
#'   over time and is useful for visualizing survival trends in your data.
#' @param kmunicate Enable this option to generate a publication-ready
#'   survival plot in the style of KMunicate. This plot shows the estimated
#'   survival probability over time with confidence intervals and is suitable
#'   for publication or presentation.
#' @param ce Enable this option to calculate and plot the cumulative number of
#'   events over time. This plot shows the total number of events (e.g., deaths)
#'   that have occurred at each time point and is useful for visualizing event
#'   rates in your data.
#' @param ch Enable this option to calculate and plot the cumulative hazard
#'   function over time. This plot shows the cumulative risk of experiencing the
#'   event (e.g., death) at each time point and is useful for visualizing the
#'   risk of the event over time.
#' @param endplot The maximum time point to include in the survival plots.
#'   This is the end time for the survival curves and cumulative event/hazard
#'   plots. Enter a positive integer representing the time in consistent units
#'   (e.g., months or years).
#' @param ybegin_plot The minimum value for the y-axis in the survival plots.
#'   Enter a number between 0 and 1 to set the lower limit of the y-axis.
#' @param yend_plot The maximum value for the y-axis in the survival plots.
#'   Enter a number between 0 and 1 to set the upper limit of the y-axis.
#' @param byplot The interval for plotting survival probabilities. Enter a
#'   positive integer representing the time interval in consistent units (e.g.,
#'   months or years).
#' @param multievent Enable this option to perform survival analysis for
#'   datasets with multiple event levels. This is useful for competing risk
#'   analysis when there are multiple event types (e.g., death due to disease,
#'   death due to other causes).
#' @param ci95 Enable this option to display 95\% confidence intervals on the
#'   survival plots. These intervals show the range of uncertainty around the
#'   estimated survival probabilities and are useful for assessing the precision
#'   of the estimates.
#' @param risktable Enable this option to display a table of risk estimates at
#'   each time point. This table shows the estimated survival probability,
#'   cumulative event rate, and cumulative hazard at each time point and is
#'   useful for summarizing the survival characteristics of your data.
#' @param censored Enable this option to display censored observations on the
#'   survival plots. Censored observations are patients who have not experienced
#'   the event of interest by the end of follow-up and are indicated by vertical
#'   ticks on the survival curves.
#' @param medianline If true, displays a line indicating the median survival
#'   time on the survival plot.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$medianSummary} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$medianTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$survTableSummary} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$survTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$plot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plot2} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plot3} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plot6} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$calculatedtime} \tab \tab \tab \tab \tab an output \cr
#'   \code{results$outcomeredefined} \tab \tab \tab \tab \tab an output \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$medianTable$asDF}
#'
#' \code{as.data.frame(results$medianTable)}
#'
#' @export
singlearm <- function(
    data,
    elapsedtime,
    tint = FALSE,
    dxdate,
    fudate,
    outcome,
    outcomeLevel,
    dod,
    dooc,
    awd,
    awod,
    analysistype = "overall",
    cutp = "12, 36, 60",
    timetypedata = "ymd",
    timetypeoutput = "months",
    uselandmark = FALSE,
    landmark = 3,
    sc = FALSE,
    kmunicate = FALSE,
    ce = FALSE,
    ch = FALSE,
    endplot = 60,
    ybegin_plot = 0,
    yend_plot = 1,
    byplot = 12,
    multievent = FALSE,
    ci95 = FALSE,
    risktable = FALSE,
    censored = FALSE,
    medianline = "none") {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("singlearm requires jmvcore to be installed (restart may be required)")

    if ( ! missing(elapsedtime)) elapsedtime <- jmvcore::resolveQuo(jmvcore::enquo(elapsedtime))
    if ( ! missing(dxdate)) dxdate <- jmvcore::resolveQuo(jmvcore::enquo(dxdate))
    if ( ! missing(fudate)) fudate <- jmvcore::resolveQuo(jmvcore::enquo(fudate))
    if ( ! missing(outcome)) outcome <- jmvcore::resolveQuo(jmvcore::enquo(outcome))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(elapsedtime), elapsedtime, NULL),
            `if`( ! missing(dxdate), dxdate, NULL),
            `if`( ! missing(fudate), fudate, NULL),
            `if`( ! missing(outcome), outcome, NULL))


    options <- singlearmOptions$new(
        elapsedtime = elapsedtime,
        tint = tint,
        dxdate = dxdate,
        fudate = fudate,
        outcome = outcome,
        outcomeLevel = outcomeLevel,
        dod = dod,
        dooc = dooc,
        awd = awd,
        awod = awod,
        analysistype = analysistype,
        cutp = cutp,
        timetypedata = timetypedata,
        timetypeoutput = timetypeoutput,
        uselandmark = uselandmark,
        landmark = landmark,
        sc = sc,
        kmunicate = kmunicate,
        ce = ce,
        ch = ch,
        endplot = endplot,
        ybegin_plot = ybegin_plot,
        yend_plot = yend_plot,
        byplot = byplot,
        multievent = multievent,
        ci95 = ci95,
        risktable = risktable,
        censored = censored,
        medianline = medianline)

    analysis <- singlearmClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\survival.b.R
--------------------------------------------------
Content of R\survival.b.R:
#' @title Survival Analysis
#' @importFrom R6 R6Class
#' @import jmvcore
#' @import magrittr
#'

survivalClass <- if (requireNamespace('jmvcore'))
    R6::R6Class(
        "survivalClass",
        inherit = survivalBase,
        private = list(

            .init = function() {

                if (self$options$ph_cox) {
                    # Disable tables
                    self$results$cox_ph$setVisible(TRUE)
                }

                if (!(self$options$ph_cox)) {
                    # Disable tables
                    self$results$cox_ph$setVisible(FALSE)
                }


                # if (self$options$sas) {
                #     # Disable tables
                #     self$results$medianSummary$setVisible(FALSE)
                #     self$results$medianTable$setVisible(FALSE)
                #     self$results$coxSummary$setVisible(FALSE)
                #     self$results$coxTable$setVisible(FALSE)
                #     self$results$tCoxtext2$setVisible(FALSE)
                #     self$results$survTableSummary$setVisible(FALSE)
                #     self$results$survTable$setVisible(FALSE)
                #     self$results$pairwiseSummary$setVisible(FALSE)
                #     self$results$pairwiseTable$setVisible(FALSE)
                # }
            }
            ,


            .getData = function() {

            mydata <- self$data

            mydata$row_names <- rownames(mydata)

            original_names <- names(mydata)

            labels <- setNames(original_names, original_names)

            mydata <- mydata %>% janitor::clean_names()

            corrected_labels <-
                setNames(original_names, names(mydata))

            mydata <- labelled::set_variable_labels(.data = mydata,
                                                    .labels = corrected_labels)

            all_labels <- labelled::var_label(mydata)


            mytime <-
                names(all_labels)[all_labels == self$options$elapsedtime]

            myoutcome <-
                names(all_labels)[all_labels == self$options$outcome]

            mydxdate <-
                names(all_labels)[all_labels == self$options$dxdate]

            myfudate <-
                names(all_labels)[all_labels == self$options$fudate]

            myexplanatory <-
                names(all_labels)[all_labels == self$options$explanatory]

            return(list(
                "mydata_labelled" = mydata
                , "mytime_labelled" = mytime
                , "myoutcome_labelled" = myoutcome
                , "mydxdate_labelled" = mydxdate
                , "myfudate_labelled" = myfudate
                , "myexplanatory_labelled" = myexplanatory
            ))


            }





            ,
            .todo = function() {

                 todo <- glue::glue(
                        "
                <br>Welcome to ClinicoPath
                <br><br>
                This tool will help you calculate median survivals and 1,3,5-yr survivals for a given fisk factor.
                <br><br>
                Explanatory variable should be categorical (ordinal or nominal).
                <br><br>
                Select outcome level from Outcome variable.
                <br><br>
                Outcome Level: if patient is dead or event (recurrence) occured. You may also use advanced outcome options depending on your analysis type.
                <br><br>
                Survival time should be numeric and continuous. You may also use dates to calculate survival time in advanced elapsed time options.
                <br><br>
                This function uses survival, survminer, and finalfit packages. Please cite jamovi and the packages as given below.
                <br><hr>
                <br>
                See details for survival <a href = 'https://cran.r-project.org/web/packages/survival/vignettes/survival.pdf'>here</a>."
                    )

                    html <- self$results$todo
                    html$setContent(todo)

            }


            # Define Survival Time ----
            ,
            .definemytime = function() {

            # Read Labelled Data ----

            labelled_data <- private$.getData()

            mydata <- labelled_data$mydata_labelled
            mytime_labelled <- labelled_data$mytime_labelled
            mydxdate_labelled <- labelled_data$mydxdate_labelled
            myfudate_labelled <- labelled_data$myfudate_labelled

            tint <- self$options$tint


                if (!tint) {
                    # Precalculated Time ----

                    mydata[["mytime"]] <-
                        jmvcore::toNumeric(mydata[[mytime_labelled]])


                } else if (tint) {
                    # Time Interval ----

                    dxdate <- mydxdate_labelled # self$options$dxdate
                    fudate <- myfudate_labelled #self$options$fudate
                    timetypedata <- self$options$timetypedata


                    # # Define a mapping from timetypedata to lubridate functions
                    # lubridate_functions <- list(
                    #     ymdhms = lubridate::ymd_hms,
                    #     ymd = lubridate::ymd,
                    #     ydm = lubridate::ydm,
                    #     mdy = lubridate::mdy,
                    #     myd = lubridate::myd,
                    #     dmy = lubridate::dmy,
                    #     dym = lubridate::dym
                    # )
                    # # Apply the appropriate lubridate function based on timetypedata
                    # if (timetypedata %in% names(lubridate_functions)) {
                    #     func <- lubridate_functions[[timetypedata]]
                    #     mydata[["start"]] <- func(mydata[[dxdate]])
                    #     mydata[["end"]] <- func(mydata[[fudate]])
                    # }


                    if (timetypedata == "ymdhms") {
                        mydata[["start"]] <- lubridate::ymd_hms(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::ymd_hms(mydata[[fudate]])
                    }
                    if (timetypedata == "ymd") {
                        mydata[["start"]] <- lubridate::ymd(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::ymd(mydata[[fudate]])
                    }
                    if (timetypedata == "ydm") {
                        mydata[["start"]] <- lubridate::ydm(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::ydm(mydata[[fudate]])
                    }
                    if (timetypedata == "mdy") {
                        mydata[["start"]] <- lubridate::mdy(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::mdy(mydata[[fudate]])
                    }
                    if (timetypedata == "myd") {
                        mydata[["start"]] <- lubridate::myd(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::myd(mydata[[fudate]])
                    }
                    if (timetypedata == "dmy") {
                        mydata[["start"]] <- lubridate::dmy(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::dmy(mydata[[fudate]])
                    }
                    if (timetypedata == "dym") {
                        mydata[["start"]] <- lubridate::dym(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::dym(mydata[[fudate]])
                    }


                    if ( sum(!is.na(mydata[["start"]])) == 0 || sum(!is.na(mydata[["end"]])) == 0)  {
                        stop(paste0("Time difference cannot be calculated. Make sure that time type in variables are correct. Currently it is: ", self$options$timetypedata)
                        )
                    }

                    timetypeoutput <-
                        jmvcore::constructFormula(terms = self$options$timetypeoutput)


                    mydata <- mydata %>%
                        dplyr::mutate(interval = lubridate::interval(start, end))



                    mydata <- mydata %>%
                        dplyr::mutate(mytime = lubridate::time_length(interval, timetypeoutput))


                }


                df_time <- mydata %>% jmvcore::select(c("row_names", "mytime"))



                return(df_time)


            }

            # Define Outcome ----
            ,
            .definemyoutcome = function() {


            labelled_data <- private$.getData()

            mydata <- labelled_data$mydata_labelled
            myoutcome_labelled <- labelled_data$myoutcome_labelled


                contin <- c("integer", "numeric", "double")

                outcomeLevel <- self$options$outcomeLevel
                multievent <- self$options$multievent

                outcome1 <- mydata[[myoutcome_labelled]]

                if (!multievent) {
                    if (inherits(outcome1, contin)) {
                        if (!((length(unique(
                            outcome1[!is.na(outcome1)]
                        )) == 2) && (sum(unique(
                            outcome1[!is.na(outcome1)]
                        )) == 1))) {
                            stop(
                                'When using continuous variable as an outcome, it must only contain 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0.'
                            )

                        }

                        mydata[["myoutcome"]] <- mydata[[myoutcome_labelled]]
                            # mydata[[self$options$outcome]]

                    } else if (inherits(outcome1, "factor")) {
                        mydata[["myoutcome"]] <-
                            ifelse(
                                test = outcome1 == outcomeLevel,
                                yes = 1,
                                no = 0
                            )

                    } else {
                        stop(
                            'When using continuous variable as an outcome, it must only contain 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0. If you are using a factor as an outcome, please check the levels and content.'
                        )

                    }

                } else if (multievent) {
                    analysistype <- self$options$analysistype

                    dod <- self$options$dod
                    dooc <- self$options$dooc
                    awd <- self$options$awd
                    awod <- self$options$awod

                    if (analysistype == 'overall') {
                        # Overall ----
                        # (Alive) <=> (Dead of Disease & Dead of Other Causes)


                        mydata[["myoutcome"]] <- NA_integer_

                        mydata[["myoutcome"]][outcome1 == awd] <- 0
                        mydata[["myoutcome"]][outcome1 == awod] <- 0
                        mydata[["myoutcome"]][outcome1 == dod] <- 1
                        mydata[["myoutcome"]][outcome1 == dooc] <- 1



                    } else if (analysistype == 'cause') {
                        # Cause Specific ----
                        # (Alive & Dead of Other Causes) <=> (Dead of Disease)


                        mydata[["myoutcome"]] <- NA_integer_

                        mydata[["myoutcome"]][outcome1 == awd] <- 0
                        mydata[["myoutcome"]][outcome1 == awod] <- 0
                        mydata[["myoutcome"]][outcome1 == dod] <- 1
                        mydata[["myoutcome"]][outcome1 == dooc] <- 0

                    } else if (analysistype == 'compete') {
                        # Competing Risks ----
                        # Alive <=> Dead of Disease accounting for Dead of Other Causes

                        # https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#part_3:_competing_risks


                        mydata[["myoutcome"]] <- NA_integer_

                        mydata[["myoutcome"]][outcome1 == awd] <- 0
                        mydata[["myoutcome"]][outcome1 == awod] <- 0
                        mydata[["myoutcome"]][outcome1 == dod] <- 1
                        mydata[["myoutcome"]][outcome1 == dooc] <- 2

                    }

                }

                df_outcome <- mydata %>% jmvcore::select(c("row_names", "myoutcome"))

                return(df_outcome)

            }


            # Define Factor ----
            ,

            .definemyfactor = function() {


            labelled_data <- private$.getData()

            mydata_labelled <- labelled_data$mydata_labelled
            myexplanatory_labelled <- labelled_data$myexplanatory_labelled

            mydata <- mydata_labelled

            mydata[["myfactor"]] <- mydata[[myexplanatory_labelled]]


            df_factor <- mydata %>% jmvcore::select(c("row_names","myfactor"))

            return(df_factor)

            }


            # Clean Data For Analysis ----
            ,
            .cleandata = function() {

            labelled_data <- private$.getData()

            mydata_labelled        <- labelled_data$mydata_labelled
            mytime_labelled        <- labelled_data$mytime_labelled
            myoutcome_labelled     <- labelled_data$myoutcome_labelled
            mydxdate_labelled      <- labelled_data$mydxdate_labelled
            myfudate_labelled      <- labelled_data$myfudate_labelled
            myexplanatory_labelled <- labelled_data$myexplanatory_labelled

                time <- private$.definemytime()
                outcome <- private$.definemyoutcome()
                factor <- private$.definemyfactor()

                if (is.null(time) || is.null(outcome) || is.null(factor)) {
                    stop("Error: Data could not be cleaned for analysis.")
                }

                cleanData <- dplyr::left_join(time, outcome, by = "row_names") %>%
                    dplyr::left_join(factor, by = "row_names")

                # Landmark ----
                # https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#landmark_method
                if (self$options$uselandmark) {

                  landmark <- jmvcore::toNumeric(self$options$landmark)

                    cleanData <- cleanData %>%
                        dplyr::filter(mytime >= landmark) %>%
                        dplyr::mutate(mytime = mytime - landmark)
                }

                # Time Dependent Covariate ----
                # https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#time-dependent_covariate


                # Names cleanData ----

                if (self$options$tint) {
                    name1time <- "CalculatedTime"
                }

                if (!self$options$tint &&
                    !is.null(self$options$elapsedtime)) {
                    name1time <- mytime_labelled
                }

                name2outcome <- myoutcome_labelled

                if (self$options$multievent) {
                    name2outcome <- "CalculatedOutcome"
                }

                if (!is.null(self$options$explanatory)
                    ) {
                    name3explanatory <- myexplanatory_labelled
                    }

                    cleanData <- cleanData %>%
                        dplyr::rename(
                            !!name1time := mytime,
                            !!name2outcome := myoutcome,
                            !!name3explanatory := myfactor
                        )

                # naOmit ----

                cleanData <- jmvcore::naOmit(cleanData)


                # Prepare Data For Plots ----

                plotData <- list(
                    "name1time" = name1time,
                    "name2outcome" = name2outcome,
                    "name3explanatory" = name3explanatory,
                    "cleanData" = cleanData
                )

                image <- self$results$plot
                image$setState(plotData)

                image2 <- self$results$plot2
                image2$setState(plotData)

                image3 <- self$results$plot3
                image3$setState(plotData)

                image6 <- self$results$plot6
                image6$setState(plotData)

                # Return Data ----

                return(
                    list(
                        "name1time" = name1time,
                        "name2outcome" = name2outcome,
                        "name3explanatory" = name3explanatory,
                        "cleanData" = cleanData,
                        "mytime_labelled" = mytime_labelled,
                        "myoutcome_labelled" = myoutcome_labelled,
                        "mydxdate_labelled" = mydxdate_labelled,
                        "myfudate_labelled" = myfudate_labelled,
                        "myexplanatory_labelled" = myexplanatory_labelled
                    )
                )

            }


            # Run Analysis ----
            ,
            .run = function() {

                # Errors, Warnings ----

                ## No variable todo ----

                ## Define subconditions ----

                subcondition1a <- !is.null(self$options$outcome)
                subcondition1b1 <- self$options$multievent
                subcondition1b2 <- !is.null(self$options$dod)
                subcondition1b3 <- !is.null(self$options$dooc)
                # subcondition1b4 <- !is.null(self$options$awd)
                # subcondition1b5 <- !is.null(self$options$awod)
                subcondition2a <- !is.null(self$options$elapsedtime)
                subcondition2b1 <- self$options$tint
                subcondition2b2 <- !is.null(self$options$dxdate)
                subcondition2b3 <- !is.null(self$options$fudate)
                condition3 <- !is.null(self$options$explanatory)


                condition1 <- subcondition1a && !subcondition1b1 || subcondition1b1 && subcondition1b2 || subcondition1b1 && subcondition1b3

                condition2 <- subcondition2b1 && subcondition2b2 && subcondition2b3 || subcondition2a && !subcondition2b1 && !subcondition2b2 && !subcondition2b3

                not_continue_analysis <- !(condition1 && condition2 && condition3)

                if (not_continue_analysis) {
                    private$.todo()
                    self$results$medianSummary$setVisible(FALSE)
                    self$results$medianTable$setVisible(FALSE)
                    self$results$coxSummary$setVisible(FALSE)
                    self$results$coxTable$setVisible(FALSE)
                    self$results$tCoxtext2$setVisible(FALSE)
                    self$results$cox_ph$setVisible(FALSE)
                    self$results$plot8$setVisible(FALSE)
                    self$results$survTableSummary$setVisible(FALSE)
                    self$results$survTable$setVisible(FALSE)
                    self$results$pairwiseSummary$setVisible(FALSE)
                    self$results$pairwiseTable$setVisible(FALSE)
                    self$results$plot$setVisible(FALSE)
                    self$results$plot2$setVisible(FALSE)
                    self$results$plot3$setVisible(FALSE)
                    self$results$plot6$setVisible(FALSE)
                    self$results$todo$setVisible(TRUE)
                    return()
                } else {
                    self$results$todo$setVisible(FALSE)
                }


                # Empty data ----

                if (nrow(self$data) == 0)
                    stop('Data contains no (complete) rows')

                # Get Clean Data ----
                results <- private$.cleandata()

                if (is.null(results)) {
                    return()
                }

                # Run Analysis ----
                ## Median Survival ----
                    private$.medianSurv(results)
                ## Cox ----
                    private$.cox(results)
                ## Survival Table ----
                    private$.survTable(results)


                ## Pairwise ----
                if (self$options$pw
                    # && !self$options$sas
                    ) {
                    private$.pairwise(results)
                }

                # Add Calculated Time to Data ----

                # self$results$mydataview$setContent(
                #     list(
                #         results
                #     )
                # )


                if (self$options$tint && self$options$calculatedtime && self$results$calculatedtime$isNotFilled()) {
                    self$results$calculatedtime$setRowNums(results$cleanData$row_names)
                    self$results$calculatedtime$setValues(results$cleanData$CalculatedTime)
                }


                # Add Redefined Outcome to Data ----

                if (self$options$multievent  && self$options$outcomeredefined && self$results$outcomeredefined$isNotFilled()) {
                    self$results$outcomeredefined$setRowNums(results$cleanData$row_names)
                    self$results$outcomeredefined$setValues(results$cleanData$CalculatedOutcome)
                }
            }

            # Median Survival Function ----
            ,
            .medianSurv = function(results) {

                mytime <- results$name1time
                myoutcome <- results$name2outcome
                myfactor <- results$name3explanatory
                myexplanatory_labelled <- results$myexplanatory_labelled

                mydata <- results$cleanData

                mydata[[mytime]] <-
                    jmvcore::toNumeric(mydata[[mytime]])

                ## Median Survival Table ----

                formula <-
                    paste('survival::Surv(',
                          mytime,
                          ',',
                          myoutcome,
                          ') ~ ',
                          myfactor)

                formula <- as.formula(formula)

                km_fit <- survival::survfit(formula, data = mydata)

                km_fit_median_df <- summary(km_fit)


                # medianSummary2 <-
                #   as.data.frame(km_fit_median_df$table)
                # self$results$medianSummary2$setContent(medianSummary2)



                results1html <-
                    as.data.frame(km_fit_median_df$table) %>%

                    janitor::clean_names(dat = ., case = "snake") %>%
                    tibble::rownames_to_column(.data = .)


                results1html[, 1] <- gsub(pattern = ", ",
                                          replacement = " and ",
                                          x = results1html[, 1])

                results1table <- results1html

                names(results1table)[1] <- "factor"


                results2table <- results1table

                results2table$factor <- gsub(pattern = paste0(myexplanatory_labelled,"="),
                                             replacement = "",
                                             x = results1table$factor)


                # self$results$medianSummary2$setContent(results2table)


                medianTable <- self$results$medianTable
                data_frame <- results2table
                for (i in seq_along(data_frame[, 1, drop = T])) {
                    medianTable$addRow(rowKey = i, values = c(data_frame[i,]))
                }


                ## Median Survival Summary ----

                results1table %>%
                    dplyr::mutate(
                        description =
                            glue::glue(
                                "When {factor}, median survival is {round(median, digits = 1)} [{round(x0_95lcl, digits = 1)} - {round(x0_95ucl, digits = 1)}, 95% CI] ",
                                self$options$timetypeoutput,
                                "."
                            )
                    ) %>%
                  dplyr::mutate(
                    description = dplyr::case_when(
                      is.na(median) ~ paste0(
                        glue::glue("{description} \n Note that when {factor}, the survival curve does not drop below 1/2 during \n the observation period, thus the median survival is undefined.")),
                      TRUE ~ paste0(description)
                    )
                  ) %>%
                  dplyr::mutate(description = gsub(
                    pattern = "=",
                    replacement = " is ",
                    x = description
                  )) %>%
                  dplyr::mutate(description = gsub(
                    pattern = myexplanatory_labelled,
                    replacement = self$options$explanatory,
                    x = description
                  )) %>%
                    dplyr::select(description) %>%
                    dplyr::pull(.) -> km_fit_median_definition

                medianSummary <- c(km_fit_median_definition,
                                   "The median survival time is when 50% of subjects have experienced the event.",
                                   "This means that 50% of subjects in this group survived longer than this time period."
                                   )

                self$results$medianSummary$setContent(medianSummary)


            }

            ## Cox Regression Function ----
            ,
            .cox = function(results) {
                ### Cox Regression ----


                mytime <- results$name1time
                mytime <- jmvcore::constructFormula(terms = mytime)

                myoutcome <- results$name2outcome
                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)


                myfactor <- results$name3explanatory
                myfactor <-
                    jmvcore::constructFormula(terms = myfactor)

                mydata <- results$cleanData

                mydata[[mytime]] <-
                    jmvcore::toNumeric(mydata[[mytime]])

                myformula <-
                    paste("Surv(", mytime, ",", myoutcome, ")")

                finalfit::finalfit(
                    .data = mydata,
                    dependent = myformula,
                    explanatory = myfactor,
                    metrics = TRUE
                ) -> tCox

                tCoxtext2 <- glue::glue("
                                <br>
                                <b>Model Metrics:</b>
                                  ",
                                        unlist(tCox[[2]]),
                                        "
                                <br>
                                ")

                if (self$options$uselandmark) {

                  landmark <- jmvcore::toNumeric(self$options$landmark)

                  tCoxtext2 <- glue::glue(tCoxtext2,
                                          "Landmark time used as: ",
                                          landmark, " ",
                                          self$options$timetypeoutput, "."
                  )
                }


                self$results$tCoxtext2$setContent(tCoxtext2)


                tCox_df <-
                    tibble::as_tibble(tCox[[1]], .name_repair = "minimal") %>%
                    janitor::clean_names(dat = ., case = "snake")


                ## Cox-Regression Table ----

                coxTable <- self$results$coxTable

                data_frame <- tCox_df

                names(data_frame) <- c("Explanatory",
                                       "Levels",
                                       "all",
                                       "HR_univariable",
                                       "HR_multivariable")

                for (i in seq_along(data_frame[, 1, drop = T])) {
                    coxTable$addRow(rowKey = i, values = c(data_frame[i,]))
                }


                ## Cox-Table Explanation ----

                tCox_df <-
                    tibble::as_tibble(tCox[[1]], .name_repair = "minimal") %>%
                    janitor::clean_names(dat = ., case = "snake")

                names(tCox_df) <-
                    names(data_frame) <- c("Explanatory",
                                           "Levels",
                                           "all",
                                           "HR_univariable",
                                           "HR_multivariable")


                # https://stackoverflow.com/questions/38470355/r-fill-empty-cell-with-value-of-last-non-empty-cell

                while (length(ind <-
                              which(tCox_df$Explanatory == "")) > 0) {
                    tCox_df$Explanatory[ind] <- tCox_df$Explanatory[ind - 1]
                }

                # https://stackoverflow.com/questions/51180290/mutate-by-group-in-r

                tCox_df %>%
                    dplyr::group_by(Explanatory) %>%
                    dplyr::mutate(firstlevel = dplyr::first(Levels)) %>%
                    dplyr::mutate(
                        coxdescription = glue::glue(
                            "When {Explanatory} is {Levels}, there is {HR_univariable} times risk than when {Explanatory} is {firstlevel}. \n For {Explanatory}, compared to the reference group ({firstlevel}), subjects in the {Levels} group had {HR_univariable} times the risk of experiencing the event at any given time point."

                        )
                    ) %>%
                    dplyr::filter(HR_univariable != '-') %>%
                    dplyr::pull(coxdescription) -> coxSummary




                coxSummary <- unlist(coxSummary)

                coxSummary <- c(coxSummary,
                                "A hazard ratio greater than 1 indicates increased risk, while less than 1 indicates decreased risk compared to the reference group."
                )

                self$results$coxSummary$setContent(coxSummary)





                ## Proportional Hazards Assumption ----

                if (self$options$ph_cox) {

                    mydata[[mytime]] <- jmvcore::toNumeric(mydata[[mytime]])

                    formula <-
                    paste('survival::Surv(',
                          mytime,
                          ',',
                          myoutcome,
                          ') ~ ',
                          myfactor)

                formula <- as.formula(formula)

                    cox_model <- survival::coxph(formula, data = mydata)
                                                 # , na.action = na.exclude)

                    zph <- survival::cox.zph(cox_model)

                    self$results$cox_ph$setContent(print(zph))

                    image8 <- self$results$plot8
                    image8$setState(zph)

                    }


            }


            # Survival Table Function ----
            ,
            .survTable = function(results) {
                mytime <- results$name1time
                myoutcome <- results$name2outcome
                myfactor <- results$name3explanatory
                myexplanatory_labelled <- results$myexplanatory_labelled

                mydata <- results$cleanData

                mydata[[mytime]] <-
                    jmvcore::toNumeric(mydata[[mytime]])

                ## Median Survival Table ----

                formula <-
                    paste('survival::Surv(',
                          mytime,
                          ',',
                          myoutcome,
                          ') ~ ',
                          myfactor)

                formula <- as.formula(formula)

                km_fit <- survival::survfit(formula, data = mydata)

                utimes <- self$options$cutp

                utimes <- strsplit(utimes, ",")
                utimes <- purrr::reduce(utimes, as.vector)
                utimes <- as.numeric(utimes)

                if (length(utimes) == 0) {
                    utimes <- c(12, 36, 60)
                }

                km_fit_summary <- summary(km_fit, times = utimes, extend = TRUE)

                km_fit_df <-
                    as.data.frame(km_fit_summary[c("strata",
                                                   "time",
                                                   "n.risk",
                                                   "n.event",
                                                   "surv",
                                                   "std.err",
                                                   "lower",
                                                   "upper")])

                # self$results$tableview$setContent(km_fit_df)


                km_fit_df[, 1] <- gsub(
                    pattern = "thefactor=",
                    replacement = paste0(self$options$explanatory, " "),
                    x = km_fit_df[, 1]
                )


                km_fit_df2 <- km_fit_df

                km_fit_df[, 1] <- gsub(
                    pattern = paste0(myexplanatory_labelled,"="),
                    replacement = paste0(
                        # self$options$explanatory,
                        ""),
                    x = km_fit_df[, 1]
                )

                survTable <- self$results$survTable

                data_frame <- km_fit_df
                for (i in seq_along(data_frame[, 1, drop = T])) {
                    survTable$addRow(rowKey = i, values = c(data_frame[i,]))
                }


                ## survTableSummary 1,3,5-yr survival summary ----

                km_fit_df2[, 1] <- gsub(
                    pattern = paste0(myexplanatory_labelled,"="),
                    replacement = paste0(self$options$explanatory, " is "),
                    x = km_fit_df2[, 1]
                )

                km_fit_df2 %>%
                    dplyr::mutate(
                        description =
                            glue::glue(
                                "When {strata}, {time} month survival is {scales::percent(surv)} [{scales::percent(lower)}-{scales::percent(upper)}, 95% CI]. \n For the {strata} group, the estimated probability of surviving beyond {time} months was {scales::percent(surv)} [{scales::percent(lower)}-{scales::percent(upper)}, 95% CI]. \n At this time point, there were {n.risk} subjects still at risk and {n.event} events had occurred in this group."

                            )
                    ) %>%
                    dplyr::select(description) %>%
                    dplyr::pull(.) -> survTableSummary

                self$results$survTableSummary$setContent(survTableSummary)

            }


            # Pairwise Function ----
            ,
            .pairwise = function(results) {
                ##  pairwise comparison ----

                mytime <- results$name1time
                myoutcome <- results$name2outcome
                myfactor <- results$name3explanatory

                mydata <- results$cleanData

                mydata[[mytime]] <-
                    jmvcore::toNumeric(mydata[[mytime]])

                ## Median Survival Table ----

                formula <-
                    paste('survival::Surv(',
                          mytime,
                          ',',
                          myoutcome,
                          ') ~ ',
                          myfactor)

                formula_p <- as.formula(formula)

                padjustmethod <-
                    jmvcore::constructFormula(terms = self$options$padjustmethod)


                results_pairwise <-
                    survminer::pairwise_survdiff(formula = formula_p,
                                                 data = mydata,
                                                 p.adjust.method = padjustmethod)


                mypairwise2 <-
                    as.data.frame(results_pairwise[["p.value"]]) %>%
                    tibble::rownames_to_column(.data = .) %>%
                    tidyr::pivot_longer(data = ., cols = -rowname) %>%
                    dplyr::filter(complete.cases(.))



                ## Pairwise Table ----

                pairwiseTable <- self$results$pairwiseTable

                data_frame <- mypairwise2
                for (i in seq_along(data_frame[, 1, drop = T])) {
                    pairwiseTable$addRow(rowKey = i, values = c(data_frame[i,]))
                }

                thefactor <-
                    jmvcore::constructFormula(terms = self$options$explanatory)

                title2 <- as.character(thefactor)

                pairwiseTable$setTitle(paste0('Pairwise Comparisons ', title2))

                pairwiseTable$setNote(
                    key = padjustmethod,
                    note = paste0("p-value adjustement method: ",
                           padjustmethod)
                )

                mypairwise2 %>%
                    dplyr::mutate(
                        description =
                            glue::glue(
                                "The difference of ",
                                title2,
                                " between {rowname} and {name}",
                                " has a p-value of {format.pval(value, digits = 3, eps = 0.001)}.",

                                "The survival difference between {rowname} and {name} groups was tested using a log-rank test. The p-value of {format.pval(value, digits = 3, eps = 0.001)} {ifelse(value < 0.05, 'indicates a statistically significant difference', 'suggests no statistically significant difference')} in survival between these groups (using {padjustmethod} adjustment for multiple comparisons)."



                            )
                    ) %>%
                    dplyr::pull(description) -> pairwiseSummary

                pairwiseSummary <- unlist(pairwiseSummary)


                self$results$pairwiseSummary$setContent(pairwiseSummary)


                if (dim(mypairwise2)[1] == 1) {
                    self$results$pairwiseTable$setVisible(FALSE)

                    pairwiseSummary <-
                        "No pairwise comparison when explanatory variable has < 3 levels."
                    self$results$pairwiseSummary$setContent(pairwiseSummary)

                }


            }


            # Survival Curve ----
            ,
            .plot = function(image, ggtheme, theme, ...) {
                sc <- self$options$sc

                if (!sc)
                    return()

                results <- image$state

                if (is.null(results)) {
                    return()
                }

                mytime <- results$name1time
                mytime <- jmvcore::constructFormula(terms = mytime)

                myoutcome <- results$name2outcome
                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)


                myfactor <- results$name3explanatory
                myfactor <-
                    jmvcore::constructFormula(terms = myfactor)

                plotData <- results$cleanData

                plotData[[mytime]] <-
                    jmvcore::toNumeric(plotData[[mytime]])

                myformula <-
                    paste("survival::Surv(", mytime, ",", myoutcome, ")")

                title2 <- as.character(myfactor)

                plot <- plotData %>%
                    finalfit::surv_plot(
                        .data = .,
                        dependent = myformula,
                        explanatory = myfactor,
                        xlab = paste0('Time (', self$options$timetypeoutput, ')'),
                        pval = self$options$pplot,
                        pval.method	= self$options$pplot,
                        legend = 'none',
                        break.time.by = self$options$byplot,
                        xlim = c(0, self$options$endplot),
                        ylim = c(
                            self$options$ybegin_plot,
                            self$options$yend_plot),
                        title = paste0("Survival curves for ", title2),
                        subtitle = "Based on Kaplan-Meier estimates",
                        risk.table = self$options$risktable,
                        conf.int = self$options$ci95,
                        censor = self$options$censored,
                        surv.median.line = self$options$medianline
                    )

                # plot <- plot + ggtheme

                print(plot)
                TRUE

            }



            # Cumulative Events ----
            # https://rpkgs.datanovia.com/survminer/survminer_cheatsheet.pdf
            ,
            .plot2 = function(image2, ggtheme, theme, ...) {
                ce <- self$options$ce

                if (!ce)
                    return()

                results <- image2$state

                if (is.null(results)) {
                    return()
                }

                mytime <- results$name1time
                mytime <- jmvcore::constructFormula(terms = mytime)

                myoutcome <- results$name2outcome
                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)


                myfactor <- results$name3explanatory
                myfactor <-
                    jmvcore::constructFormula(terms = myfactor)

                plotData <- results$cleanData

                plotData[[mytime]] <-
                    jmvcore::toNumeric(plotData[[mytime]])

                myformula <-
                    paste("survival::Surv(", mytime, ",", myoutcome, ")")

                title2 <- as.character(myfactor)

                plot2 <- plotData %>%
                    finalfit::surv_plot(
                        .data = .,
                        dependent = myformula,
                        explanatory = myfactor,
                        xlab = paste0('Time (', self$options$timetypeoutput, ')'),
                        pval = self$options$pplot,
                        pval.method	= self$options$pplot,
                        legend = 'none',
                        break.time.by = self$options$byplot,
                        xlim = c(0, self$options$endplot),
                        ylim = c(
                            self$options$ybegin_plot,
                            self$options$yend_plot),
                        title = paste0("Cumulative Events ", title2),
                        fun = "event",
                        risk.table = self$options$risktable,
                        conf.int = self$options$ci95,
                        censor = self$options$censored,
                        surv.median.line = self$options$medianline

                    )

                print(plot2)
                TRUE

            }



            # Cumulative Hazard ----
            ,
            .plot3 = function(image3, ggtheme, theme, ...) {
                ch <- self$options$ch

                if (!ch)
                    return()

                results <- image3$state

                if (is.null(results)) {
                    return()
                }

                mytime <- results$name1time
                mytime <- jmvcore::constructFormula(terms = mytime)

                myoutcome <- results$name2outcome
                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)


                myfactor <- results$name3explanatory
                myfactor <-
                    jmvcore::constructFormula(terms = myfactor)

                plotData <- results$cleanData

                plotData[[mytime]] <-
                    jmvcore::toNumeric(plotData[[mytime]])

                myformula <-
                    paste("survival::Surv(", mytime, ",", myoutcome, ")")

                title2 <- as.character(myfactor)


                plot3 <- plotData %>%
                    finalfit::surv_plot(
                        .data = .,
                        dependent = myformula,
                        explanatory = myfactor,
                        xlab = paste0('Time (', self$options$timetypeoutput, ')'),
                        pval = self$options$pplot,
                        pval.method	= self$options$pplot,
                        legend = 'none',
                        break.time.by = self$options$byplot,
                        xlim = c(0, self$options$endplot),
                        ylim = c(
                            self$options$ybegin_plot,
                            self$options$yend_plot),
                        title = paste0("Cumulative Hazard ", title2),
                        fun = "cumhaz",
                        risk.table = self$options$risktable,
                        conf.int = self$options$ci95,
                        censor = self$options$censored,
                        surv.median.line = self$options$medianline

                    )


                print(plot3)
                TRUE
            }


            # KMunicate Style ----
            ,
            .plot6 = function(image6, ggtheme, theme, ...) {
                kmunicate <- self$options$kmunicate

                if (!kmunicate)
                    return()

                results <- image6$state

                if (is.null(results)) {
                    return()
                }

                mytime <- results$name1time
                mytime <- jmvcore::constructFormula(terms = mytime)

                myoutcome <- results$name2outcome
                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)


                myfactor <- results$name3explanatory
                myfactor <-
                    jmvcore::constructFormula(terms = myfactor)

                plotData <- results$cleanData

                plotData[[mytime]] <-
                    jmvcore::toNumeric(plotData[[mytime]])


                title2 <- as.character(myfactor)


                myformula <-
                    paste('survival::Surv(',
                          mytime,
                          ',',
                          myoutcome,
                          ') ~ ',
                          myfactor)

                myformula <- as.formula(myformula)

                km_fit <-
                    survival::survfit(myformula, data = plotData)

                time_scale <-
                    seq(0, self$options$endplot, by = self$options$byplot)


                plot6 <-
                    KMunicate::KMunicate(
                        fit = km_fit,
                        time_scale = time_scale,
                        .xlab = paste0('Time in ', self$options$timetypeoutput)
                    )


                print(plot6)
                TRUE

            }


            # cox.zph ----
            ,
            .plot8 = function(image8, ggtheme, theme, ...) {

                ph_cox <- self$options$ph_cox

                if (!ph_cox)
                    return()

                zph <- image8$state

                if (is.null(zph)) {
                    return()
                }

                plot8 <- plot(zph)

                print(plot8)
                TRUE

            }

        )
    )


File: R\survival.h.R
--------------------------------------------------
Content of R\survival.h.R:

# This file is automatically generated, you probably don't want to edit this

survivalOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "survivalOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            elapsedtime = NULL,
            tint = FALSE,
            dxdate = NULL,
            fudate = NULL,
            explanatory = NULL,
            outcome = NULL,
            outcomeLevel = NULL,
            dod = NULL,
            dooc = NULL,
            awd = NULL,
            awod = NULL,
            analysistype = "overall",
            cutp = "12, 36, 60",
            timetypedata = "ymd",
            timetypeoutput = "months",
            uselandmark = FALSE,
            landmark = 3,
            pw = FALSE,
            padjustmethod = "holm",
            ph_cox = FALSE,
            sc = FALSE,
            kmunicate = FALSE,
            ce = FALSE,
            ch = FALSE,
            endplot = 60,
            ybegin_plot = 0,
            yend_plot = 1,
            byplot = 12,
            multievent = FALSE,
            ci95 = FALSE,
            risktable = FALSE,
            censored = FALSE,
            pplot = TRUE,
            medianline = "none", ...) {

            super$initialize(
                package="jsurvival",
                name="survival",
                requiresData=TRUE,
                ...)

            private$..elapsedtime <- jmvcore::OptionVariable$new(
                "elapsedtime",
                elapsedtime,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..tint <- jmvcore::OptionBool$new(
                "tint",
                tint,
                default=FALSE)
            private$..dxdate <- jmvcore::OptionVariable$new(
                "dxdate",
                dxdate)
            private$..fudate <- jmvcore::OptionVariable$new(
                "fudate",
                fudate)
            private$..calculatedtime <- jmvcore::OptionOutput$new(
                "calculatedtime")
            private$..explanatory <- jmvcore::OptionVariable$new(
                "explanatory",
                explanatory,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..outcome <- jmvcore::OptionVariable$new(
                "outcome",
                outcome,
                suggested=list(
                    "ordinal",
                    "nominal",
                    "continuous"),
                permitted=list(
                    "factor",
                    "numeric"))
            private$..outcomeLevel <- jmvcore::OptionLevel$new(
                "outcomeLevel",
                outcomeLevel,
                variable="(outcome)")
            private$..dod <- jmvcore::OptionLevel$new(
                "dod",
                dod,
                variable="(outcome)",
                allowNone=TRUE)
            private$..dooc <- jmvcore::OptionLevel$new(
                "dooc",
                dooc,
                variable="(outcome)",
                allowNone=TRUE)
            private$..awd <- jmvcore::OptionLevel$new(
                "awd",
                awd,
                variable="(outcome)",
                allowNone=TRUE)
            private$..awod <- jmvcore::OptionLevel$new(
                "awod",
                awod,
                variable="(outcome)",
                allowNone=TRUE)
            private$..analysistype <- jmvcore::OptionList$new(
                "analysistype",
                analysistype,
                options=list(
                    "overall",
                    "cause",
                    "compete"),
                default="overall")
            private$..outcomeredefined <- jmvcore::OptionOutput$new(
                "outcomeredefined")
            private$..cutp <- jmvcore::OptionString$new(
                "cutp",
                cutp,
                default="12, 36, 60")
            private$..timetypedata <- jmvcore::OptionList$new(
                "timetypedata",
                timetypedata,
                options=list(
                    "ymdhms",
                    "ymd",
                    "ydm",
                    "mdy",
                    "myd",
                    "dmy",
                    "dym"),
                default="ymd")
            private$..timetypeoutput <- jmvcore::OptionList$new(
                "timetypeoutput",
                timetypeoutput,
                options=list(
                    "days",
                    "weeks",
                    "months",
                    "years"),
                default="months")
            private$..uselandmark <- jmvcore::OptionBool$new(
                "uselandmark",
                uselandmark,
                default=FALSE)
            private$..landmark <- jmvcore::OptionInteger$new(
                "landmark",
                landmark,
                default=3)
            private$..pw <- jmvcore::OptionBool$new(
                "pw",
                pw,
                default=FALSE)
            private$..padjustmethod <- jmvcore::OptionList$new(
                "padjustmethod",
                padjustmethod,
                options=list(
                    "holm",
                    "hochberg",
                    "hommel",
                    "bonferroni",
                    "BH",
                    "BY",
                    "fdr",
                    "none"),
                default="holm")
            private$..ph_cox <- jmvcore::OptionBool$new(
                "ph_cox",
                ph_cox,
                default=FALSE)
            private$..sc <- jmvcore::OptionBool$new(
                "sc",
                sc,
                default=FALSE)
            private$..kmunicate <- jmvcore::OptionBool$new(
                "kmunicate",
                kmunicate,
                default=FALSE)
            private$..ce <- jmvcore::OptionBool$new(
                "ce",
                ce,
                default=FALSE)
            private$..ch <- jmvcore::OptionBool$new(
                "ch",
                ch,
                default=FALSE)
            private$..endplot <- jmvcore::OptionInteger$new(
                "endplot",
                endplot,
                default=60)
            private$..ybegin_plot <- jmvcore::OptionNumber$new(
                "ybegin_plot",
                ybegin_plot,
                default=0)
            private$..yend_plot <- jmvcore::OptionNumber$new(
                "yend_plot",
                yend_plot,
                default=1)
            private$..byplot <- jmvcore::OptionInteger$new(
                "byplot",
                byplot,
                default=12)
            private$..multievent <- jmvcore::OptionBool$new(
                "multievent",
                multievent,
                default=FALSE)
            private$..ci95 <- jmvcore::OptionBool$new(
                "ci95",
                ci95,
                default=FALSE)
            private$..risktable <- jmvcore::OptionBool$new(
                "risktable",
                risktable,
                default=FALSE)
            private$..censored <- jmvcore::OptionBool$new(
                "censored",
                censored,
                default=FALSE)
            private$..pplot <- jmvcore::OptionBool$new(
                "pplot",
                pplot,
                default=TRUE)
            private$..medianline <- jmvcore::OptionList$new(
                "medianline",
                medianline,
                options=list(
                    "none",
                    "h",
                    "v",
                    "hv"),
                default="none")

            self$.addOption(private$..elapsedtime)
            self$.addOption(private$..tint)
            self$.addOption(private$..dxdate)
            self$.addOption(private$..fudate)
            self$.addOption(private$..calculatedtime)
            self$.addOption(private$..explanatory)
            self$.addOption(private$..outcome)
            self$.addOption(private$..outcomeLevel)
            self$.addOption(private$..dod)
            self$.addOption(private$..dooc)
            self$.addOption(private$..awd)
            self$.addOption(private$..awod)
            self$.addOption(private$..analysistype)
            self$.addOption(private$..outcomeredefined)
            self$.addOption(private$..cutp)
            self$.addOption(private$..timetypedata)
            self$.addOption(private$..timetypeoutput)
            self$.addOption(private$..uselandmark)
            self$.addOption(private$..landmark)
            self$.addOption(private$..pw)
            self$.addOption(private$..padjustmethod)
            self$.addOption(private$..ph_cox)
            self$.addOption(private$..sc)
            self$.addOption(private$..kmunicate)
            self$.addOption(private$..ce)
            self$.addOption(private$..ch)
            self$.addOption(private$..endplot)
            self$.addOption(private$..ybegin_plot)
            self$.addOption(private$..yend_plot)
            self$.addOption(private$..byplot)
            self$.addOption(private$..multievent)
            self$.addOption(private$..ci95)
            self$.addOption(private$..risktable)
            self$.addOption(private$..censored)
            self$.addOption(private$..pplot)
            self$.addOption(private$..medianline)
        }),
    active = list(
        elapsedtime = function() private$..elapsedtime$value,
        tint = function() private$..tint$value,
        dxdate = function() private$..dxdate$value,
        fudate = function() private$..fudate$value,
        calculatedtime = function() private$..calculatedtime$value,
        explanatory = function() private$..explanatory$value,
        outcome = function() private$..outcome$value,
        outcomeLevel = function() private$..outcomeLevel$value,
        dod = function() private$..dod$value,
        dooc = function() private$..dooc$value,
        awd = function() private$..awd$value,
        awod = function() private$..awod$value,
        analysistype = function() private$..analysistype$value,
        outcomeredefined = function() private$..outcomeredefined$value,
        cutp = function() private$..cutp$value,
        timetypedata = function() private$..timetypedata$value,
        timetypeoutput = function() private$..timetypeoutput$value,
        uselandmark = function() private$..uselandmark$value,
        landmark = function() private$..landmark$value,
        pw = function() private$..pw$value,
        padjustmethod = function() private$..padjustmethod$value,
        ph_cox = function() private$..ph_cox$value,
        sc = function() private$..sc$value,
        kmunicate = function() private$..kmunicate$value,
        ce = function() private$..ce$value,
        ch = function() private$..ch$value,
        endplot = function() private$..endplot$value,
        ybegin_plot = function() private$..ybegin_plot$value,
        yend_plot = function() private$..yend_plot$value,
        byplot = function() private$..byplot$value,
        multievent = function() private$..multievent$value,
        ci95 = function() private$..ci95$value,
        risktable = function() private$..risktable$value,
        censored = function() private$..censored$value,
        pplot = function() private$..pplot$value,
        medianline = function() private$..medianline$value),
    private = list(
        ..elapsedtime = NA,
        ..tint = NA,
        ..dxdate = NA,
        ..fudate = NA,
        ..calculatedtime = NA,
        ..explanatory = NA,
        ..outcome = NA,
        ..outcomeLevel = NA,
        ..dod = NA,
        ..dooc = NA,
        ..awd = NA,
        ..awod = NA,
        ..analysistype = NA,
        ..outcomeredefined = NA,
        ..cutp = NA,
        ..timetypedata = NA,
        ..timetypeoutput = NA,
        ..uselandmark = NA,
        ..landmark = NA,
        ..pw = NA,
        ..padjustmethod = NA,
        ..ph_cox = NA,
        ..sc = NA,
        ..kmunicate = NA,
        ..ce = NA,
        ..ch = NA,
        ..endplot = NA,
        ..ybegin_plot = NA,
        ..yend_plot = NA,
        ..byplot = NA,
        ..multievent = NA,
        ..ci95 = NA,
        ..risktable = NA,
        ..censored = NA,
        ..pplot = NA,
        ..medianline = NA)
)

survivalResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "survivalResults",
    inherit = jmvcore::Group,
    active = list(
        subtitle = function() private$.items[["subtitle"]],
        todo = function() private$.items[["todo"]],
        medianSummary = function() private$.items[["medianSummary"]],
        medianTable = function() private$.items[["medianTable"]],
        coxSummary = function() private$.items[["coxSummary"]],
        coxTable = function() private$.items[["coxTable"]],
        tCoxtext2 = function() private$.items[["tCoxtext2"]],
        cox_ph = function() private$.items[["cox_ph"]],
        plot8 = function() private$.items[["plot8"]],
        survTableSummary = function() private$.items[["survTableSummary"]],
        survTable = function() private$.items[["survTable"]],
        pairwiseSummary = function() private$.items[["pairwiseSummary"]],
        pairwiseTable = function() private$.items[["pairwiseTable"]],
        plot = function() private$.items[["plot"]],
        plot2 = function() private$.items[["plot2"]],
        plot3 = function() private$.items[["plot3"]],
        plot6 = function() private$.items[["plot6"]],
        calculatedtime = function() private$.items[["calculatedtime"]],
        outcomeredefined = function() private$.items[["outcomeredefined"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Survival Analysis",
                refs=list(
                    "finalfit",
                    "survival",
                    "survminer",
                    "survivaltutorial",
                    "survivalrwnahhas",
                    "survivalrviews",
                    "appliedsurvivalanalysisR",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="subtitle",
                title="`Survival Analysis - ${explanatory}`"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do",
                clearWith=list(
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="medianSummary",
                title="`Median Survival Summary and Table - ${explanatory}`",
                clearWith=list(
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Table$new(
                options=options,
                name="medianTable",
                title="`Median Survival Table: Levels for ${explanatory}`",
                rows=0,
                columns=list(
                    list(
                        `name`="factor", 
                        `title`="Levels", 
                        `type`="text"),
                    list(
                        `name`="records", 
                        `title`="Records", 
                        `type`="integer"),
                    list(
                        `name`="events", 
                        `title`="Events", 
                        `type`="integer"),
                    list(
                        `name`="rmean", 
                        `title`="rmean", 
                        `type`="number"),
                    list(
                        `name`="se_rmean", 
                        `title`="se_rmean", 
                        `type`="number"),
                    list(
                        `name`="median", 
                        `title`="Median", 
                        `type`="number"),
                    list(
                        `name`="x0_95lcl", 
                        `title`="Lower", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number"),
                    list(
                        `name`="x0_95ucl", 
                        `title`="Upper", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number")),
                clearWith=list(
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="coxSummary",
                title="`Cox Regression Summary and Table - ${explanatory}`",
                clearWith=list(
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Table$new(
                options=options,
                name="coxTable",
                title="`Cox Table- ${explanatory}`",
                rows=0,
                columns=list(
                    list(
                        `name`="Explanatory", 
                        `title`="Explanatory", 
                        `type`="text"),
                    list(
                        `name`="Levels", 
                        `title`="Levels", 
                        `type`="text"),
                    list(
                        `name`="all", 
                        `title`="all", 
                        `type`="text"),
                    list(
                        `name`="HR_univariable", 
                        `title`="HR (Univariable)", 
                        `type`="text")),
                clearWith=list(
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Html$new(
                options=options,
                name="tCoxtext2",
                title="",
                refs="finalfit",
                clearWith=list(
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent",
                    "contexpl")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="cox_ph",
                title="Proportional Hazards Assumption",
                visible="(ph_cox)",
                clearWith=list(
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent",
                    "contexpl")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot8",
                title="`Proportional Hazards Assumption - ${explanatory}`",
                width=600,
                height=450,
                renderFun=".plot8",
                visible="(ph_cox)",
                requiresData=TRUE,
                clearWith=list(
                    "ph_cox",
                    "endplot",
                    "byplot",
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="survTableSummary",
                title="`1, 3, 5-yr Survival Summary and Table  - ${explanatory}`",
                clearWith=list(
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Table$new(
                options=options,
                name="survTable",
                title="`1, 3, 5 year Survival - ${explanatory}`",
                rows=0,
                columns=list(
                    list(
                        `name`="strata", 
                        `title`="Levels", 
                        `type`="text"),
                    list(
                        `name`="time", 
                        `title`="time", 
                        `type`="integer"),
                    list(
                        `name`="n.risk", 
                        `title`="Number at Risk", 
                        `type`="integer"),
                    list(
                        `name`="n.event", 
                        `title`="Number of Events", 
                        `type`="integer"),
                    list(
                        `name`="surv", 
                        `title`="Survival", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="lower", 
                        `title`="Lower", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="upper", 
                        `title`="Upper", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number", 
                        `format`="pc")),
                clearWith=list(
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="pairwiseSummary",
                title="`Pairwise Comparison Summary and Table - ${explanatory}`",
                clearWith=list(
                    "pw",
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent"),
                visible="(pw)"))
            self$add(jmvcore::Table$new(
                options=options,
                name="pairwiseTable",
                title="`Pairwise Comparison Table - ${explanatory}`",
                rows=0,
                columns=list(
                    list(
                        `name`="rowname", 
                        `title`="Levels", 
                        `type`="text"),
                    list(
                        `name`="name", 
                        `title`="Levels", 
                        `type`="text"),
                    list(
                        `name`="value", 
                        `title`="p-value", 
                        `type`="number", 
                        `format`="zto,pvalue")),
                visible="(pw)",
                clearWith=list(
                    "pw",
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent"),
                refs=list(
                    "padjust")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot",
                title="`Survival Plot - ${explanatory}`",
                width=600,
                height=450,
                renderFun=".plot",
                visible="(sc)",
                requiresData=TRUE,
                clearWith=list(
                    "sc",
                    "endplot",
                    "byplot",
                    "ybegin_plot",
                    "yend_plot",
                    "ci95",
                    "risktable",
                    "censored",
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent",
                    "pplot")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot2",
                title="`Cumulative Events - ${explanatory}`",
                width=600,
                height=450,
                renderFun=".plot2",
                visible="(ce)",
                requiresData=TRUE,
                clearWith=list(
                    "ce",
                    "endplot",
                    "byplot",
                    "ybegin_plot",
                    "yend_plot",
                    "ci95",
                    "risktable",
                    "censored",
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot3",
                title="`Cumulative Hazard - ${explanatory}`",
                width=600,
                height=450,
                renderFun=".plot3",
                visible="(ch)",
                requiresData=TRUE,
                clearWith=list(
                    "ch",
                    "endplot",
                    "byplot",
                    "ybegin_plot",
                    "yend_plot",
                    "ci95",
                    "risktable",
                    "censored",
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot6",
                title="`KMunicate-Style Plot - ${explanatory}`",
                width=600,
                height=450,
                renderFun=".plot6",
                visible="(kmunicate)",
                requiresData=TRUE,
                clearWith=list(
                    "kmunicate",
                    "endplot",
                    "byplot",
                    "ybegin_plot",
                    "yend_plot",
                    "explanatory",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent"),
                refs=list(
                    "KMunicate",
                    "KMunicate2")))
            self$add(jmvcore::Output$new(
                options=options,
                name="calculatedtime",
                title="Add Calculated Time to Data",
                varTitle="`Calculated Time - from ${ dxdate } to { fudate }`",
                varDescription="`Calculated Time from Given Dates - from ${ dxdate } to { fudate } in Survival Analysis`",
                measureType="continuous",
                clearWith=list(
                    "tint",
                    "dxdate",
                    "fudate",
                    "overalltime",
                    "calculatedtime")))
            self$add(jmvcore::Output$new(
                options=options,
                name="outcomeredefined",
                title="Add Redefined Outcome to Data",
                varTitle="`Redefined Outcome - from ${ outcome } for { analysistype } survival analysis`",
                varDescription="Redefined Outcome from Outcome based on Analysis Type in Survival Analysis",
                clearWith=list(
                    "outcome",
                    "analysistype",
                    "multievent",
                    "explanatory",
                    "outcomeLevel")))}))

survivalBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "survivalBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "jsurvival",
                name = "survival",
                version = c(1,0,0),
                options = options,
                results = survivalResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'none')
        }))

#' Survival Analysis
#'
#' Function for Generating Summaries for Survival Analysis.
#'
#' @examples
#' # example will be added
#'
#' @param data The data as a data frame.
#' @param elapsedtime The time elapsed from the start of the study to the
#'   event or censoring.
#' @param tint If the time is in date format, select this option to calculate
#'   the survival time. The time will be calculated as the difference between
#'   the event date and the diagnosis date. If the follow-up date is available,
#'   the time will be  calculated as the difference between the event date and
#'   the follow-up date.
#' @param dxdate The date of diagnosis. If the time is in date format, the
#'   time will be calculated as the difference between the event date and the
#'   diagnosis date.
#' @param fudate The date of follow-up. If the time is in date format, the
#'   time will be calculated as the difference between the event date and the
#'   follow-up date.
#' @param explanatory The explanatory variable that will be used to compare
#'   the survival times of different groups.
#' @param outcome The outcome variable that will be used to compare the
#'   survival times of different groups.
#' @param outcomeLevel The level of the outcome variable that will be used as
#'   the event level.
#' @param dod .
#' @param dooc .
#' @param awd .
#' @param awod .
#' @param analysistype .
#' @param cutp .
#' @param timetypedata select the time type in data
#' @param timetypeoutput select the time type in output
#' @param uselandmark .
#' @param landmark .
#' @param pw .
#' @param padjustmethod .
#' @param ph_cox .
#' @param sc .
#' @param kmunicate .
#' @param ce .
#' @param ch .
#' @param endplot .
#' @param ybegin_plot .
#' @param yend_plot .
#' @param byplot .
#' @param multievent .
#' @param ci95 .
#' @param risktable .
#' @param censored .
#' @param pplot .
#' @param medianline If true, displays a line indicating the median survival
#'   time on the survival plot.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$subtitle} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$medianSummary} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$medianTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$coxSummary} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$coxTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$tCoxtext2} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$cox_ph} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$plot8} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$survTableSummary} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$survTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$pairwiseSummary} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$pairwiseTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$plot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plot2} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plot3} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plot6} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$calculatedtime} \tab \tab \tab \tab \tab an output \cr
#'   \code{results$outcomeredefined} \tab \tab \tab \tab \tab an output \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$medianTable$asDF}
#'
#' \code{as.data.frame(results$medianTable)}
#'
#' @export
survival <- function(
    data,
    elapsedtime,
    tint = FALSE,
    dxdate,
    fudate,
    explanatory,
    outcome,
    outcomeLevel,
    dod,
    dooc,
    awd,
    awod,
    analysistype = "overall",
    cutp = "12, 36, 60",
    timetypedata = "ymd",
    timetypeoutput = "months",
    uselandmark = FALSE,
    landmark = 3,
    pw = FALSE,
    padjustmethod = "holm",
    ph_cox = FALSE,
    sc = FALSE,
    kmunicate = FALSE,
    ce = FALSE,
    ch = FALSE,
    endplot = 60,
    ybegin_plot = 0,
    yend_plot = 1,
    byplot = 12,
    multievent = FALSE,
    ci95 = FALSE,
    risktable = FALSE,
    censored = FALSE,
    pplot = TRUE,
    medianline = "none") {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("survival requires jmvcore to be installed (restart may be required)")

    if ( ! missing(elapsedtime)) elapsedtime <- jmvcore::resolveQuo(jmvcore::enquo(elapsedtime))
    if ( ! missing(dxdate)) dxdate <- jmvcore::resolveQuo(jmvcore::enquo(dxdate))
    if ( ! missing(fudate)) fudate <- jmvcore::resolveQuo(jmvcore::enquo(fudate))
    if ( ! missing(explanatory)) explanatory <- jmvcore::resolveQuo(jmvcore::enquo(explanatory))
    if ( ! missing(outcome)) outcome <- jmvcore::resolveQuo(jmvcore::enquo(outcome))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(elapsedtime), elapsedtime, NULL),
            `if`( ! missing(dxdate), dxdate, NULL),
            `if`( ! missing(fudate), fudate, NULL),
            `if`( ! missing(explanatory), explanatory, NULL),
            `if`( ! missing(outcome), outcome, NULL))

    for (v in explanatory) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- survivalOptions$new(
        elapsedtime = elapsedtime,
        tint = tint,
        dxdate = dxdate,
        fudate = fudate,
        explanatory = explanatory,
        outcome = outcome,
        outcomeLevel = outcomeLevel,
        dod = dod,
        dooc = dooc,
        awd = awd,
        awod = awod,
        analysistype = analysistype,
        cutp = cutp,
        timetypedata = timetypedata,
        timetypeoutput = timetypeoutput,
        uselandmark = uselandmark,
        landmark = landmark,
        pw = pw,
        padjustmethod = padjustmethod,
        ph_cox = ph_cox,
        sc = sc,
        kmunicate = kmunicate,
        ce = ce,
        ch = ch,
        endplot = endplot,
        ybegin_plot = ybegin_plot,
        yend_plot = yend_plot,
        byplot = byplot,
        multievent = multievent,
        ci95 = ci95,
        risktable = risktable,
        censored = censored,
        pplot = pplot,
        medianline = medianline)

    analysis <- survivalClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



File: R\survivalcont.b.R
--------------------------------------------------
Content of R\survivalcont.b.R:
#' @title Survival Analysis for Continuous Explanatory Variable
#' @importFrom R6 R6Class
#' @import jmvcore
#' @import magrittr

survivalcontClass <- if (requireNamespace("jmvcore")) {
    R6::R6Class(
        "survivalcontClass",
        inherit = survivalcontBase,
        private = list(


            # init ----
            .init = function() {
                if (!self$options$findcut) {
                    # Disable other tables
                    self$results$medianSummary$setVisible(FALSE)
                    self$results$medianTable$setVisible(FALSE)
                    self$results$survTableSummary$setVisible(FALSE)
                    self$results$survTable$setVisible(FALSE)
                }
            }

            # getData ----
            ,
            .getData = function() {
                mydata <- self$data

                mydata$row_names <- rownames(mydata)

                original_names <- names(mydata)

                labels <- setNames(original_names, original_names)

                mydata <- mydata %>% janitor::clean_names()

                corrected_labels <-
                    setNames(original_names, names(mydata))

                mydata <- labelled::set_variable_labels(
                    .data = mydata,
                    .labels = corrected_labels
                )

                all_labels <- labelled::var_label(mydata)


                mytime <-
                    names(all_labels)[all_labels == self$options$elapsedtime]

                myoutcome <-
                    names(all_labels)[all_labels == self$options$outcome]

                mydxdate <-
                    names(all_labels)[all_labels == self$options$dxdate]

                myfudate <-
                    names(all_labels)[all_labels == self$options$fudate]

                mycontexpl <-
                    names(all_labels)[all_labels == self$options$contexpl]

                return(list(
                    "mydata_labelled" = mydata,
                    "mytime_labelled" = mytime,
                    "myoutcome_labelled" = myoutcome,
                    "mydxdate_labelled" = mydxdate,
                    "myfudate_labelled" = myfudate,
                    "mycontexpl_labelled" = mycontexpl
                ))
            }


            # todo ----
            ,
            .todo = function() {
                todo <- glue::glue(
                    "
                <br>Welcome to ClinicoPath
                <br><br>
                This tool will help you calculate a cut-off for a continuous variable based on survival outcome.
                <br>
                After the cut-off is determined median survivals and 1,3,5-yr survivals are calculated.
                <br><br>
                Explanatory variable is continuous.
                <br><br>
                Select outcome level from Outcome variable.
                <br><br>
                Outcome Level: if patient is dead or event (recurrence) occured. You may also use advanced outcome options depending on your analysis type.
                <br><br>
                Survival time should be numeric and continuous. You may also use dates to calculate survival time in advanced elapsed time options.
                <br><br>
                This function uses survival, survminer, and finalfit packages. Please cite jamovi and the packages as given below.
                <br><hr>
                <br>
                See details for survival <a href = 'https://cran.r-project.org/web/packages/survival/vignettes/survival.pdf'>here</a>."
                )

                html <- self$results$todo
                html$setContent(todo)
            }




            # Define Survival Time ----
            ,
            .definemytime = function() {

            ## Read Labelled Data ----

            labelled_data <- private$.getData()

            mydata <- labelled_data$mydata_labelled
            mytime_labelled <- labelled_data$mytime_labelled
            mydxdate_labelled <- labelled_data$mydxdate_labelled
            myfudate_labelled <- labelled_data$myfudate_labelled

            tint <- self$options$tint


                if (!tint) {
                    ### Precalculated Time ----

                    mydata[["mytime"]] <-
                        jmvcore::toNumeric(mydata[[mytime_labelled]])


                } else if (tint) {
                    ### Time Interval ----

                    dxdate <- mydxdate_labelled
                    fudate <- myfudate_labelled
                    timetypedata <- self$options$timetypedata


                    # # Define a mapping from timetypedata to lubridate functions
                    # lubridate_functions <- list(
                    #     ymdhms = lubridate::ymd_hms,
                    #     ymd = lubridate::ymd,
                    #     ydm = lubridate::ydm,
                    #     mdy = lubridate::mdy,
                    #     myd = lubridate::myd,
                    #     dmy = lubridate::dmy,
                    #     dym = lubridate::dym
                    # )
                    # # Apply the appropriate lubridate function based on timetypedata
                    # if (timetypedata %in% names(lubridate_functions)) {
                    #     func <- lubridate_functions[[timetypedata]]
                    #     mydata[["start"]] <- func(mydata[[dxdate]])
                    #     mydata[["end"]] <- func(mydata[[fudate]])
                    # }


                    if (timetypedata == "ymdhms") {
                        mydata[["start"]] <- lubridate::ymd_hms(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::ymd_hms(mydata[[fudate]])
                    }
                    if (timetypedata == "ymd") {
                        mydata[["start"]] <- lubridate::ymd(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::ymd(mydata[[fudate]])
                    }
                    if (timetypedata == "ydm") {
                        mydata[["start"]] <- lubridate::ydm(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::ydm(mydata[[fudate]])
                    }
                    if (timetypedata == "mdy") {
                        mydata[["start"]] <- lubridate::mdy(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::mdy(mydata[[fudate]])
                    }
                    if (timetypedata == "myd") {
                        mydata[["start"]] <- lubridate::myd(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::myd(mydata[[fudate]])
                    }
                    if (timetypedata == "dmy") {
                        mydata[["start"]] <- lubridate::dmy(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::dmy(mydata[[fudate]])
                    }
                    if (timetypedata == "dym") {
                        mydata[["start"]] <- lubridate::dym(mydata[[dxdate]])
                        mydata[["end"]] <-
                            lubridate::dym(mydata[[fudate]])
                    }


                    if ( sum(!is.na(mydata[["start"]])) == 0 || sum(!is.na(mydata[["end"]])) == 0)  {
                        stop(paste0("Time difference cannot be calculated. Make sure that time type in variables are correct. Currently it is: ", self$options$timetypedata)
                        )
                    }

                    timetypeoutput <-
                        jmvcore::constructFormula(terms = self$options$timetypeoutput)


                    mydata <- mydata %>%
                        dplyr::mutate(interval = lubridate::interval(start, end))


                    mydata <- mydata %>%
                        dplyr::mutate(mytime = lubridate::time_length(interval,
                                                                      timetypeoutput))

                }


                df_time <- mydata %>% jmvcore::select(c("row_names", "mytime"))

                return(df_time)


            }

            # Define Outcome ----
            ,
            .definemyoutcome = function() {


            labelled_data <- private$.getData()

            mydata <- labelled_data$mydata_labelled
            myoutcome_labelled <- labelled_data$myoutcome_labelled


                contin <- c("integer", "numeric", "double")

                outcomeLevel <- self$options$outcomeLevel
                multievent <- self$options$multievent

                outcome1 <- mydata[[myoutcome_labelled]]

                if (!multievent) {
                    if (inherits(outcome1, contin)) {
                        if (!((length(unique(
                            outcome1[!is.na(outcome1)]
                        )) == 2) && (sum(unique(
                            outcome1[!is.na(outcome1)]
                        )) == 1))) {
                            stop(
                                'When using continuous variable as an outcome, it must only contain 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0.'
                            )

                        }

                        mydata[["myoutcome"]] <- mydata[[myoutcome_labelled]]
                            # mydata[[self$options$outcome]]

                    } else if (inherits(outcome1, "factor")) {
                        mydata[["myoutcome"]] <-
                            ifelse(
                                test = outcome1 == outcomeLevel,
                                yes = 1,
                                no = 0
                            )

                    } else {
                        stop(
                            'When using continuous variable as an outcome, it must only contain 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0. If you are using a factor as an outcome, please check the levels and content.'
                        )

                    }

                } else if (multievent) {
                    analysistype <- self$options$analysistype

                    dod <- self$options$dod
                    dooc <- self$options$dooc
                    awd <- self$options$awd
                    awod <- self$options$awod

                    if (analysistype == 'overall') {
                        # Overall ----
                        # (Alive) <=> (Dead of Disease & Dead of Other Causes)


                        mydata[["myoutcome"]] <- NA_integer_

                        mydata[["myoutcome"]][outcome1 == awd] <- 0
                        mydata[["myoutcome"]][outcome1 == awod] <- 0
                        mydata[["myoutcome"]][outcome1 == dod] <- 1
                        mydata[["myoutcome"]][outcome1 == dooc] <- 1



                    } else if (analysistype == 'cause') {
                        # Cause Specific ----
                        # (Alive & Dead of Other Causes) <=> (Dead of Disease)


                        mydata[["myoutcome"]] <- NA_integer_

                        mydata[["myoutcome"]][outcome1 == awd] <- 0
                        mydata[["myoutcome"]][outcome1 == awod] <- 0
                        mydata[["myoutcome"]][outcome1 == dod] <- 1
                        mydata[["myoutcome"]][outcome1 == dooc] <- 0

                    } else if (analysistype == 'compete') {
                        # Competing Risks ----
                        # Alive <=> Dead of Disease accounting for Dead of Other Causes

                        # https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#part_3:_competing_risks


                        mydata[["myoutcome"]] <- NA_integer_

                        mydata[["myoutcome"]][outcome1 == awd] <- 0
                        mydata[["myoutcome"]][outcome1 == awod] <- 0
                        mydata[["myoutcome"]][outcome1 == dod] <- 1
                        mydata[["myoutcome"]][outcome1 == dooc] <- 2

                    }

                }

                df_outcome <- mydata %>% jmvcore::select(c("row_names", "myoutcome"))

                return(df_outcome)

            }


            # Define Factor ----
            ,

            .definemyfactor = function() {


            labelled_data <- private$.getData()

            mydata_labelled <- labelled_data$mydata_labelled
            mycontexpl_labelled <- labelled_data$mycontexpl_labelled

            mydata <- mydata_labelled

            mydata[["myfactor"]] <- mydata[[mycontexpl_labelled]]


            df_factor <- mydata %>% jmvcore::select(c("row_names","myfactor"))

            return(df_factor)

            }


            # Clean Data For Analysis ----
            ,
            .cleandata = function() {

            labelled_data <- private$.getData()

            mydata_labelled        <- labelled_data$mydata_labelled
            mytime_labelled        <- labelled_data$mytime_labelled
            myoutcome_labelled     <- labelled_data$myoutcome_labelled
            mydxdate_labelled      <- labelled_data$mydxdate_labelled
            myfudate_labelled      <- labelled_data$myfudate_labelled
            mycontexpl_labelled <- labelled_data$mycontexpl_labelled

                time <- private$.definemytime()
                outcome <- private$.definemyoutcome()
                factor <- private$.definemyfactor()

                cleanData <- dplyr::left_join(time, outcome, by = "row_names") %>%
                    dplyr::left_join(factor, by = "row_names")

                # Landmark ----
                # https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#landmark_method
                if (self$options$uselandmark) {

                  landmark <- jmvcore::toNumeric(self$options$landmark)

                    cleanData <- cleanData %>%
                        dplyr::filter(mytime >= landmark) %>%
                        dplyr::mutate(mytime = mytime - landmark)
                }

                # Names cleanData ----

                if (self$options$tint) {
                    name1time <- "CalculatedTime"
                }

                if (!self$options$tint &&
                    !is.null(self$options$elapsedtime)) {
                    name1time <- mytime_labelled
                }

                name2outcome <- myoutcome_labelled

                if (self$options$multievent) {
                    name2outcome <- "CalculatedOutcome"
                }

                if (!is.null(self$options$contexpl)
                    ) {
                    name3contexpl <- mycontexpl_labelled
                    }

                    cleanData <- cleanData %>%
                        dplyr::rename(
                            !!name1time := mytime,
                            !!name2outcome := myoutcome,
                            !!name3contexpl := myfactor
                        )

                # naOmit ----

                cleanData <- jmvcore::naOmit(cleanData)

                # Return Data ----

                return(
                    list(
                        "name1time" = name1time,
                        "name2outcome" = name2outcome,
                        "name3contexpl" = name3contexpl,
                        "cleanData" = cleanData,
                        "mytime_labelled" = mytime_labelled,
                        "myoutcome_labelled" = myoutcome_labelled,
                        "mydxdate_labelled" = mydxdate_labelled,
                        "myfudate_labelled" = myfudate_labelled,
                        "mycontexpl_labelled" = mycontexpl_labelled
                    )
                )

            }



            # Run Analysis ----
            ,
            .run = function() {

                # Errors, Warnings ----

                ## No variable todo ----

                ## Define subconditions ----

                subcondition1a <- !is.null(self$options$outcome)
                subcondition1b1 <- self$options$multievent
                subcondition1b2 <- !is.null(self$options$dod)
                subcondition1b3 <- !is.null(self$options$dooc)
                # subcondition1b4 <- !is.null(self$options$awd)
                # subcondition1b5 <- !is.null(self$options$awod)
                subcondition2a <- !is.null(self$options$elapsedtime)
                subcondition2b1 <- self$options$tint
                subcondition2b2 <- !is.null(self$options$dxdate)
                subcondition2b3 <- !is.null(self$options$fudate)
                condition3 <- !is.null(self$options$contexpl)

                condition1 <- subcondition1a && !subcondition1b1 || subcondition1b1 && subcondition1b2 || subcondition1b1 && subcondition1b3

                condition2 <- subcondition2b1 && subcondition2b2 && subcondition2b3 || subcondition2a && !subcondition2b1 && !subcondition2b2 && !subcondition2b3

                not_continue_analysis <- !(condition1 && condition2 && condition3)


                if (not_continue_analysis) {
                    private$.todo()
                    self$results$coxSummary$setVisible(FALSE)
                    self$results$coxTable$setVisible(FALSE)
                    self$results$tCoxtext2$setVisible(FALSE)
                    self$results$rescutTable$setVisible(FALSE)
                    self$results$medianSummary$setVisible(FALSE)
                    self$results$medianTable$setVisible(FALSE)
                    self$results$survTableSummary$setVisible(FALSE)
                    self$results$survTable$setVisible(FALSE)
                    self$results$plot4$setVisible(FALSE)
                    self$results$plot5$setVisible(FALSE)
                    self$results$plot2$setVisible(FALSE)
                    self$results$plot3$setVisible(FALSE)
                    self$results$plot6$setVisible(FALSE)
                    self$results$todo$setVisible(TRUE)
                    return()
                } else {
                  self$results$todo$setVisible(FALSE)
                }


                ## Empty data ----

                if (nrow(self$data) == 0)
                    stop('Data contains no (complete) rows')

                # Get Clean Data ----
                results <- private$.cleandata()

                # Run Analysis ----

                ## Run Continious Cox Regression ----
                private$.cox(results)

                ## Run Cut-off calculation and further analysis ----
                if (!self$options$findcut) {
                    return()
                }


                ## Run Cut-off calculation ----
                res.cut <- private$.cutoff(results)

                ## Run Cut-off Table ----
                private$.cutoffTable(res.cut)

                ## Run Categorise Data ----
                cutoffdata <- private$.cutoff2(res.cut)




                # self$results$mydataview$setContent(
                #     list(
                #         res.cut = res.cut,
                #         cutoffdata = cutoffdata,
                #         not_continue_analysis = not_continue_analysis
                #     )
                # )



                ## Run median cutoff ----

                private$.mediancutoff(cutoffdata)

                ## Run life table cutoff ----

                private$.lifetablecutoff(cutoffdata)

                # Prepare Data For Plots ----

                plotData1 <- list(res.cut = res.cut,
                                  name3contexpl = results$name3contexpl
                                  # ,
                                  # not_continue_analysis = not_continue_analysis
                )

                # self$results$mydataview2$setContent(plotData1)


                image4 <- self$results$plot4
                image4$setState(plotData1)

                plotData2 <- list(
                    cutoffdata = cutoffdata,
                    results = results
                    # ,
                    # not_continue_analysis = not_continue_analysis
                    )

                image5 <- self$results$plot5
                image5$setState(plotData2)

                image2 <- self$results$plot2
                image2$setState(plotData2)

                image3 <- self$results$plot3
                image3$setState(plotData2)

                image6 <- self$results$plot6
                image6$setState(plotData2)



                # Add Calculated Time to Data ----


                if (self$options$tint && self$options$calculatedtime && self$results$calculatedtime$isNotFilled()) {
                    self$results$calculatedtime$setRowNums(results$cleanData$row_names)
                    self$results$calculatedtime$setValues(results$cleanData$CalculatedTime)
                }


                # Add Redefined Outcome to Data ----

                if (self$options$multievent  && self$options$outcomeredefined && self$results$outcomeredefined$isNotFilled()) {
                    self$results$outcomeredefined$setRowNums(results$cleanData$row_names)
                    self$results$outcomeredefined$setValues(results$cleanData$CalculatedOutcome)
                }


                # Add calculatedcutoff to Data ----

                cutoffgr <- cutoffdata[[results$name3contexpl]]

                if (self$options$calculatedcutoff &&
                        self$results$calculatedcutoff$isNotFilled()) {
                        self$results$calculatedcutoff$setValues(cutoffgr)
                }

            }





            # Continious Cox Regression ----
            ,
            .cox = function(results) {

                ## Cox Regression ----

                mytime <- results$name1time
                mytime <- jmvcore::constructFormula(terms = mytime)

                myoutcome <- results$name2outcome
                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)


                myfactor <- results$name3contexpl
                myfactor <-
                    jmvcore::constructFormula(terms = myfactor)

                mydata <- results$cleanData

                mydata[[mytime]] <-
                    jmvcore::toNumeric(mydata[[mytime]])

                myformula <-
                    paste("Surv(", mytime, ",", myoutcome, ")")

                finalfit::finalfit(
                    .data = mydata,
                    dependent = myformula,
                    explanatory = myfactor,
                    metrics = TRUE
                ) -> tCox


                tCoxtext2 <- glue::glue(
                    "
                                <br>
                                <b>Model Metrics:</b>
                                  ",
                    unlist(tCox[[2]]),
                    "
                                <br>
                                "
                )


                if (self$options$uselandmark) {
                    landmark <- jmvcore::toNumeric(self$options$landmark)

                    tCoxtext2 <- glue::glue(
                        tCoxtext2,
                        "Landmark time used as: ",
                        landmark, " ",
                        self$options$timetypeoutput, "."
                    )
                }


                self$results$tCoxtext2$setContent(tCoxtext2)


                tCox_df <-
                    tibble::as_tibble(tCox[[1]], .name_repair = "minimal") %>%
                    janitor::clean_names(dat = ., case = "snake")


                # Continious Cox-Regression Table ----

                coxTable <- self$results$coxTable

                data_frame <- tCox_df

                names(data_frame) <- c(
                    "contexpl",
                    "Levels",
                    "all",
                    "HR_univariable",
                    "HR_multivariable"
                )

                for (i in seq_along(data_frame[, 1, drop = T])) {
                    coxTable$addRow(rowKey = i, values = c(data_frame[i, ]))
                }


                # Continious coxTable explanation ----


                tCox_df <-
                    tibble::as_tibble(tCox[[1]], .name_repair = "minimal") %>%
                    janitor::clean_names(dat = ., case = "snake")

                names(tCox_df) <- names(data_frame) <- c(
                    "Explanatory",
                    "Levels",
                    "all",
                    "HR_univariable",
                    "HR_multivariable"
                )


                # https://stackoverflow.com/questions/38470355/r-fill-empty-cell-with-value-of-last-non-empty-cell

                while (length(ind <-
                    which(tCox_df$Explanatory == "")) > 0) {
                    tCox_df$Explanatory[ind] <- tCox_df$Explanatory[ind - 1]
                }

                # https://stackoverflow.com/questions/51180290/mutate-by-group-in-r

                tCox_df %>%
                    dplyr::group_by(Explanatory) %>%
                    dplyr::mutate(firstlevel = dplyr::first(Levels)) %>%
                    dplyr::mutate(
                        coxdescription = glue::glue(
                            "When {Explanatory} increases 1 unit, the hazard increases {HR_multivariable} times."
                        )
                    ) %>%
                    dplyr::filter(HR_univariable != "-") %>%
                    dplyr::pull(coxdescription) -> coxSummary



                coxSummary <- unlist(coxSummary)
                self$results$coxSummary$setContent(coxSummary)
            }



                # Continuous Optimal Cut-off ----
            ,
            .cutoff = function(results) {


                mytime <- results$name1time
                mytime <- jmvcore::constructFormula(terms = mytime)

                myoutcome <- results$name2outcome
                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)


                myfactor <- results$name3contexpl
                myfactor <-
                    jmvcore::constructFormula(terms = myfactor)

                mydata <- results$cleanData

                mydata[[mytime]] <-
                    jmvcore::toNumeric(mydata[[mytime]])

                # https://rpkgs.datanovia.com/survminer/reference/surv_cutpoint.html

                res.cut <- survminer::surv_cutpoint(
                    mydata,
                    time = mytime,
                    event = myoutcome,
                    variables = myfactor,
                    minprop = 0.1
                    # ,
                    # progressbar = TRUE
                )

                return(res.cut)

            }

            # Cut-off Table ----
            ,
            .cutoffTable = function(res.cut) {
                rescut_summary <- summary(res.cut)

                rescutTable <- self$results$rescutTable

                rescutTable$setTitle(paste0(
                  "Optimal Cutpoint Analysis for ", self$options$contexpl,
                  " \n The cutpoint maximizes the statistical difference between groups while maintaining sufficient sample sizes"
                ))



                # rescutTable$setTitle(paste0(self$options$contexpl))

                data_frame <- rescut_summary
                for (i in seq_along(data_frame[, 1, drop = T])) {
                    rescutTable$addRow(rowKey = i, values = c(data_frame[i, ]))
                }
            }

            # Categorise Data ----
            ,
            .cutoff2 = function(res.cut) {
                res.cat <- survminer::surv_categorize(res.cut)
                return(res.cat)
            }


            # Median ----
            ,
            .mediancutoff = function(cutoffdata) {

                results <- private$.cleandata()

                mydata <- cutoffdata

                ## Median Survival Table ----

                mytime <- results$name1time
                myoutcome <- results$name2outcome
                mycontexpl <- results$name3contexpl


                mytime <-
                    jmvcore::constructFormula(terms = mytime)

                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)

                mycontexpl <-
                    jmvcore::constructFormula(terms = mycontexpl)


                mydata[[mytime]] <-
                    jmvcore::toNumeric(mydata[[mytime]])


                formula <-
                    paste('survival::Surv(',
                          mytime,
                          ',',
                          myoutcome,
                          ') ~ ',
                          mycontexpl)

                formula <- as.formula(formula)

                km_fit <- survival::survfit(formula, data = mydata)


                km_fit_median_df <- summary(km_fit)

                results1html <-
                    as.data.frame(km_fit_median_df$table) %>%
                    janitor::clean_names(dat = ., case = "snake") %>%
                    tibble::rownames_to_column(.data = .)


                results1html[, 1] <- gsub(
                    pattern = ", ",
                    replacement = " and ",
                    x = results1html[, 1]
                )

                results1table <- results1html

                results1table <- results1html

                names(results1table)[1] <- "factor"


                results2table <- results1table

                results2table$factor <- gsub(pattern = paste0(mycontexpl,"="),
                                             replacement = "",
                                             x = results1table$factor)

                # self$results$mydataview$setContent(
                #     list(
                #         results2table = results2table
                #     )
                # )


                medianTable <- self$results$medianTable
                data_frame <- results2table
                for (i in seq_along(data_frame[, 1, drop = T])) {
                    medianTable$addRow(rowKey = i, values = c(data_frame[i,]))
                }


                ## Median Survival Summary ----

                results1table %>%
                    dplyr::mutate(
                        description =
                            glue::glue(
                                "When {factor}, median survival is {round(median, digits = 1)} [{round(x0_95lcl, digits = 1)} - {round(x0_95ucl, digits = 1)}, 95% CI] ",
                                self$options$timetypeoutput,
                                "."
                            )
                    ) %>%
                    dplyr::mutate(
                        description = dplyr::case_when(
                            is.na(median) ~ paste0(
                                glue::glue("{description} \n Note that when {factor}, the survival curve does not drop below 1/2 during \n the observation period, thus the median survival is undefined.")),
                            TRUE ~ paste0(description)
                        )
                    ) %>%
                    dplyr::mutate(description = gsub(
                        pattern = "=",
                        replacement = " is ",
                        x = description
                    )) %>%
                    dplyr::mutate(description = gsub(
                        pattern = mycontexpl,
                        replacement = self$options$contexpl,
                        x = description
                    )) %>%
                    dplyr::select(description) %>%
                    dplyr::pull(.) -> km_fit_median_definition

                medianSummary <- c(km_fit_median_definition,
                                   "The median survival time is when 50% of subjects have experienced the event.",
                                   "This means that 50% of subjects in this group survived longer than this time period."
                )


                self$results$medianSummary$setContent(medianSummary)

            }


            # Life Table ----
            ,
            .lifetablecutoff = function(cutoffdata) {


                # survival table 1,3,5-yr survival ----

                utimes <- self$options$cutp

                utimes <- strsplit(utimes, ",")
                utimes <- purrr::reduce(utimes, as.vector)
                utimes <- as.numeric(utimes)

                if (length(utimes) == 0) {
                    utimes <- c(12, 36, 60)
                }

                results <- private$.cleandata()

                mydata <- cutoffdata

                mytime <- results$name1time
                myoutcome <- results$name2outcome
                mycontexpl <- results$name3contexpl


                mytime <-
                    jmvcore::constructFormula(terms = mytime)

                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)

                mycontexpl <-
                    jmvcore::constructFormula(terms = mycontexpl)


                mydata[[mytime]] <-
                    jmvcore::toNumeric(mydata[[mytime]])


                formula <-
                    paste('survival::Surv(',
                          mytime,
                          ',',
                          myoutcome,
                          ') ~ ',
                          mycontexpl)

                formula <- as.formula(formula)

                km_fit <- survival::survfit(formula, data = mydata)

                km_fit_summary <- summary(km_fit, times = utimes, extend = TRUE)

                km_fit_df <-
                    as.data.frame(km_fit_summary[c(
                        "strata",
                        "time",
                        "n.risk",
                        "n.event",
                        "surv",
                        "std.err",
                        "lower",
                        "upper"
                    )])

                km_fit_df[, 1] <- gsub(
                    pattern = "thefactor=",
                    replacement = paste0(self$options$contexpl, " "),
                    x = km_fit_df[, 1]
                )


                km_fit_df2 <- km_fit_df

                km_fit_df2$strata <- gsub(pattern = paste0(mycontexpl,"="),
                                             replacement = "",
                                             x =km_fit_df2$strata)

                data_frame <- km_fit_df2

                survTable <- self$results$survTable


                for (i in seq_along(data_frame[, 1, drop = T])) {
                    survTable$addRow(rowKey = i, values = c(data_frame[i, ]))
                }




                # survTableSummary 1,3,5-yr survival summary ----

                km_fit_df[, 1] <- gsub(
                    pattern = paste0(mycontexpl,"="),
                    replacement = paste0(self$options$contexpl, " is "),
                    x = km_fit_df[, 1]
                )


                km_fit_df %>%
                    dplyr::mutate(
                        description =
                            glue::glue(
                                "When {strata}, {time} month survival is {scales::percent(surv)} [{scales::percent(lower)}-{scales::percent(upper)}, 95% CI]."
                            )
                    ) %>%
                    dplyr::select(description) %>%
                    dplyr::pull(.) -> survTableSummary

                self$results$survTableSummary$setContent(survTableSummary)
            }

            # Cut-off Plot ----
            ,
            .plot4 = function(image4, ggtheme, theme, ...) {

                if (!self$options$findcut) {
                    return()
                }

                plotData <- image4$state

                if (is.null(plotData)) {
                    return()
                }

                # if (plotData$not_continue_analysis) {
                #     return()
                # }

                res.cut <- plotData$res.cut

                name3contexpl <- plotData$name3contexpl

                plot4 <-
                    plot(res.cut, name3contexpl, palette = "npg")

                print(plot4)
                TRUE
            }


            # Survival Curve with new cut-off ----
            ,
            .plot5 = function(image5, ggtheme, theme, ...) {



                if (!self$options$findcut) {
                    return()
                }

                plotData <- image5$state

                if (is.null(plotData)) {
                    return()
                }

                # if (plotData$not_continue_analysis) {
                #     return()
                # }



                res.cat <- plotData$cutoffdata

                results <- plotData$results

                mytime <- results$name1time
                myoutcome <- results$name2outcome
                mycontexpl <- results$name3contexpl


                mytime <-
                    jmvcore::constructFormula(terms = mytime)

                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)

                mycontexpl <-
                    jmvcore::constructFormula(terms = mycontexpl)


                formula <-
                    paste('survival::Surv(',
                          mytime,
                          ',',
                          myoutcome,
                          ') ~ ',
                          mycontexpl)

                myformula <- as.formula(formula)


                fit <- survminer::surv_fit(
                    formula = myformula,
                    data = res.cat
                )

                plot5 <- survminer::ggsurvplot(
                    fit,
                    data = res.cat,
                    risk.table = self$options$risktable,
                    conf.int = self$options$ci95

                )
                print(plot5)
                TRUE
            }


            # Cumulative Events with new cut-off ----
            # https://rpkgs.datanovia.com/survminer/survminer_cheatsheet.pdf
            ,
            .plot2 = function(image2, ggtheme, theme, ...) {

                if (!self$options$findcut) {
                    return()
                }

                if (!self$options$ce) {
                    return()
                }

                plotData <- image2$state


                if (is.null(plotData)) {
                    return()
                }

                # if (plotData$not_continue_analysis) {
                #     return()
                # }

                res.cat <- plotData$cutoffdata

                results <- plotData$results

                mytime <- results$name1time
                myoutcome <- results$name2outcome
                mycontexpl <- results$name3contexpl

                mytime <-
                    jmvcore::constructFormula(terms = mytime)

                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)

                mycontexpl <-
                    jmvcore::constructFormula(terms = mycontexpl)


                myformula <-
                    paste0('survival::Surv(',
                          mytime,
                          ',',
                          myoutcome,
                          ')')

                title2 <- as.character(mycontexpl)

                plot2 <- res.cat %>%
                    finalfit::surv_plot(
                        .data = .,
                        dependent = myformula,
                        explanatory = mycontexpl,
                        xlab = paste0("Time (", self$options$timetypeoutput, ")"),
                        # pval = TRUE,
                        legend = "none",
                        break.time.by = self$options$byplot,
                        xlim = c(0, self$options$endplot),
                        ylim = c(
                            self$options$ybegin_plot,
                            self$options$yend_plot),
                        title = paste0("Cumulative Events ", title2),
                        fun = "event",
                        risk.table = self$options$risktable,
                        conf.int = self$options$ci95,
                        censor = self$options$censored,
                        surv.median.line = self$options$medianline

                    )


                print(plot2)
                TRUE
            }



            # Cumulative Hazard with new cut-off ----
            ,
            .plot3 = function(image3, ggtheme, theme, ...) {

                if (!self$options$findcut) {
                    return()
                }

                if (!self$options$ch) {
                    return()
                }

                plotData <- image3$state

                if (is.null(plotData)) {
                    return()
                }

                # if (plotData$not_continue_analysis) {
                #     return()
                # }

                res.cat <- plotData$cutoffdata

                results <- plotData$results

                mytime <- results$name1time
                myoutcome <- results$name2outcome
                mycontexpl <- results$name3contexpl


                mytime <-
                    jmvcore::constructFormula(terms = mytime)

                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)

                mycontexpl <-
                    jmvcore::constructFormula(terms = mycontexpl)


                myformula <-
                    paste('survival::Surv(',
                          mytime,
                          ',',
                          myoutcome,
                          ')')

                title2 <- as.character(mycontexpl)

                plot3 <- res.cat %>%
                    finalfit::surv_plot(
                        .data = .,
                        dependent = myformula,
                        explanatory = mycontexpl,
                        xlab = paste0("Time (", self$options$timetypeoutput, ")"),
                        # pval = TRUE,
                        legend = "none",
                        break.time.by = self$options$byplot,
                        xlim = c(0, self$options$endplot),
                        ylim = c(
                            self$options$ybegin_plot,
                            self$options$yend_plot),
                        title = paste0("Cumulative Hazard ", title2),
                        fun = "cumhaz",
                        risk.table = self$options$risktable,
                        conf.int = self$options$ci95,
                        censor = self$options$censored,
                        surv.median.line = self$options$medianline
                    )


                print(plot3)
                TRUE
            }


            # KMunicate Style with new cut-off ----
            ,
            .plot6 = function(image6, ggtheme, theme, ...) {

                if (!self$options$findcut) {
                    return()
                }

                if (!self$options$kmunicate) {
                    return()
                }

                plotData <- image6$state

                if (is.null(plotData)) {
                    return()
                }

                # if (plotData$not_continue_analysis) {
                #     return()
                # }

                res.cat <- plotData$cutoffdata

                results <- plotData$results

                mytime <- results$name1time
                myoutcome <- results$name2outcome
                mycontexpl <- results$name3contexpl


                mytime <-
                    jmvcore::constructFormula(terms = mytime)

                myoutcome <-
                    jmvcore::constructFormula(terms = myoutcome)

                mycontexpl <-
                    jmvcore::constructFormula(terms = mycontexpl)


                myformula <-
                    paste('survival::Surv(',
                          mytime,
                          ',',
                          myoutcome,
                          ') ~ ',
                          mycontexpl)

                myformula <- as.formula(myformula)

                # myformula <-
                #     paste0("survival::Surv(mytime, myoutcome) ~ ", contfactor)

                km_fit <- survival::survfit(myformula, data = res.cat)

                time_scale <-
                    seq(0, self$options$endplot, by = self$options$byplot)


                plot6 <-
                    KMunicate::KMunicate(
                        fit = km_fit,
                        time_scale = time_scale,
                        .xlab = paste0("Time in ", self$options$timetypeoutput)
                    )


                print(plot6)
                TRUE
            }
        )
    )
}


File: R\survivalcont.h.R
--------------------------------------------------
Content of R\survivalcont.h.R:

# This file is automatically generated, you probably don't want to edit this

survivalcontOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "survivalcontOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            elapsedtime = NULL,
            tint = FALSE,
            dxdate = NULL,
            fudate = NULL,
            contexpl = NULL,
            outcome = NULL,
            outcomeLevel = NULL,
            dod = NULL,
            dooc = NULL,
            awd = NULL,
            awod = NULL,
            analysistype = "overall",
            cutp = "12, 36, 60",
            timetypedata = "ymd",
            timetypeoutput = "months",
            uselandmark = FALSE,
            landmark = 3,
            sc = FALSE,
            kmunicate = FALSE,
            ce = FALSE,
            ch = FALSE,
            endplot = 60,
            ybegin_plot = 0,
            yend_plot = 1,
            byplot = 12,
            findcut = FALSE,
            multievent = FALSE,
            ci95 = FALSE,
            risktable = FALSE,
            censored = FALSE,
            medianline = "none", ...) {

            super$initialize(
                package="jsurvival",
                name="survivalcont",
                requiresData=TRUE,
                ...)

            private$..elapsedtime <- jmvcore::OptionVariable$new(
                "elapsedtime",
                elapsedtime,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..tint <- jmvcore::OptionBool$new(
                "tint",
                tint,
                default=FALSE)
            private$..dxdate <- jmvcore::OptionVariable$new(
                "dxdate",
                dxdate)
            private$..fudate <- jmvcore::OptionVariable$new(
                "fudate",
                fudate)
            private$..calculatedtime <- jmvcore::OptionOutput$new(
                "calculatedtime")
            private$..contexpl <- jmvcore::OptionVariable$new(
                "contexpl",
                contexpl,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..outcome <- jmvcore::OptionVariable$new(
                "outcome",
                outcome,
                suggested=list(
                    "ordinal",
                    "nominal",
                    "continuous"),
                permitted=list(
                    "factor",
                    "numeric"))
            private$..outcomeLevel <- jmvcore::OptionLevel$new(
                "outcomeLevel",
                outcomeLevel,
                variable="(outcome)")
            private$..dod <- jmvcore::OptionLevel$new(
                "dod",
                dod,
                variable="(outcome)",
                allowNone=TRUE)
            private$..dooc <- jmvcore::OptionLevel$new(
                "dooc",
                dooc,
                variable="(outcome)",
                allowNone=TRUE)
            private$..awd <- jmvcore::OptionLevel$new(
                "awd",
                awd,
                variable="(outcome)",
                allowNone=TRUE)
            private$..awod <- jmvcore::OptionLevel$new(
                "awod",
                awod,
                variable="(outcome)",
                allowNone=TRUE)
            private$..analysistype <- jmvcore::OptionList$new(
                "analysistype",
                analysistype,
                options=list(
                    "overall",
                    "cause",
                    "compete"),
                default="overall")
            private$..outcomeredefined <- jmvcore::OptionOutput$new(
                "outcomeredefined")
            private$..cutp <- jmvcore::OptionString$new(
                "cutp",
                cutp,
                default="12, 36, 60")
            private$..timetypedata <- jmvcore::OptionList$new(
                "timetypedata",
                timetypedata,
                options=list(
                    "ymdhms",
                    "ymd",
                    "ydm",
                    "mdy",
                    "myd",
                    "dmy",
                    "dym"),
                default="ymd")
            private$..timetypeoutput <- jmvcore::OptionList$new(
                "timetypeoutput",
                timetypeoutput,
                options=list(
                    "days",
                    "weeks",
                    "months",
                    "years"),
                default="months")
            private$..uselandmark <- jmvcore::OptionBool$new(
                "uselandmark",
                uselandmark,
                default=FALSE)
            private$..landmark <- jmvcore::OptionInteger$new(
                "landmark",
                landmark,
                default=3)
            private$..sc <- jmvcore::OptionBool$new(
                "sc",
                sc,
                default=FALSE)
            private$..kmunicate <- jmvcore::OptionBool$new(
                "kmunicate",
                kmunicate,
                default=FALSE)
            private$..ce <- jmvcore::OptionBool$new(
                "ce",
                ce,
                default=FALSE)
            private$..ch <- jmvcore::OptionBool$new(
                "ch",
                ch,
                default=FALSE)
            private$..endplot <- jmvcore::OptionInteger$new(
                "endplot",
                endplot,
                default=60)
            private$..ybegin_plot <- jmvcore::OptionNumber$new(
                "ybegin_plot",
                ybegin_plot,
                default=0)
            private$..yend_plot <- jmvcore::OptionNumber$new(
                "yend_plot",
                yend_plot,
                default=1)
            private$..byplot <- jmvcore::OptionInteger$new(
                "byplot",
                byplot,
                default=12)
            private$..findcut <- jmvcore::OptionBool$new(
                "findcut",
                findcut,
                default=FALSE)
            private$..calculatedcutoff <- jmvcore::OptionOutput$new(
                "calculatedcutoff")
            private$..multievent <- jmvcore::OptionBool$new(
                "multievent",
                multievent,
                default=FALSE)
            private$..ci95 <- jmvcore::OptionBool$new(
                "ci95",
                ci95,
                default=FALSE)
            private$..risktable <- jmvcore::OptionBool$new(
                "risktable",
                risktable,
                default=FALSE)
            private$..censored <- jmvcore::OptionBool$new(
                "censored",
                censored,
                default=FALSE)
            private$..medianline <- jmvcore::OptionList$new(
                "medianline",
                medianline,
                options=list(
                    "none",
                    "h",
                    "v",
                    "hv"),
                default="none")

            self$.addOption(private$..elapsedtime)
            self$.addOption(private$..tint)
            self$.addOption(private$..dxdate)
            self$.addOption(private$..fudate)
            self$.addOption(private$..calculatedtime)
            self$.addOption(private$..contexpl)
            self$.addOption(private$..outcome)
            self$.addOption(private$..outcomeLevel)
            self$.addOption(private$..dod)
            self$.addOption(private$..dooc)
            self$.addOption(private$..awd)
            self$.addOption(private$..awod)
            self$.addOption(private$..analysistype)
            self$.addOption(private$..outcomeredefined)
            self$.addOption(private$..cutp)
            self$.addOption(private$..timetypedata)
            self$.addOption(private$..timetypeoutput)
            self$.addOption(private$..uselandmark)
            self$.addOption(private$..landmark)
            self$.addOption(private$..sc)
            self$.addOption(private$..kmunicate)
            self$.addOption(private$..ce)
            self$.addOption(private$..ch)
            self$.addOption(private$..endplot)
            self$.addOption(private$..ybegin_plot)
            self$.addOption(private$..yend_plot)
            self$.addOption(private$..byplot)
            self$.addOption(private$..findcut)
            self$.addOption(private$..calculatedcutoff)
            self$.addOption(private$..multievent)
            self$.addOption(private$..ci95)
            self$.addOption(private$..risktable)
            self$.addOption(private$..censored)
            self$.addOption(private$..medianline)
        }),
    active = list(
        elapsedtime = function() private$..elapsedtime$value,
        tint = function() private$..tint$value,
        dxdate = function() private$..dxdate$value,
        fudate = function() private$..fudate$value,
        calculatedtime = function() private$..calculatedtime$value,
        contexpl = function() private$..contexpl$value,
        outcome = function() private$..outcome$value,
        outcomeLevel = function() private$..outcomeLevel$value,
        dod = function() private$..dod$value,
        dooc = function() private$..dooc$value,
        awd = function() private$..awd$value,
        awod = function() private$..awod$value,
        analysistype = function() private$..analysistype$value,
        outcomeredefined = function() private$..outcomeredefined$value,
        cutp = function() private$..cutp$value,
        timetypedata = function() private$..timetypedata$value,
        timetypeoutput = function() private$..timetypeoutput$value,
        uselandmark = function() private$..uselandmark$value,
        landmark = function() private$..landmark$value,
        sc = function() private$..sc$value,
        kmunicate = function() private$..kmunicate$value,
        ce = function() private$..ce$value,
        ch = function() private$..ch$value,
        endplot = function() private$..endplot$value,
        ybegin_plot = function() private$..ybegin_plot$value,
        yend_plot = function() private$..yend_plot$value,
        byplot = function() private$..byplot$value,
        findcut = function() private$..findcut$value,
        calculatedcutoff = function() private$..calculatedcutoff$value,
        multievent = function() private$..multievent$value,
        ci95 = function() private$..ci95$value,
        risktable = function() private$..risktable$value,
        censored = function() private$..censored$value,
        medianline = function() private$..medianline$value),
    private = list(
        ..elapsedtime = NA,
        ..tint = NA,
        ..dxdate = NA,
        ..fudate = NA,
        ..calculatedtime = NA,
        ..contexpl = NA,
        ..outcome = NA,
        ..outcomeLevel = NA,
        ..dod = NA,
        ..dooc = NA,
        ..awd = NA,
        ..awod = NA,
        ..analysistype = NA,
        ..outcomeredefined = NA,
        ..cutp = NA,
        ..timetypedata = NA,
        ..timetypeoutput = NA,
        ..uselandmark = NA,
        ..landmark = NA,
        ..sc = NA,
        ..kmunicate = NA,
        ..ce = NA,
        ..ch = NA,
        ..endplot = NA,
        ..ybegin_plot = NA,
        ..yend_plot = NA,
        ..byplot = NA,
        ..findcut = NA,
        ..calculatedcutoff = NA,
        ..multievent = NA,
        ..ci95 = NA,
        ..risktable = NA,
        ..censored = NA,
        ..medianline = NA)
)

survivalcontResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "survivalcontResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        coxSummary = function() private$.items[["coxSummary"]],
        coxTable = function() private$.items[["coxTable"]],
        tCoxtext2 = function() private$.items[["tCoxtext2"]],
        rescutTable = function() private$.items[["rescutTable"]],
        plot4 = function() private$.items[["plot4"]],
        plot5 = function() private$.items[["plot5"]],
        medianSummary = function() private$.items[["medianSummary"]],
        medianTable = function() private$.items[["medianTable"]],
        survTableSummary = function() private$.items[["survTableSummary"]],
        survTable = function() private$.items[["survTable"]],
        plot2 = function() private$.items[["plot2"]],
        plot3 = function() private$.items[["plot3"]],
        plot6 = function() private$.items[["plot6"]],
        calculatedtime = function() private$.items[["calculatedtime"]],
        outcomeredefined = function() private$.items[["outcomeredefined"]],
        calculatedcutoff = function() private$.items[["calculatedcutoff"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Survival Analysis for Continuous Explanatory Variable",
                refs=list(
                    "finalfit",
                    "survival",
                    "survminer",
                    "dichotomizing",
                    "survivaltutorial",
                    "survivalrwnahhas",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="To Do"))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="coxSummary",
                title="`Cox Regression Summary and Table - ${contexpl}`",
                clearWith=list(
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Table$new(
                options=options,
                name="coxTable",
                title="`Cox Table- ${contexpl}`",
                rows=0,
                columns=list(
                    list(
                        `name`="Explanatory", 
                        `title`="Explanatory", 
                        `type`="text"),
                    list(
                        `name`="Levels", 
                        `title`="Levels", 
                        `type`="text"),
                    list(
                        `name`="all", 
                        `title`="all", 
                        `type`="text"),
                    list(
                        `name`="HR_univariable", 
                        `title`="HR (Univariable)", 
                        `type`="text"),
                    list(
                        `name`="HR_multivariable", 
                        `title`="HR (Multivariable)", 
                        `type`="text")),
                clearWith=list(
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Html$new(
                options=options,
                name="tCoxtext2",
                title="",
                refs="finalfit",
                clearWith=list(
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Table$new(
                options=options,
                name="rescutTable",
                title="Cut Point",
                rows=0,
                columns=list(
                    list(
                        `name`="cutpoint", 
                        `title`="Cut Point", 
                        `type`="number"),
                    list(
                        `name`="statistic", 
                        `title`="Statistic", 
                        `type`="number")),
                visible="(findcut)",
                clearWith=list(
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot4",
                title="Cutpoint Plot",
                width=600,
                height=450,
                renderFun=".plot4",
                visible="(findcut)",
                requiresData=TRUE,
                clearWith=list(
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot5",
                title="`Survival Plot - ${contexpl} Grouped with New Cut-Off`",
                width=600,
                height=450,
                renderFun=".plot5",
                visible="(findcut && sc)",
                requiresData=TRUE,
                clearWith=list(
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="medianSummary",
                title="`Median Survival Summary and Table - ${contexpl}`",
                visible="(findcut)",
                clearWith=list(
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Table$new(
                options=options,
                name="medianTable",
                title="`Median Survival Table: Levels for ${contexpl}`",
                rows=0,
                columns=list(
                    list(
                        `name`="factor", 
                        `title`="Levels", 
                        `type`="text"),
                    list(
                        `name`="records", 
                        `title`="Records", 
                        `type`="number"),
                    list(
                        `name`="events", 
                        `title`="Events", 
                        `type`="integer"),
                    list(
                        `name`="rmean", 
                        `title`="rmean", 
                        `type`="number"),
                    list(
                        `name`="se_rmean", 
                        `title`="se_rmean", 
                        `type`="number"),
                    list(
                        `name`="median", 
                        `title`="Median", 
                        `type`="number"),
                    list(
                        `name`="x0_95lcl", 
                        `title`="Lower", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number"),
                    list(
                        `name`="x0_95ucl", 
                        `title`="Upper", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number")),
                visible="(findcut)",
                clearWith=list(
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="survTableSummary",
                title="`1, 3, 5-yr Survival Summary and Table  - ${contexpl}`",
                visible="(findcut)",
                clearWith=list(
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Table$new(
                options=options,
                name="survTable",
                title="`1, 3, 5 year Survival - ${contexpl}`",
                rows=0,
                columns=list(
                    list(
                        `name`="strata", 
                        `title`="Levels", 
                        `type`="text"),
                    list(
                        `name`="time", 
                        `title`="time", 
                        `type`="integer"),
                    list(
                        `name`="n.risk", 
                        `title`="Number at Risk", 
                        `type`="integer"),
                    list(
                        `name`="n.event", 
                        `title`="Number of Events", 
                        `type`="integer"),
                    list(
                        `name`="surv", 
                        `title`="Survival", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="lower", 
                        `title`="Lower", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="upper", 
                        `title`="Upper", 
                        `superTitle`="95% Confidence Interval", 
                        `type`="number", 
                        `format`="pc")),
                visible="(findcut)",
                clearWith=list(
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot2",
                title="`Cumulative Events  - ${contexpl} Grouped with New Cut-Off`",
                width=600,
                height=450,
                renderFun=".plot2",
                visible="(findcut && ce)",
                requiresData=TRUE,
                clearWith=list(
                    "ce",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot3",
                title="`Cumulative Hazard  - ${contexpl} Grouped with New Cut-Off`",
                width=600,
                height=450,
                renderFun=".plot3",
                visible="(findcut && ch)",
                requiresData=TRUE,
                clearWith=list(
                    "ch",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Image$new(
                options=options,
                name="plot6",
                title="`KMunicate-Style Plot  - ${contexpl} Grouped with New Cut-Off`",
                width=600,
                height=450,
                renderFun=".plot6",
                visible="(findcut && kmunicate)",
                requiresData=TRUE,
                clearWith=list(
                    "kmunicate",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent"),
                refs=list(
                    "KMunicate",
                    "KMunicate2")))
            self$add(jmvcore::Output$new(
                options=options,
                name="calculatedtime",
                title="Add Calculated Time to Data",
                varTitle="`Calculated Time in Continious Survival Function - from ${ dxdate } to { fudate }`",
                varDescription="Calculated Time from given Dates in Continious Survival Function",
                clearWith=list(
                    "tint",
                    "dxdate",
                    "fudate",
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Output$new(
                options=options,
                name="outcomeredefined",
                title="Add Redefined Outcome to Data",
                varTitle="`Redefined Outcome in Continious Survival Function - from ${ outcome } for analysis { analysistype }`",
                varDescription="Redefined Outcome from Outcome based on Analysis Type in Continious Survival Function",
                clearWith=list(
                    "outcome",
                    "analysistype",
                    "multievent",
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))
            self$add(jmvcore::Output$new(
                options=options,
                name="calculatedcutoff",
                title="Add Calculated Cut-off Group to Data",
                varTitle="`Calculated Cut-off Group - from ${ contexpl }`",
                varDescription="Calculated Cut-off Group from given Cut-off in Continious Survival Function",
                clearWith=list(
                    "outcome",
                    "analysistype",
                    "multievent",
                    "contexpl",
                    "findcut",
                    "sc",
                    "endplot",
                    "byplot",
                    "ci95",
                    "risktable",
                    "outcome",
                    "outcomeLevel",
                    "overalltime",
                    "findcut",
                    "contexpl",
                    "fudate",
                    "dxdate",
                    "tint",
                    "multievent")))}))

survivalcontBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "survivalcontBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "jsurvival",
                name = "survivalcont",
                version = c(1,0,0),
                options = options,
                results = survivalcontResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'none')
        }))

#' Survival Analysis for Continuous Variable
#'
#' 
#' @param data The data as a data frame.
#' @param elapsedtime The time-to-event or follow-up duration for each
#'   patient. Should be numeric and continuous, measured in consistent units
#'   (e.g., months or years). Can be calculated automatically from dates if
#'   using the date options below.
#' @param tint Enable this option if you want to calculate survival time from
#'   dates in your data. This is useful when you have separate columns for
#'   diagnosis date and follow-up date and want to calculate the time elapsed
#'   between them.
#' @param dxdate The date of diagnosis or study entry for each patient. Should
#'   be in a consistent date format (e.g., YYYY-MM-DD).
#' @param fudate The date of last follow-up or event for each patient. Should
#'   be in a consistent date format (e.g., YYYY-MM-DD).
#' @param contexpl The continuous explanatory variable to be used in the
#'   analysis.
#' @param outcome The outcome variable to be used in the analysis.
#' @param outcomeLevel The level of the outcome variable that represents the
#'   event of interest.
#' @param dod .
#' @param dooc .
#' @param awd .
#' @param awod Select the levels of the outcome variable that correspond to
#'   different event types in your data. For example, you might have separate
#'   levels for "Dead of Disease" and "Alive w Disease" in a survival analysis
#'   of cancer patients.
#' @param analysistype Select the type of survival analysis to perform.
#'   "Overall" survival analysis considers all events as equivalent, while
#'   "Cause Specific" analysis distinguishes between different event types.
#'   "Competing Risk" analysis accounts for competing risks that may prevent the
#'   event of interest from occurring.
#' @param cutp Specify the cutpoints at which to divide the continuous
#'   explanatory variable into groups for survival analysis. Separate multiple
#'   cutpoints with commas (e.g., "12, 36, 60").
#' @param timetypedata select the time type in data
#' @param timetypeoutput select the time type in output
#' @param uselandmark Enable this option to perform landmark survival analysis
#'   at a specified time point.
#' @param landmark Specify the landmark time at which to evaluate survival
#'   probabilities in landmark analysis. This option is only available if you
#'   enable the "Use Landmark Time" option.
#' @param sc Enable this option to create a Kaplan-Meier survival plot for the
#'   continuous explanatory variable.
#' @param kmunicate Enable this option to create a KMunicate-style survival
#'   plot for the continuous explanatory variable.
#' @param ce Enable this option to create a plot of cumulative events over
#'   time for the continuous explanatory variable.
#' @param ch Enable this option to create a plot of cumulative hazard over
#'   time for the continuous explanatory variable.
#' @param endplot Specify the end time for the survival plots. This option
#'   determines the maximum time point to include in the plots.
#' @param ybegin_plot Specify the starting value for the y-axis in the
#'   survival plots. This option allows you to customize the range of the
#'   y-axis.
#' @param yend_plot Specify the ending value for the y-axis in the survival
#'   plots. This option allows you to customize the range of the y-axis.
#' @param byplot Specify the time interval for the survival plots. This option
#'   determines the spacing of tick marks on the x-axis.
#' @param findcut Enable this option to automatically find the optimal cut-off
#'   point for the continuous explanatory variable using the maximally selected
#'   rank statistic. This option is only available if you enable the "Survival
#'   Plot" option. The optimal cut-off point will be displayed on the survival
#'   plot as a vertical dashed line.
#' @param multievent Enable this option if your data includes multiple event
#'   levels (e.g., different types of events or outcomes). This option is
#'   required for cause-specific and competing risk survival analyses.
#' @param ci95 Enable this option to display 95\% confidence intervals around
#'   the survival estimates in the plots.
#' @param risktable Enable this option to display a table of risk estimates
#'   for each group in the survival analysis.
#' @param censored Enable this option to display censored observations in the
#'   survival plots.
#' @param medianline If true, displays a line indicating the median survival
#'   time on the survival plot.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$coxSummary} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$coxTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$tCoxtext2} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$rescutTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$plot4} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plot5} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$medianSummary} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$medianTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$survTableSummary} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$survTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$plot2} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plot3} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$plot6} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$calculatedtime} \tab \tab \tab \tab \tab an output \cr
#'   \code{results$outcomeredefined} \tab \tab \tab \tab \tab an output \cr
#'   \code{results$calculatedcutoff} \tab \tab \tab \tab \tab an output \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$coxTable$asDF}
#'
#' \code{as.data.frame(results$coxTable)}
#'
#' @export
survivalcont <- function(
    data,
    elapsedtime,
    tint = FALSE,
    dxdate,
    fudate,
    contexpl,
    outcome,
    outcomeLevel,
    dod,
    dooc,
    awd,
    awod,
    analysistype = "overall",
    cutp = "12, 36, 60",
    timetypedata = "ymd",
    timetypeoutput = "months",
    uselandmark = FALSE,
    landmark = 3,
    sc = FALSE,
    kmunicate = FALSE,
    ce = FALSE,
    ch = FALSE,
    endplot = 60,
    ybegin_plot = 0,
    yend_plot = 1,
    byplot = 12,
    findcut = FALSE,
    multievent = FALSE,
    ci95 = FALSE,
    risktable = FALSE,
    censored = FALSE,
    medianline = "none") {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("survivalcont requires jmvcore to be installed (restart may be required)")

    if ( ! missing(elapsedtime)) elapsedtime <- jmvcore::resolveQuo(jmvcore::enquo(elapsedtime))
    if ( ! missing(dxdate)) dxdate <- jmvcore::resolveQuo(jmvcore::enquo(dxdate))
    if ( ! missing(fudate)) fudate <- jmvcore::resolveQuo(jmvcore::enquo(fudate))
    if ( ! missing(contexpl)) contexpl <- jmvcore::resolveQuo(jmvcore::enquo(contexpl))
    if ( ! missing(outcome)) outcome <- jmvcore::resolveQuo(jmvcore::enquo(outcome))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(elapsedtime), elapsedtime, NULL),
            `if`( ! missing(dxdate), dxdate, NULL),
            `if`( ! missing(fudate), fudate, NULL),
            `if`( ! missing(contexpl), contexpl, NULL),
            `if`( ! missing(outcome), outcome, NULL))


    options <- survivalcontOptions$new(
        elapsedtime = elapsedtime,
        tint = tint,
        dxdate = dxdate,
        fudate = fudate,
        contexpl = contexpl,
        outcome = outcome,
        outcomeLevel = outcomeLevel,
        dod = dod,
        dooc = dooc,
        awd = awd,
        awod = awod,
        analysistype = analysistype,
        cutp = cutp,
        timetypedata = timetypedata,
        timetypeoutput = timetypeoutput,
        uselandmark = uselandmark,
        landmark = landmark,
        sc = sc,
        kmunicate = kmunicate,
        ce = ce,
        ch = ch,
        endplot = endplot,
        ybegin_plot = ybegin_plot,
        yend_plot = yend_plot,
        byplot = byplot,
        findcut = findcut,
        multievent = multievent,
        ci95 = ci95,
        risktable = risktable,
        censored = censored,
        medianline = medianline)

    analysis <- survivalcontClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}



